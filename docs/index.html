<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>CephaloPOV Documentation</title>
<style type="text/css">
	body,table,input { font: 10pt Arial,Helvetica,sans-serif; }
    body { width: 8.5in; margin-left: auto; margin-right: auto; }
	div.code { white-space: pre; font: 10pt Consolas,Courier,fixed; background-color: #EEF; border: 1px solid #CCF; margin-top: 1em; padding: 1em; }
    code { font: 10pt Consolas,Courier,fixed; }
    pre { font: 10pt Consolas,Courier,fixed; }
    table.matrixDemo { background-color: black; border-spacing: 1pt; margin-left: auto; margin-right: auto; }
    table.matrixDemo th { color: white; width: 20%; padding: 0.5em; }
    table.matrixDemo td { background-color: white; vertical-align: top; padding: 0.25em; }
    table.matrixDemo td.implicit { background-color: #CCC; }
    table.matrixDemo td.scale { background-color: #FAA; }
    table.matrixDemo td.translate { background-color: #AAF; }
    table.matrixDemo td.skew { background-color: #AFA; }
    table.matrixDemo div.cpName { text-align: center; font: bold 10pt Consolas,Courier,fixed; }
    table.matrixDemo div.op { text-align: center; font-weight: bold; margin-top: 0.25em; }
</style>
</head>
<body>
<h1>CephaloPOV Documentation</h1>

<div class='code'>Before CephaloPOV reaches a preliminary beta phase, this will
be the user manual. Right now, it's mostly notes.</div>

<h2>Introduction</h2>

<p>CephaloPOV is a JavaScript scripting engine for POV-Ray. It is implemented as
a Node command line program that loads a user script and executes it. User
scripts manipulate various JavaScript classes that map to POV-Ray's native
objects, in addition to having full access to the Node ecosystem. CephaloPOV
takes care of generating POV-Ray Scene Description Language files, both for
static scenes and multi-frame animations.</p>

<h2>Appendix A: Matrices</h2>

<p>SDL matrices are an abbreviated form of the entire matrix being used. The
fourth column is invariant and therefore omitted from its SDL representation and
inaccessible within CephaloPOV, but we'll show it here in grey for the
math-curious. You <em>don't</em> have to know much about matrix math to use the
<code>Matrix</code> class. Like SDL, CephaloPOV offers shortcuts to the
individual transformations in the form of special arguments to the
<code>Matrix</code> constructor and the <code>apply</code> method.</p>

<p>If you want to know more, Jeff Lee's <a
href="https://www.shipbrook.net/jeff/raytrace/matrix.html">POV-Ray-specific
tutorial</a> is a good place to start, as are these <a
href="https://courses.cs.washington.edu/courses/cse457/99au/handouts/lectures/3d-transformations.pdf">course
notes</a>. To dig deeper than that&mdash;and there's
a <em>lot</em> more you can do with matrices&mdash;the topic is covered in depth
in 3D graphics and linear algebra textbooks. And don't be scared off: it's far
more tedious than difficult.</p>



<table class='matrixDemo'>
    <tr><th></th><th>Column<br/>0</th><th>Column<br/>1</th><th>Column<br/>2</th><th>Column<br/>3</th></tr>
    <tr>
        <th>Row<br/>0</th>
        <td class='scale'><div class='cpName'>v00</div><div class='op'>Scale X</div></td>
        <td class='skew'><div class='cpName'>v01</div><div class='op'>Skew Y by X</div></td>
        <td class='skew'><div class='cpName'>v02</div><div class='op'>Skew Z by X</div></td>
        <td class='implicit'><div class='cpName'>(v03)</div><div class='op'>0</div></td>
    </tr><tr>
        <th>Row<br/>1</th>
        <td class='skew'><div class='cpName'>v10</div><div class='op'>Skew X by Y</div></td>
        <td class='scale'><div class='cpName'>v11</div><div class='op'>Scale Y</div></td>
        <td class='skew'><div class='cpName'>v12</div><div class='op'>Skew Z by Y</div></td>
        <td class='implicit'><div class='cpName'>(v13)</div><div class='op'>0</div></td>
    </tr><tr>
        <th>Row<br/>2</th>
        <td class='skew'><div class='cpName'>v20</div><div class='op'>Skew X by Z</div></td>
        <td class='skew'><div class='cpName'>v21</div><div class='op'>Skew Y by Z</div></td>
        <td class='scale'><div class='cpName'>v22</div><div class='op'>Scale Z</div></td>
        <td class='implicit'><div class='cpName'>(v23)</div><div class='op'>0</div></td>
    </tr><tr>
        <th>Row<br/>3</th>
        <td class='translate'><div class='cpName'>v30</div><div class='op'>Translate X</div></td>
        <td class='translate'><div class='cpName'>v31</div><div class='op'>Translate Y</div></td>
        <td class='translate'><div class='cpName'>v32</div><div class='op'>Translate Z</div></td>
        <td class='implicit'><div class='cpName'>(v33)</div><div class='op'>1</div></td>
    </tr>
</table>

<!--

 If we were to rotate an object 45 degrees around the Z axis, we would use the following statement:

            matrix < cos(a), sin(a), 0,
                    -sin(a), cos(a), 0,
                       0,      0,    1,
                       0,      0,    0 >

The course notes I found, taken from Mathematical Elements for Computer Graphics, 2ed,
Rogers and Adams, 1990, gives the following Z axis rotation (note the fourth,
invariant column):

        Rz = [ cos(a), -sin(a), 0, 0,
               sin(a),  cos(a), 0, 0,
                    0,       0, 1, 0,
                    0,       0, 0, 1 ]

I'll have to test to find out for sure, but I think the reversal of the signs of
the two sine functions is because the second source uses a right-handed coordinate
system while POV-Ray uses a left-handed system.

The other two rotation matrices in Rogers and Adams are as follows:

        Rx = [ 1,      0,       0, 0,
               0, cos(a), -sin(a), 0,
               0, sin(a),  cos(a), 0,
               0,      0,       0, 1 ]

        Ry  = [  cos(a), 0, sin(a), 0,
                      0, 1,      0, 0,
                -sin(a), 0, cos(a), 0,
                      0, 0,      0, 1 ]

-->


<h2>TODO</h2>

<h3>Milestone C0: core system implementation and shakedown</h3>

<pre>Type coercion
    Matrix
        toSDL
        rotate } ... in progress; will need to experiment to figure out
        skew   }     the mapping between SDL matrices and proper matrices
    Try conversion and assignment in validator for matrices?

    reqTest in snippets for use in toSDL methods, or maybe revalidate
    Get SDL vector or SDL function out of vector params automatically
    Add toSDL alias 'toString' to SDL function params

parent/child updates for CSG, blobs, sphere sweeps, parametrics, etc.; subcomponents generally
CSG output

Frame output routine

[use --preamble or --sdlIncludes for atmospheric effects until implemented]</pre>

Implicit fourth column in transformation matrix documentation.

<h3>Milestone C1: preparation for public beta</h3>

<pre>
Array of arrays or objects to vectors
copy() method across classes, both shallow and deep
Remaining primitives
    snippet: isoSurface.toSDL -- need to examine examples of functions
    snippet: mesh.toSDL
    snippet: mesh2.toSDL
    snippet: polynomial.toSDL
Wrap Array attributes with Proxies to enforce type
Matrix, Vector, Color
    Use JS/SDL func in lieu of individual attributes
Reorg
    Move things needed for codegen to separate file not included at runtime
    Script to pretty-print definition files
Camera pseudo-primitive transform integration
codegen
    Documentation generation
    Reports
Regression tests
Primitive
    .photons
    .radiosity
ImageOptions
    boundingThreshold: convert zero to boolean on output
    constants: gets special handling
    endColumn: post check startColumn
    endRow: post check startRow
    startColumn: post check endColumn
    startRow: post check endRow
Execution
    Optionally generate .sh/.bat files
    Oversee execution directly
</pre>


<h3>Backlog</h3>

<pre>Output frame range
https://www.npmjs.com/package/ml-matrix
Additional splines, easing functions, esp. Catmull-Rom
Interior
Texture
Macro/Function generation, i.e., in separate file to use directly with POV-Ray
Color and texture SDL generation, i.e., in separate file to use directly with POV-Ray
Script to parse as much as possible of POV-Ray .inc files into JS/cpov
Porting of functions in .inc files
Drag in some color libraries, theme generators
Atmospheric effects
Spline-builder UI
Stereo pseudo-cameras
Parametric types
Polyhedron library
Level-of-Detail
Particle systems
Geometric query system
    Eric Haines' table of object intersections, collision detection
Primitive
    tick order
Direct support for ffmpeg + Google speech API
Script execution on events
Extensive warn, info, debug output</pre>


<h4>CephaloPOV Scene Graph</h4>

<p>Master objects are defined relative to the origin. More precisely, the origin is
their primary point of articulation. In each frame, they are transformed to
their current frame-state.</p>

Possibly, a relationship between A and B is stated in the form of B's point of
articulation relative to some explicit or implicit point in A. In its most basic
form, this would amount to free movement of B relative to its attachment point
to A. PSII could provide a set of standard constraints, e.g., ball joint, hinge,
track, etc., which could be built upon or supplanted by the user.

This suggests a separate assembly process for objects with moving parts, which
means that ordinary native CSG objects can go ahead just fine. Converting them
into master objects amounts to just positioning them appropriately relative to
the origin after construction.


/*

npm install -g sloc        ... cronify

*/
</pre>

<h2>Changelog</h2>

<p>Oh geez, not yet.</p>

</body>
</html>