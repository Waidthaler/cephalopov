<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">

<!--

Copyright 2018-2019 Eric O'Dell and subsequent contributors

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies of
the Software, and to permit persons to whom the Software is furnished to do so,
subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, FITNESS
FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR
COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER
IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE SOFTWARE.

-->

<title>CephaloPOV Documentation</title>
<style type="text/css">

@font-face { font-family: ArchivoNarrow; src: url("fonts/archivonarrow/ArchivoNarrow-Regular.ttf"); }
@font-face { font-family: ArchivoNarrow; src: url("fonts/archivonarrow/ArchivoNarrow-Bold.ttf"); font-weight: bold; }
@font-face { font-family: ArchivoNarrow; src: url("fonts/archivonarrow/ArchivoNarrow-BoldItalic.ttf"); font-weight: bold; font-style: italic; }
@font-face { font-family: ArchivoNarrow; src: url("fonts/archivonarrow/ArchivoNarrow-Italic.ttf"); font-style: italic; }

@font-face { font-family: ArchivoNarrowSemiBold; src: url("fonts/archivonarrow/ArchivoNarrow-SemiBold.ttf"); }
@font-face { font-family: ArchivoNarrowSemiBold; src: url("fonts/archivonarrow/ArchivoNarrow-SemiBoldItalic.ttf"); font-style: italic; }

@font-face { font-family: ArchivoNarrowMedium; src: url("./fonts/archivonarrow/ArchivoNarrow-Medium.ttf"); }
@font-face { font-family: ArchivoNarrowMedium; src: url("./fonts/archivonarrow/ArchivoNarrow-MediumItalic.ttf"); font-style: italic; }

@font-face { font-family: Chivo; src: url("./fonts/chivo/Chivo-Bold.ttf"); font-weight: bold; }
@font-face { font-family: Chivo; src: url("./fonts/chivo/Chivo-BoldItalic.ttf"); font-weight: bold; font-style: italic; }
@font-face { font-family: Chivo; src: url("./fonts/chivo/Chivo-Italic.ttf"); font-style: italic; }
@font-face { font-family: Chivo; src: url("./fonts/chivo/Chivo-Regular.ttf"); }

@font-face { font-family: ChivoBlack; src: url("./fonts/chivo/Chivo-Black.ttf"); }
@font-face { font-family: ChivoBlack; src: url("./fonts/chivo/Chivo-BlackItalic.ttf"); font-style: italic; }

@font-face { font-family: ChivoLight; src: url("./fonts/chivo/Chivo-Light.ttf"); }
@font-face { font-family: ChivoLight; src: url("./fonts/chivo/Chivo-LightItalic.ttf"); font-style: italic; }

@font-face { font-family: Inconsolata; src: url("./fonts/inconsolata/Inconsolata-Bold.ttf"); font-weight: bold; }
@font-face { font-family: Inconsolata; src: url("./fonts/inconsolata/Inconsolata-Regular.ttf"); }

@font-face { font-family: RobotoBlack; src: url("./fonts/roboto/Roboto-Black.ttf"); }
@font-face { font-family: RobotoBlack; src: url("./fonts/roboto/Roboto-BlackItalic.ttf"); font-style: italic; }

@font-face { font-family: Roboto; src: url("./fonts/roboto/Roboto-Bold.ttf"); font-weight: bold; }
@font-face { font-family: Roboto; src: url("./fonts/roboto/Roboto-BoldItalic.ttf"); font-weight: bold; font-style: italic; }
@font-face { font-family: Roboto; src: url("./fonts/roboto/Roboto-Italic.ttf"); font-style: italic; }
@font-face { font-family: Roboto; src: url("./fonts/roboto/Roboto-Regular.ttf"); }

@font-face { font-family: RobotoLight; src: url("./fonts/roboto/Roboto-Light.ttf"); }
@font-face { font-family: RobotoLight; src: url("./fonts/roboto/Roboto-LightItalic.ttf"); font-style: italic; }

@font-face { font-family: RobotoMedium; src: url("./fonts/roboto/Roboto-Medium.ttf"); }
@font-face { font-family: RobotoMedium; src: url("./fonts/roboto/Roboto-MediumItalic.ttf"); font-style: italic; }

@font-face { font-family: RobotoThin; src: url("./fonts/roboto/Roboto-Thin.ttf"); }
@font-face { font-family: RobotoThin; src: url("./fonts/roboto/Roboto-ThinItalic.ttf"); font-style: italic; }

@font-face { font-family: RobotoCondensed; src: url("./fonts/robotocondensed/RobotoCondensed-Bold.ttf"); font-weight: bold; }
@font-face { font-family: RobotoCondensed; src: url("./fonts/robotocondensed/RobotoCondensed-BoldItalic.ttf"); font-weight: bold; font-style: italic; }
@font-face { font-family: RobotoCondensed; src: url("./fonts/robotocondensed/RobotoCondensed-Italic.ttf"); font-style: italic; }
@font-face { font-family: RobotoCondensed; src: url("./fonts/robotocondensed/RobotoCondensed-Regular.ttf"); }

@font-face { font-family: RobotoCondensedLight; src: url("./fonts/robotocondensed/RobotoCondensed-Light.ttf"); }
@font-face { font-family: RobotoCondensedLight; src: url("./fonts/robotocondensed/RobotoCondensed-LightItalic.ttf"); font-style: italic; }

@font-face { font-family: LogicTwentyFive; src: url("./fonts/Logic twenty-five A.ttf"); }

body,table,input { font: 10pt Roboto; }
body { width: 7.5in; margin-left: auto; margin-right: auto; counter-reset: h2counter; }
div.code { white-space: pre; font: 10pt Inconsolata; background-color: #E1F1F7; border: 1px dashed #3C607B; margin-top: 1em; margin-bottom: 1em; padding: 1em; clear: both; }
code { font: bold 10pt Inconsolata; }
pre { font: 10pt Inconsolata; }
.beta { color: #A00; }
p,li { text-align: justify; }
.fixme { color: #A00; background-color: #FF0; font-weight: bold; }
a { text-decoration: none; }

h1 { counter-reset: h2counter; font: 36pt ChivoBlack; position: relative; color: #3C607B; top: 36pt; text-shadow: 2pt 2pt 2pt #AAA; }
h2 { counter-reset: h3counter; font-size: 22pt; color: white; background-color: #3C607B; padding: 0.25em 0.0em 0.25em 0.5em; margin-top: 2.5em; margin-bottom: 0.6em; font-family: ChivoBlack; border-top-right-radius: 40px; text-shadow: 2pt 2pt #263E4F; }
h3 { counter-reset: h4counter; font-size: 14pt; color: white; background-color: #3C607B; margin-top: 2em; margin-bottom: 0.5em; padding: 0.15em 0.15em 0.15em 0.35em; font-family: Chivo; }
h4 { counter-reset: h5counter; font-size: 14pt; color: #263E4F; margin-top: 1.5em; margin-bottom: 0.3em; border-bottom: 1.5pt solid #263E4F; font-family: Chivo; }
h5 { font-size: 13pt; color: #263E4F; margin-top: 1em; margin-bottom: 0.4em; font-family: Chivo; }
h6 { font-size: 11pt; color: #263E4F; margin-top: 1em; margin-bottom: 0.4em; font-family: Chivo; font-weight: bold; }

span.h2num { margin: 0pt 0pt 36pt 12pt; font: 144pt LogicTwentyFive; float: right; position: relative; bottom: 18pt; left: 13pt; color: #3C607B; }
span.h2num:before { content: counter(h2counter); }

h2:before { counter-increment: h2counter; content: counter(h2counter) "\0000a0\0000a0";                                               }
h3:before { counter-increment: h3counter; content: counter(h2counter) "." counter(h3counter) "\0000a0\0000a0";                        }
h4:before { counter-increment: h4counter; content: counter(h2counter) "." counter(h3counter) "." counter(h4counter) "\0000a0\0000a0"; }

div.h1 { margin-left: 0em; counter-reset: toc2counter; }
div.h2 { margin-left: 0em; counter-reset: toc3counter; font: bold 13pt Chivo; margin-top: 0.75em; }
div.h3 { margin-left: 1em; counter-reset: toc4counter; font: bold 12pt Chivo; margin-top: 0.25em; }
div.h4 { margin-left: 2em; counter-reset: toc5counter; font: 11pt Chivo; }
div.h5 { margin-left: 3em; font: 10pt Chivo; }

div.h2:before { counter-increment: toc2counter; content: counter(toc2counter) "\0000a0\0000a0";                                               }
div.h3:before { counter-increment: toc3counter; content: counter(toc2counter) "." counter(toc3counter) "\0000a0\0000a0";                        }
div.h4:before { counter-increment: toc4counter; content: counter(toc2counter) "." counter(toc3counter) "." counter(toc4counter) "\0000a0\0000a0"; }

p { margin-top: 0em; margin-bottom: 0.75em; }
ul.spacious li { padding-top: 0.5em; }
ol.spacious li { padding-top: 0.5em; }

table.matrixDemo { background-color: black; border-spacing: 1pt; margin-left: auto; margin-right: auto; font-size: 90%; margin-top: 1em; margin-bottom: 2em; }
table.matrixDemo th { color: white; width: 20%; padding: 0.5em; }
table.matrixDemo td { background-color: white; vertical-align: top; padding: 0.25em; }
table.matrixDemo td.implicit { background-color: #CCC; }
table.matrixDemo td.scale { background-color: #FAA; }
table.matrixDemo td.translate { background-color: #AAF; }
table.matrixDemo td.skew { background-color: #AFA; }
table.matrixDemo td.rotate { background-color: #FAA; }
table.matrixDemo td.ident { background-color: #AAF; }
table.matrixDemo td.null { background-color: #CCC; }
table.matrixDemo div.cpName { text-align: center; font: bold 10pt Inconsolata; }
table.matrixDemo div.op { text-align: center; font-weight: bold; margin-top: 0.25em; }

table.sgrid { margin-top: 0.5em; border-collapse: collapse; }
table.sgrid > thead { background-color: #263E4F;  color: white; }
table.sgrid > td { padding-left: 0.5em; padding-right: 0.5em; vertical-align: top; }
table.sgrid td { border: 0.25pt solid black; }
table.sgrid th { background-color: #3C607B; border: 0.25pt solid black; }

table.todo { width: 100%; }
table.todo td.pending { text-align: center; background-color: #A00;    color: yellow; font-weight: bold; white-space: nowrap; }
table.todo td.working { text-align: center; background-color: yellow;  color: #A00;   font-weight: bold; white-space: nowrap; }
table.todo td.done    { text-align: center; background-color: #060;    color: white;  font-weight: bold; white-space: nowrap; }
table.todo td.tbd     { text-align: center; background-color: #3C607B; color: white;  font-weight: bold; white-space: nowrap; }
table.todo td.subtask { padding-left: 3em; }
table.todo > tbody > tr > td:nth-child(2) { text-align: center; }
table.todo > tbody > tr > td:nth-child(3) { text-align: center; color: #A00; font-weight: bold; }

table.attrs { width: 100%; font-family: RobotoCondensed; }
table.attrs > tbody > tr > td { padding: 0.25em; }
table.attrs > tbody > tr > td:nth-child(1) { white-space: pre; text-align: center; }
table.attrs > tbody > tr > td:nth-child(2) { text-align: center; }
table.attrs > tbody > tr > td:nth-child(3) { font-family: Inconsolata; font-weight: bold; }
table.attrs > tbody > tr > td:nth-child(4) { font-family: Inconsolata; }
table.attrs > tbody > tr > td:nth-child(5) { padding-left: 0.5em; padding-right: 0.5em; white-space: normal; font-family: RobotoCondensed; width: 100%; }
table.attrs > tbody > tr > td { vertical-align: top; }
table.attrs > tbody > tr > td.dummy { color: #888; background-color: #FFE; }
table.attrs > tbody > tr > td.niy { color: #A00; font: bold 10pt Roboto; }


table.codeDoc { margin-left: auto; margin-right: auto; margin-bottom: 1em; font-family: RobotoCondensed;}
table.codeDoc td { text-align: left; padding-left: 0.5em; padding-right: 0.5em; }
table.codeDoc > tbody > tr > td:nth-child(1) { text-align: center; font-weight: bold; }

div.fsig { font: bold 10pt Inconsolata; margin-bottom: 0.3em; margin-top: 1em; }
p+div.fsig { margin-top: 1.25em; }
.fdesc { margin-left: 1em; }

table.illusBasic { page-break-inside: avoid; }
table.illusBasic td { vertical-align: top; }
table.illusBasic td.infinite { padding-left: 1em; }
</style>

<script src="jquery-3.3.1.min.js"></script>

<script>

function buildTOC() {
    var content = [ ];
    $("h1,h2,h3,h4").each(function(idx) {
        var parts = $(this).html().split("\0000a0\0000a0");
        var name = "toc" + parts[0];
        name = name.replace(/\./g, "_");
        $(this).before("<a name='" + name + "'></a>");
        content.push("<div class='" + this.tagName.toLowerCase() + "'><a href='#" + name + "'>" + $(this).html() + "</a></div>");
    });
    $("#toc").html(content.join("\n"));
    $("div.h1").html("");
}

$(document).ready(function() {
    buildTOC();
});

</script>

</head>
<body>
<img src='cplogo_small.png' style='float: right; margin-left: 1em; margin-bottom: 1em; position: relative; top: 12pt;'>
<h1>CephaloPOV v0.0.2&alpha;<br/>User's Manual</h1>

<h2>Introduction</h2>

<div>

<p><span class='h2num'></span>CephaloPOV is a JavaScript scripting engine for
POV-Ray. It is implemented as a Node command line program that loads a user
script and executes it in an environment in which it can manipulate various
JavaScript classes that map to POV-Ray's native objects, in addition to having
full access to the Node ecosystem. CephaloPOV takes care of generating POV-Ray
Scene Description Language files, both for static scenes and multi-frame
animations.</p>

<p><i>The documentation as it stands is more or less complete as far as CephaloPOV
itself is concerned, but the longer-term goal of being self-sufficient without
requiring familiarity with POV-Ray is still a good ways away.</i></p>

</dive>

<h3>Table of Contents</h3>

<div id='toc'></div>

<h3>What you need (and don't need) to know</h3>

<p>One of the major design goals of CephaloPOV is to be accessible to anyone who
has basic competency in JavaScript without requiring prior experience with
POV-Ray or having to know its Scene Description Language (SDL). However, POV-Ray
is an enormous program with a vast array of features, and it will be quite some
time before this manual is a complete substitute for POV-Ray's own extensive
documentation. In the meantime, POV-Ray novices should refer to the <a
href="http://povray.org/documentation/3.7.0/index.html">official
documentation</a>.</p>

<p>Having said all that, another major design goal of CephaloPOV is to interoperate
as smoothly as possible with SDL. You can use existing SDL code with (and within)
CephaloPOV JavaScript code, and it is easy to go the other way, incorporating
the output of CephaloPOV scripts into SDL.</p>

<p>As far as JavaScript expertise goes, you can get by with a basic knowledge of
the language. CephaloPOV uses ES6 classes instead of bare prototypes for most
things, but unless you intend to extend them, you can treat them just like
prototypes. If you're a JavaScript expert, you can of course do much more than a
beginner, but that is a simple matter of programmer skill and not a matter of
CephaloPOV's API. All that said, it's worth being very clear that CephaloPOV
does not run in your browser; it runs under Node.js. To get very far, you'll
need at least minimal knowledge of writing and running programs with Node.</p>

<p>POV-Ray is a non-interactive 3D graphics program, so knowledge of analytic
geometry will always be to your advantage, but both POV-Ray and CephaloPOV are
designed to be usable to anyone who understands three-dimensional Cartesian
coordinates. <span class='ephemeral'>In the future, CephaloPOV will offer a
sophisticated but easy-to-use geometric query system that will let you leverage
quite complex math without having to understand the details, but that's still
a ways off.</span></p>

<h3>Installation</h3>

<p>CephaloPOV is packaged as a Node module. If you don't already have Node installed,
<a href="https://nodejs.org/en/">take care of that first</a>. Then, using the Node package
manager <code>npm</code>, which was installed with Node, you can install CephaloPOV. Open a terminal window --
on Windows systems, you'll want to launch the "Node.js command prompt" -- and type the following
command:</p>

<div class='code'>$ npm install cephalopov --global</div>

<p>Boom. That's it. Henceforth, you can type <code>cpov</code> at the command prompt
to start CephaloPOV.</p>

<p>If you want copies of the examples used in the tutorials and some tools for
hacking CephaloPOV's internals, you'll need to get the
<code>cpov_examples</code> package from GitHub <a
href="https://github.com/Waidthaler/cpov_examples">here</a>. (You can also get
the <a href="https://github.com/Waidthaler/cephalopov">repo</a> used to build CephaloPOV and the npm package
but you don't need it to use CephaloPOV or to run the examples.)</p>

<h4>Configuration Files</h4>

<p>CephaloPOV has a lot of settings, the majority of which live in two objects,
<code>cpov.globalSettings</code> and <code>cpov.imageOptions</code>. You will likely
find that there are parameters you want to set nearly all the time and a smaller
group of parameters that you want to set for a specific project. Fortunately,
CephaloPOV supports configuration files that will take care of this for you if
you don't mind taking the time to set them up.</p>

<p>There are two (on Windows) or three (on Linux and other Unix clones)
configuration files that CephaloPOV consults before it runs the user program. The first
of these, <code>/etc/cpov/config.js</code>, is Linux-only. Note that CephaloPOV
does not create either the <code>/etc/cpov</code> or its <code>config.js</code> file
for you. You'll have to do this using <code>sudo</code>. The following commands
will create the directory and an empty config file:</p>

<div class="code">$ sudo mkdir /etc/cpov
$ sudo touch /etc/cpov/config.js</div>

<p>Then just open your editor and put the following into <code>config.js</code>:</p>

<div class="code">var config = {
    imageOptions: {
    },
    globalSettings: {
    },
    settings: {
    },
};

module.exports = config;     // Don't forget this!</div>

<p>Now you have a global config file that does nothing whatsoever! You'll add
parameters to the <code>cpov.imageOptions</code>, <code>cpov.globalSettings</code>, and <code>cpov.settings</code>
objects that will be copied to their equivalents inside of CephaloPOV at
runtime. (For more details, see the <a href="#tocGlobal%20Parameters">Global
Parameters</a> section.) One thing worth noticing here is the last line in the
config file, <code>module.exports = config;</code>. It's just an ordinary Node
module.</p>

<p>There is also a per-user config file that is loaded after the global config
file. On Linux and other Unix-like systems, it is named <code>.cpov</code> and
appears in your home directory, e.g., <code>~/.cpov</code>. On Windows, it is
located at <code>C:\Users\<i>username</i>\cpov\config.js</code>, where
<code><i>username</i></code> is, of course, your username. For now, just put
a copy of your empty global config file here.</p>

<p>Finally, there is a per-project config file. It is located in the same
directory as your user program and is named <code><i>programName</i>.config.js</code>,
so if your program is named <code>prettyPictures.js</code>, its config file
will be named <code>prettyPictures.config.js</code>.</p>

<p>To make sure any or all of these files are being loaded correctly, run CephaloPOV
with the <code>-vv</code> switch, and you'll see something like this:</p>

<div class="code">$ ./cpov.js -i illus.js -vv
[cpov.configLoad] INFO: Failed to load global config file \etc\cpov\config.js
[cpov.configLoad] INFO: Successfully loaded and applied user config file C:\Users\eodell\cpov\config.js
[cpov.configLoad] INFO: Failed to load project config file D:\prog\cephalopov\illus.config.js</div>

<p>This tells me that I don't have a global or project config file, but it found
my user file and loaded it successfully.</p>

<p>The config files are loaded in the order given above, i.e., global, user,
project, and if the same parameters are set in each, later files override
earlier files. Note that <em>none</em> of these files are necessary, but they
can be convenient for some working styles. If you prefer to keep everything
self-contained, you can just set parameters inside
<code>cpov.imageOptions</code> and <code>cpov.globalSettings</code> in your main
program file.</p>

<h3>Getting Help</h3>

<p>Aside from this documentation, there are three mailing lists for CephaloPOV
users. All three are hosted at Google Groups, so you can participate via the web as well
as by email:</p>

<ul class='spacious'>

    <li><b><a href="https://groups.google.com/forum/#!forum/cephalopov-users">CephaloPOV
    Users</a>: This is the main mailing list for users of CephaloPOV. It's a good place
    to ask and answer questions and to share user programs and libraries.</b></li>

    <li><b><a href="https://groups.google.com/forum/#!forum/cephalopov-announce">CephaloPOV
    Announce</a>: This is a read-only mailing list where new versions and bug
    fixes are announced. There may be some other announcements, but it rarely exceeds a
    message or two per month.</b></li>

    <li><b><a href="https://groups.google.com/forum/#!forum/cephalopov-developers">CephaloPOV
    Developers</a>:</b> This last one is for developers working on CephaloPOV itself, but
    any users interested in the internals of the system are welcome to participate. This
    is <b>not</b> a forum for bug reports (those go to the <a href="https://github.com/Waidthaler/cephalopov/issues">GitHub repo</a>)
    or feature requests (those go on the <a href="https://groups.google.com/forum/#!forum/cephalopov-users">CephaloPOV</a> Users list).</li>

</ul>

<p>Should you find a bug, you can report it at the <a href="https://github.com/Waidthaler/cephalopov/issues">CephaloPOV repo</a> on GitHub.</p>

<h2>Tutorial</h2>

<div>

<p><span class='h2num'></span>This section will take you step-by-step through
learning how to use CephaloPOV and all its features. It will be, sadly, likely the
last section to be completed.</p>

<p><br/><br/><br/><br/><br/><br/><br/><br/><br/></p>

<h2>Reference</h2>

<p><span class='h2num'></span>The reference section contains a complete summary
of the CephaloPOV API.</p>

<p><br/><br/><br/><br/><br/><br/><br/><br/><br/></p>

<h3>Documentation Conventions</h3>

<p>Code and literals in body text are distinguished by the use of a
<code>fixed-pitch font</code>. Blocks of code appear in boxes like the
one below:</p>

<div class='code'>cpov.primitiveDefIdentifier = function(obj) {
    var result = [ ];
    result.push("#" + obj.serial);
    if(obj.id !== null)
        result.push(obj.id);
    return result.join(":");
}</div>

<p>Most tables of object attributes have a standard set of columns:</p>

<ol class="spacious">

<li>The first (unlabeled) column specifies the read and write permissions
of the attribute, <code>RO</code> for read-only or <code>RW</code> for
read-write.</li>

<li><em>Req:</em> Indicates whether the field is required using <code>Y</code>
or <code>N</code>. This is left blank for read-only attributes.</li>

<li><em>Name:</em> Gives the name of the attribute. This is left unqualified
in object class descriptions, but where the global <code>cpov</code> object
is described, it is given in full, e.g., <code>cpov.currentFrame</code>.</li>

<li><em>Type(s):</em> Lists the type or types accepted by the setter function.
This is usually a single type, but if multiple types are accepted, they will
be listed one after the other.</li>

<li><em>Description:</em> Contains the full details you'll need to use the
attribute, including default values, if any.</li>

</ol>

<h3>API Conventions</h3>

<h4>Naming</h4>

<p>To make things easier for experienced POV-Ray users, the
<code>snake_cased</code> names of objects and properties in SDL, with a few
exceptions (mostly truncations), are converted directly into the
camelCased names which are the norm in JavaScript. Class names
begin with a capital letter, so <code>julia_fractal</code> becomes
<code>JuliaFractal</code>.

<h4>Type Discipline</h4>

<p>To avoid making the user painfully debug cases where CephaloPOV accepts an
erroneous value and writes it into the SDL output files, CephaloPOV imposes a
stricter type discipline than the default JavaScript type system:</p>

<ul class='spacious'>

    <li>The most important rule is that primitive types are <em>never</em>
    silently converted to other types. If a parameter or method calls for a
    string and you pass a number (or vice versa), you'll get a fatal error. The
    string <code>"2"</code> and the number <code>2</code> are as different in
    CephaloPOV as if it had been written in C.</li>

    <li>CephaloPOV is particularly picky about numbers. JavaScript has only one
    numeric type, <code>Number</code>, which is internally a double-precision
    floating point number. CephaloPOV, however, distinguishes between floats and
    integers. If the API expects an integer, you must pass a whole number;
    fractional values will be rejected. This is to avoid the unexpected behavior
    that might come from truncating or rounding the fractional part.</li>

    <li>The big exception to all this is that the constructors for nearly all of
    the classes take optional shortcut forms for the sake of convenience. In
    most cases, this is an ordered list of the minimum required arguments, e.g.,
    <code>corner1</code> and <code>corner2</code> for a <code>Box</code>.</li>

    <li>The other exception concerns the various <code>Vector*</code>,
    <code>Color</code>, and <code>Matrix</code> types which are heavily used
    throughout the API. For example, anywhere a <code>VectorXYZ</code> is
    required, you can pass a three-element array of floats&mdash;<code>[ 0, 1,
    2.3 ]</code>&mdash;to avoid the tedious boilerplate code of explicitly
    instantiating the class.</li>

    <li>All parameters are initialized to <code>null</code> and can be set to
    <code>null</code> at any time, with the caveat that required parameters must
    have non-<code>null</code> values at output time. Optional parameters with
    <code>null</code> values are not output and thus have their default values
    from POV-Ray's perspective.</li>

</ul>

<h4>Type Indiscipline</h4>

<p>The type discipline that CephaloPOV imposes is useful from the standpoint of
avoiding careless bugs, but it is only enforced upon static data. In almost
every case, object parameters in CephaloPOV can be replaced with either
JavaScript callback functions or SDL functions.</p>

<p>SDL functions are specified as strings beginning with <code>"&"</code>. (The
leading ampersand is stripped off before output.) CephaloPOV presently has no way
of determining the validity of SDL code, so you'll need to know exactly what you're
doing. This also means that CephaloPOV can't use SDL functions in its internal
calculations. For example, if you assign an SDL function returning a vector to
an object parameter, that object cannot be transformed within CephaloPOV.</p>

<p>JavaScript parameters are somewhat easier to deal with. Each callback is
called as needed with the global <code>cpov</code> object and the object it
belongs to, e.g.:</p>

<div class='code'>yourFunction(cpov, obj);</div>

<p>On the receiving end, getting the return type right is left to the user as
CephaloPOV does not perform any validation tests upon it. CephaloPOV may also
call user functions at any time, so they should not have any side-effects or
internal state. Unlike SDL function strings, the return values of user functions
<em>can</em> be used in calculations just like a static value, but beware of
cases where an operation writes a value back to the
parameter&mdash;transformations are a good example&mdash;which will result in
the dynamic user function being replaced by a static value. All that said, with
a little care, JavaScript callbacks can be an incredibly powerful tool.</p>

<p>To get around the limitations on side-effects and internal state, remember
that every <code>Primitive</code> object has two callback methods,
<code>frameBegin</code> and <code>frameEnd</code>. These methods are guaranteed
to only be called by CephaloPOV at the beginning and end of a frame, exactly
once for each object.</p>

<h3>The Animation Cycles</h3>

<p>From CephaloPOV's perspective, every user program is an animation. Static
scenes are just animations with a single frame. If you're only making static
scenes, you don't need to know much about the animation features beyond setting
up a scene and triggering its output. Conversely, once you know how to create
static scenes, there's not much more you have to know in order to create
animations.</p>

<p>One of the major design goals of CephaloPOV was to have more flexible options
than POV-Ray's native animation system which, while more than adequate for many
animations, can be awkward for others. Consequently, there are two main ways to
produce animations in CephaloPOV:</p>

<ul class='spacious'>

    <li><b>Snapshot Mode:</b> In snapshot mode, which is triggered by setting
    <code>cpov.settings.snapshotMode</code> to <code>true</code>, the user provides the
    main loop. Objects are created and destroyed as needed, but they remain
    invisible until their <code>snapshot</code> methods are called. When
    <code>cpov.outputFrame()</code> is called, the <code>.pov</code> file for
    the frame is output. This mode is often used for still scenes as well. It is
    important to remember that object <code>active</code> flags are still
    respected in snapshot mode.</li>

    <li><b>Automatic Mode:</b> In automatic mode, the user program does not call
    <code>cpov.outputFrame()</code> directly; instead, it hands off control to
    <code>cpov.runAnimation()</code>. Before each frame is output, the
    <code>cpov.settings.frameBegin</code> callback function is called, followed by each
    object's own <code>frameBegin</code> callbacks. The frame is then output.
    Afterwards, each object's <code>frameEnd</code> callback is called, followed
    by the global <code>cpov.settings.frameEnd</code> callback. Finally, both the animation
    time clock variable, <code>cpov.clockTime</code> is incremented by <code>cpov.tickVal</code>,
    and the frame number, <code>cpov.currentFrame</code>, is incremented. The cycle
    repeats until any of the callbacks invokes <code>cpov.endAnimation</code>.</li>

</ul>

<p>Aside from the greater flexibility of writing procedural code in JavaScript
instead of SDL, having both a time counter and a frame counter in automatic mode
can make certain kinds of animations and programming styles easier. At the same
time, the ability to work within the implicit Newtonian time of the native
POV-Ray animation system is preserved.</p>

<h4>Animation Parameters</h4>

<p>The animation loop is configured through attributes of the global <code>cpov</code>
object. All of them are directly writeable by the user program, but some of them should
be manipulated with care as noted in the table below.</p>

<div>
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>cpov.clockTime</td><td>float</td><td>This attribute holds the current clock time for the animation. It defaults to <code>0.0</code>.</td></tr>
<tr><td>RW</td><td>Y</td><td>cpov.currentFrame</td><td>integer</td><td>The number of the current frame. In most cases, you should treat this as a read-only value, but there is no reason you can't at least change it to a higher number to skip frames if you do it at the end of the animation loop.</td></tr>
<tr><td>RW</td><td>Y</td><td>cpov.endFrame</td><td>integer</td><td>The user program will halt if and when <code>cpov.currentFrame</code> is greater than this number. Defaults to <code>Infinity</code>.</td></tr>
<tr><td>RW</td><td>Y</td><td>cpov.endTime</td><td>float</td><td>The user program will halt if and when <code>cpov.clockTime</code> is greater than this number. Defaults to <code>Infinity</code>.</td></tr>
<tr><td>RW</td><td>Y</td><td>cpov.settings.frameBegin</td><td>function</td><td>This is a user-supplied callback function which is called at the beginning of the animation loop. It is passed the global <code>cpov</code> object as its sole argument.</td></tr>
<tr><td>RW</td><td>Y</td><td>cpov.settings.frameEnd</td><td>function</td><td>This is a user-supplied callback function which is called at the end of the animation loop. It is passed the global <code>cpov</code> object as its sole argument.</td></tr>
<tr><td>RW</td><td>Y</td><td>cpov.settings.outputBase</td><td>string</td><td>The generated <code>.pov</code> and <code>.ini</code> filenames will be based on this template, which defaults to <code>cpov0000</code>. The first sequence of zeroes in the template string will be replaced with the frame number, left-padded with to the same number of digits as the zero sequence.</td></tr>
<tr><td>RW</td><td>Y</td><td>cpov.settings.snapshotMode</td><td>boolean</td><td>If <code>true</code>, puts CephaloPOV in snapshot mode.</td></tr>
<tr><td>RW</td><td>Y</td><td>cpov.snapshots</td><td>array</td><td>This is an array containing the output SDL strings which will be written to the <code>.pov</code> file at the end of the frame loop. Normally read-only, but if you know what you're doing, feel free to <code>push()</code> additional content to it.</td></tr>
<tr><td>RW</td><td>Y</td><td>cpov.startFrame</td><td>integer</td><td>The user program will run but not produce any output until <code>cpov.currentFrame</code> is greater than or equal to this number. Defaults to <code>0</code>.</td></tr>
<tr><td>RW</td><td>Y</td><td>cpov.startTime</td><td>float</td><td>The user program will run but not produce any output until <code>cpov.clockTime</code> is greater than or equal to this number. Defaults to <code>0</code>.</td></tr>
<tr><td>RW</td><td>Y</td><td>cpov.tickVal</td><td>float</td><td>Contains the value added to <code>cpov.clockTime</code> after each iteration of the animation loop. Defaults to <code>1.0</code>.</td></tr>
</tbody>
</table>

<h4>Snapshot Mode</h4>

<p>Snapshot mode is arguably the easier of the two animation modes to get
started with, especially if the animation is simple or you want to construct
your own animation loop to suit your needs. Just set
<code>cpov.settings.snapshotMode</code> to <code>true</code>, which disables the built-in
loop.</p>

<div class="code">cpov.settings.snapshotMode = true;</div>

<p>All you need to do after that is create your objects and call their
<code>snapshot</code> methods. If you move them afterwards, you can call
<code>snapshot</code> again to "plot" them in their new positions. And once
you've created a snapshot of every object you want in the frame, call
<code>cpov.outputFrame</code> to generate the
<code>.pov</code>/<code>.ini</code> files and clear the snapshot buffer.</p>

<p>Two things are important to remember in snapshot mode. First, your light
sources and cameras are objects themselves, so you have to remember to add their
snapshots to the buffer in each frame. Second, objects don't magically cease to
exist if you only use them once. This may not matter much in short, simple
animations, but if you are creating a lot of single-use objects, you'll want to
call their <code>destroy</code> methods to avoid filling up memory.</p>

<p>The script that generates the illustrations for this documentation uses
snapshot mode. Here's a somewhat simplified version of what it does. (See <code>/docs/illus.js</code>
if you want to dig into the full, somewhat hairy details.) First, it just does
the usual setup and housekeeping, the only germane part of which is the first
line that activates snapshot mode:</p>

<div class="code"><b>cpov.settings.snapshotMode                = true;  // Don't forget this part</b>
cpov.imageOptions.height         = 320;
cpov.imageOptions.width          = 320;
cpov.imageOptions.outputFileType = "N";
cpov.imageOptions.createIni      = true;
cpov.imageOptions.outputAlpha    = true;
cpov.imageOptions.antialias      = true;
cpov.imageOptions.antialiasDepth = 9;
cpov.globalSettings.ambientLight = [0.25, 0.25, 0.25];</div>

<p>Then it creates the generic texture string that all of the object examples
reuse, and it calls an undocumented internal function to produce the stage
objects, which come as an array with two members, the stage and lights, and the
camera. We go ahead and push those right into the snapshot buffer.</p>

<div class='code'>var texture = "texture { pigment { color <1, 1, 0> }}";
var stage   = cpov.testStage("corner", 6);
stage[0].snapshot();
stage[1].snapshot();</div>

<p>Because this isn't actually an animation, the script sets <code>cpov.settings.outputBase</code>
at the beginning of each "frame" to make it easier to find the files. (I'm mentioning
this to point out that snapshot mode is also a convenient way to crank out a bunch of
static images.)</p>

<div class="code">cpov.settings.outputBase = "./docs/src/box_basic";</div>

<p>Now we can get down to business and create our example box:</p>

<div class="code">var obj = new Box({
    corner1: [2,2,2],
    corner2: [-2, -2, -2]
});
obj.snapshot();</div>

<p>And that's it as far as objects go. We just need to output the frame and clean
up after ourselves:</p>

<div class="code">cpov.outputFrame();  // This outputs box_basic.pov and box_basic.ini
obj.destroy();</div>

<p>Naturally, if you're only doing a single frame or a short animation with
relatively few objects, you don't have to bother with calling
<code>destroy</code>, but it's a good habit to get into before you start working
on more ambitious projects.</p>


<h4>Automatic Mode</h4>

<p>Automatic mode is not actually any harder to use than snapshot mode. In fact,
it's a lot easier because it automates a lot of the stuff you'd otherwise have
to do manually, but it does require you to understand the CephaloPOV animation
loop, at least if you want to avoid tying yourself into knots. Let's just get
that out of the way first:</p>

<ol class="spacious">
    <li>The global <code>cpov.settings.frameBegin</code> callback is called.</li>
    <li>Each object's individual <code>frameBegin</code> callback is called.</li>
    <li>All <code>active</code> objects are written to file by <code>cpov.outputFrame</code>.</li>
    <li>Each object's individual <code>frameEnd</code> callback is called.</li>
    <li>The global <code>cpov.settings.frameEnd</code> callback is called.</li>
    <li>The <code>cpov.clockTime</code> is incremented by <code>cpov.tickVal</code> and <code>cpov.currentFrame</code> is incremented.</li>
</ol>

<p>This loop starts when your program calls <code>cpov.runAnimation</code> and
continues until either your program calls <code>cpov.endAnimation</code>,
<code>cpov.clockTime</code> exceeds <code>cpov.endTime</code>, or
<code>cpov.currentFrame</code> exceeds <code>cpov.endFrame</code>. Besides
setting up the initial scene, all you have to do is write the necessary
<code>beginFrame</code> and <code>endFrame</code> callbacks.</p>


<h5>Callbacks</h5>

<p>As far as the callbacks are concerned, how you want to structure things is up
to you. If you want, you can stuff all of your logic into
<code>cpov.beginFrame</code> and/or <code>cpov.endFrame</code>. You can also
leave them set to <code>null</code> and pack everything into the
<code>beginFrame</code> and <code>endFrame</code> methods of individual objects.
You can also use both. CephaloPOV is not opinionated about your code.</p>

<p>All of the callbacks are the same. Each one is called with a single argument,
the global <code>cpov</code> object, which it can then interrogate to determine
the current clock value and frame number, as well as use
<code>cpov.serialMap</code> or <code>cpov.idMap</code> to find other objects.
You can feel free to attach additional data and function members to
<code>cpov</code> as well.</p>

<h5>Using the Clock and the Frame Count</h5>

<p>The animation clock, <code>cpov.clockTime</code>, is a continuous
floating-point value that is incremented by <code>cpov.tickVal</code> at the end
of each frame and measures time inside the animation. The current frame number,
<code>cpov.currentFrame</code>, is a discrete integer value that increases by
one at the end of each frame, and which effectively measures the number of times
that the simulated world of the animation has been sampled.</p>

<p>You can just use one or the other if your needs are simple enough, but the
combination of the two is powerful enough to make it worth understanding their
relationship. [TODO]</p>


<h3>The cpov Object</h3>

<p>From the POV of user programs (see what I did there?), CephaloPOV appears as
the global object <code>cpov</code>, so named because it would be a pain to have
to type CephaloPOV all the time. Trust me, I know. The innards of
<code>cpov</code> are actually pretty short and simple because its main job is
to keep track of various settings and just run the user program. Most of the
gnarly code lives elsewhere. It does have a few oft-used public methods which
will be described after the parameter objects. For a complete list, see the <a
href="#tocInside_the_cpov_Object">developer documentation</a>.</p>

<p>POV-Ray has two sets of global parameters which remain separate here. The
first, represented in CephaloPOV by the <code>cpov.imageOptions</code> object,
corresponds to POV-Ray's command line switches and the contents of
<code>.ini</code> files. The second is the <code>global_settings</code> block in
<code>.pov</code> scene files, which is represented by
<code>cpov.globalSettings</code>.</p>

<p>In addition to these, there is a third object, <code>cpov.settings</code>, that
contains parameters specific to CephaloPOV to avoid confusion with the POV-Ray specific
settings in the other two objects.</p>

<h4>cpov.settings</h4>

<p>The <code>cpov.settings</code> objects represents the global parameters controlling
the operation of CephaloPOV. Some can be set indirectly by command line switches or
the config files. All of them are directly accessible to user programs.</p>

<h5>Attributes</h5>

<div dh="Settings">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>N</td><td>debug</td><td>integer</td><td>Determines the debugging mode. The legal values are 
<table class="sgrid codeDoc">
<thead>

<tr><th>Code</th><th>Meaning</th></tr>
</thead><tbody>
<tr><td>0</td><td>Debugging mode is turned off.</td></tr>
<tr><td>1</td><td>Debugging mode is turned on.</td></tr>
<tr><td>2</td><td>Debugging mode is turned on <em>and</em> fatal errors are ignored. This is mainly useful if you are modifying CephaloPOV itself.</td></tr>
</tbody></table>
</td></tr>
<tr><td>RW</td><td>N</td><td>frameBegin</td><td>function</td><td>This callback function is called at the beginning of each frame.</td></tr>
<tr><td>RW</td><td>N</td><td>frameEnd</td><td>function</td><td>This callback function is called at the end of each frame.</td></tr>
<tr><td>RW</td><td>N</td><td>infile</td><td>string</td><td>This is the name of the user program file.</td></tr>
<tr><td>RW</td><td>N</td><td>outputBase</td><td>string</td><td>Provides the template for generated filenames. The first substring of zeroes will be replaced with the frame number zero-padded to the same number of digits, and <code>.ini</code> and <code>.pov</code> will be appended to form the filename. The default is <code>"cpov0000"</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>preamble</td><td>string</td><td>If non-<code>null</code>, this specifies a string&mdash;presumably SDL&mdash;to prepend to all output <code>.pov</code> files. This can also be specified by passing a filename to the <code>-p</code> or <code>--preamble</code> command line switches.</td></tr>
<tr><td>RW</td><td>N</td><td>quietMode</td><td>boolean</td><td>If true, console output will be suppressed. Can be set with the <code>-q</code> or <code>--quietMode</code> command line switches.</td></tr>
<tr><td>RW</td><td>N</td><td>sdlIncludes</td><td>boolean</td><td>Specifies an array of one or more SDL include files. These will generate <code>#include</code> statements in the generated <code>.pov</code> files in the order given after the contents of <code>cpov.settings.preamble</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>snapshotMode</td><td>boolean</td><td>If true, snapshot mode will be used for animations.</td></tr>
<tr><td>RW</td><td>N</td><td>verbosity</td><td>integer</td><td>Sets the verbosity of console output. The default value, <code>1</code>, permits output of fatal errors and warnings, <code>2</code> enables information messages, <code>3</code> enables debugging messages. Quiet mode is the same as a verbosity of <code>0</code>. This value is incremented by the <code>-v</code> command line switch.</td></tr>
</tbody></table>
</div dh="Settings">

<h5>Methods</h5>

<div class='fsig'>Settings(<i>options</i>)</div>

<p class='fdesc'>The constructor may be called without arguments, returning an
object with its attributes initialized to <code>null</code>. The
<code>options</code> argument may also be a plain JavaScript object containing
named initializers. User programs will rarely have to call the <code>Settings</code>
constructor directly as <code>cpov.settings</code> is already initialized.</p>

<div class='fsig'>xset(<i>valObj</i>)</div>

<p class='fdesc'>This is a convenience function which takes an object full
of key/value pairs and sets several attributes at the same time, much like
the constructor, which avoids having to set them individually. The following
are equivalent:</p>

<div class='code fdesc'>cpov.settings.quietMode = false;
cpov.settings.snapshotMode = true;

// is the same as...

cpov.settings.xset({quietMode: false, snapshotMode: true});</div>

<h4>cpov.imageOptions</h4>

<p>The <code>cpov.imageOptions</code> object represents the global parameters
that are set either by POV-Ray command line switches or by <code>.ini</code>
files. CephaloPOV itself never uses the command line switches, but they are
output in a comment at the beginning of the generated <code>.ini</code> files
for the curious. It should be noted that not all of the values that can be set
in a <code>.ini</code> file have corresponding command line switches.</p>

<p>By default, CephaloPOV initializes <code>cpov.imageOptions</code> with an
<code>ImageOptions</code> object at the beginning of a job. You can create
additional <code>ImageOptions</code> objects, but only the one assigned to
<code>cpov.imageOptions</code> when <code>cpov.outputFrame()</code> is called is
actually used.</p>

<p>All of the parameters are optional except for <code>height</code> and
<code>width</code>.</p>

<h5>Attributes</h5>

<div dh="ImageOptions">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>height</td><td>integer</td><td>Height of output image in pixels.</td></tr>
<tr><td>RW</td><td>Y</td><td>width</td><td>integer</td><td>Width of output image in pixels.</td></tr>
<tr><td>RW</td><td>N</td><td>allConsole</td><td>boolean</td><td>If <code>true</code>, POV-Ray debug messages, fatal errors, rendering info, statistics, and warnings are sent to the console.</td></tr>
<tr><td>RW</td><td>N</td><td>allFile</td><td>boolean<br/>string</td><td>If <code>true</code>, POV-Ray debug messages, fatal errors, rendering info, statistics, and warnings are written to <code>ALLTEXT.OUT</code>. Alternatively, a custom filename may be specified here.</td></tr>
<tr><td>RW</td><td>N</td><td>antialias</td><td>boolean</td><td>If <code>true</code>, enables antialiasing.</td></tr>
<tr><td>RW</td><td>N</td><td>antialiasDepth</td><td>integer</td><td>Specifies the number of rows and columns within each pixel to be super-sampled. Values in the range 1-9 are permitted, and the default is 3.</td></tr>
<tr><td>RW</td><td>N</td><td>antialiasGamma</td><td>float</td><td>Sets the gamma to be used in antialiasing.</td></tr>
<tr><td>RW</td><td>N</td><td>antialiasThreshold</td><td>float</td><td>Defines the amount by which a pixel must differ from its neighbors to trigger supersampling. The default is 0.3.</td></tr>
<tr><td>RW</td><td>N</td><td>appendFile</td><td>boolean</td><td>If <code>true</code>, output from the various runtime log files will be appended to existing files. If <code>false</code>, runtime log files will be overwritten.</td></tr>
<tr><td>RW</td><td>N</td><td>bitsPerColor</td><td>integer</td><td>Specifies the number of bits per color channel in the image file. This only affects PNG and PNM output, which allow 5-16 bits per channel.</td></tr>
<tr><td>RW</td><td>N</td><td>bounding</td><td>boolean</td><td>If <code>true</code> (the default), turns automatic bounding control on.</td></tr>
<tr><td>RW</td><td>N</td><td>boundingMethod</td><td>integer</td><td>If set to 1 (the default), the POV-Ray 3.0+ automatic bounding system is used. If set to 2, the new (and very much beta) Binary Space Partitioning method is used.</td></tr>
<tr><td>RW</td><td>N</td><td>boundingThreshold</td><td>integer</td><td>Sets the minimum number of objects that must be in a scene before automatic bounding control is used. Defaults to 25.</td></tr>
<tr><td>RW</td><td>N</td><td>bspBaseAccessCost</td><td>float</td><td>Parameter for the beta Binary Space Partioning System. See <a href="http://www.realtimerendering.com/resources/RTNews/html/rtnv17n1.html#art8">this article</a> for details.</td></tr>
<tr><td>RW</td><td>N</td><td>bspChildAccessCost</td><td>float</td><td>Parameter for the beta Binary Space Partioning System. See <a href="http://www.realtimerendering.com/resources/RTNews/html/rtnv17n1.html#art8">this article</a> for details.</td></tr>
<tr><td>RW</td><td>N</td><td>bspIsectCost</td><td>float</td><td>Parameter for the beta Binary Space Partioning System. See <a href="http://www.realtimerendering.com/resources/RTNews/html/rtnv17n1.html#art8">this article</a> for details.</td></tr>
<tr><td>RW</td><td>N</td><td>bspMaxDepth</td><td>float</td><td>Parameter for the beta Binary Space Partioning System. See <a href="http://www.realtimerendering.com/resources/RTNews/html/rtnv17n1.html#art8">this article</a> for details.</td></tr>
<tr><td>RW</td><td>N</td><td>bspMissChance</td><td>float</td><td>Parameter for the beta Binary Space Partioning System. See <a href="http://www.realtimerendering.com/resources/RTNews/html/rtnv17n1.html#art8">this article</a> for details.</td></tr>
<tr><td>RW</td><td>N</td><td>debugConsole</td><td>boolean</td><td>If <code>true</code>, POV-Ray debug messages are sent to the console.</td></tr>
<tr><td>RW</td><td>N</td><td>debugFile</td><td>boolean<br/>string</td><td>If <code>true</code>, POV-Ray debug messages are written to <code>DEBUG.OUT</code>. Alternatively, a custom filename may be specified here.</td></tr>
<tr><td>RW</td><td>N</td><td>display</td><td>boolean</td><td>If <code>true</code>, the image in progress will be displayed during rendering.</td></tr>
<tr><td>RW</td><td>N</td><td>displayGamma</td><td>float<br/>string</td><td>A float defining the gamma to be used by the display during rendering or the string <code>"sRGB"</code> (roughly 2.2).</td></tr>
<tr><td>RW</td><td>N</td><td>dither</td><td>boolean</td><td>If <code>true</code> (the default is <code>false</code>), output dithering is used.</td></tr>
<tr><td>RW</td><td>N</td><td>ditherMethod</td><td>string</td><td>Sets the dithering algorithm if dithering is turned on. The supported values are: 
<table class="sgrid codeDoc">
<thead>

<tr><th>Code</th><th>Meaning</th></tr>
</thead><tbody>
<tr><td>B2</td><td>Bayer pattern 2x2</td></tr>
<tr><td>B3</td><td>Bayer pattern 3x3</td></tr>
<tr><td>B4</td><td>Bayer pattern 4x4</td></tr>
<tr><td>D1</td><td>Simple error diffusion 1D</td></tr>
<tr><td>D2</td><td>Simple error diffusion 2D</td></tr>
<tr><td>FS</td><td>Floyd-Steinberg error diffusion</td></tr>
</tbody></table>
</td></tr>
<tr><td>RW</td><td>N</td><td>endColumn</td><td>integer<br/>float</td><td>Forces the end of output at the specified column if an integer is supplied or a fraction of screen width if a float in the unit interval (0.n) is supplied.</td></tr>
<tr><td>RW</td><td>N</td><td>endRow</td><td>integer<br/>float</td><td>Forces the end of output at the specified row if an integer is supplied or a fraction of screen height if a float in the unit interval (0.n) is supplied.</td></tr>
<tr><td>RW</td><td>N</td><td>exePath</td><td>string</td><td>This should contain the full path to the POV-Ray executable if it is not in the system path.</td></tr>
<tr><td>RW</td><td>N</td><td>fatalConsole</td><td>boolean</td><td>If <code>true</code>, POV-Ray fatal error messages are sent to the console.</td></tr>
<tr><td>RW</td><td>N</td><td>fatalErrorCommand</td><td>string</td><td>Shell command to execute when POV-Ray encounters a fatal error.</td></tr>
<tr><td>RW</td><td>N</td><td>fatalErrorReturn</td><td>string</td><td>Specifies the action to take when a fatal error occurs during the exectuion of the <code>fatalErrorCommand</code>. Action codes may be prefixed with "<code>-</code>" or "<code>!</code> to negate the action. The legal codes are 
<table class="sgrid codeDoc">
<thead>

<tr><th>Code</th><th>Meaning</th></tr>
</thead><tbody>
<tr><td>A</td><td>all steps skipped</td></tr>
<tr><td>F</td><td>generate a fatal error in POV-Ray</td></tr>
<tr><td>I</td><td>ignore code</td></tr>
<tr><td>Q</td><td>quit POV-Ray immediately</td></tr>
<tr><td>S</td><td>skip one step</td></tr>
<tr><td>U</td><td>generate a user abort in POV-Ray</td></tr>
</tbody></table>
</td></tr>
<tr><td>RW</td><td>N</td><td>fatalFile</td><td>boolean<br/>string</td><td>If <code>true</code>, POV-Ray fatal error messages are written to <code>FATAL.OUT</code>. Alternatively, a custom filename may be specified here.</td></tr>
<tr><td>RW</td><td>N</td><td>fileGamma</td><td>float<br/>string</td><td>Sets the display target gamma for the output file. This may be given as either a float or the string <code>"sRGB"</code> (approx. 2.2).</td></tr>
<tr><td>RW</td><td>N</td><td>highReproducibility</td><td>boolean</td><td>If <code>true</code>, enables the experimental high reproducibility mode, which attempts to impose determinism on calculations in SMP environments. Currently only works with radiosity.</td></tr>
<tr><td>RW</td><td>N</td><td>includeHeaders</td><td>string</td><td>An array containing the names of SDL include files to be referenced in the SDL output.</td></tr>
<tr><td>RW</td><td>N</td><td>inputFileName</td><td>string</td><td>Explicitly sets an input .pov file name.</td></tr>
<tr><td>RW</td><td>N</td><td>jitter</td><td>boolean</td><td>If <code>true</code>, enables random jittering of antialiasing super-samples to minimize artifacts. This should only be used for static scenes, not animation.</td></tr>
<tr><td>RW</td><td>N</td><td>jitterAmount</td><td>float</td><td>Defines the amount of jitter. The default is 1.0, above which super-samples may stray outside of their pixels.</td></tr>
<tr><td>RW</td><td>N</td><td>libraryPath</td><td>Array</td><td>An array of one or more paths to search for include files.</td></tr>
<tr><td>RW</td><td>N</td><td>maxImageBuffer</td><td>integer</td><td>Specifies the number of megabytes of memory to reserve as an output buffer for images. The default is 128.</td></tr>
<tr><td>RW</td><td>N</td><td>outputAlpha</td><td>boolean</td><td>Enables or disables the alpha channel in output files. This only has an effect when the output file type supports alpha, i.e., PNG or Targa.</td></tr>
<tr><td>RW</td><td>N</td><td>outputFileName</td><td>string</td><td>By default, the output file name is derived from the .pov scene file name. This option allows it to be set manually. If a directory name is given here instead of a file name, the default name is used and the file is written to the specified directory.</td></tr>
<tr><td>RW</td><td>N</td><td>outputFileType</td><td>string</td><td>Sets the format of the output file. These are all single-character codes as specified below: 
<table class="sgrid codeDoc">
<thead>

<tr><th>Code</th><th>Meaning</th></tr>
</thead><tbody>
<tr><td>B</td><td>BMP</td></tr>
<tr><td>C</td><td>TGA, RLE compression</td></tr>
<tr><td>E</td><td>OpenEXR HDR</td></tr>
<tr><td>H</td><td>Radiance HDR</td></tr>
<tr><td>J</td><td>JPEG</td></tr>
<tr><td>N</td><td>PNG</td></tr>
<tr><td>P</td><td>PPM</td></tr>
<tr><td>S</td><td>System default</td></tr>
<tr><td>T</td><td>TGA, uncompressed</td></tr>
</tbody></table>
</td></tr>
<tr><td>RW</td><td>N</td><td>outputToFile</td><td>boolean</td><td>If <code>true</code> (the default), POV-Ray will produce an output image file. If <code>false</code>, no file is produced, which is often desirable when doing test renders.</td></tr>
<tr><td>RW</td><td>N</td><td>palette</td><td>char</td><td>A single character which selects a hardware-dependent palette for display during rendering.</td></tr>
<tr><td>RW</td><td>N</td><td>pauseWhenDone</td><td>boolean</td><td>If <code>true</code>, POV-Ray will wait for a keypress at the end of rendering before clearing the display.</td></tr>
<tr><td>RW</td><td>N</td><td>postSceneCommand</td><td>string</td><td>Shell command to execute after rendering a scene. Since CephaloPOV replaces POV-Ray's native animation system, this happens after every frame in an animation.</td></tr>
<tr><td>RW</td><td>N</td><td>postSceneReturn</td><td>string</td><td>Specifies the action to take when the <code>postSceneAction</code> fails. See <code>fatalExecutionReturn</code> for a list of legal values.</td></tr>
<tr><td>RW</td><td>N</td><td>preSceneCommand</td><td>string</td><td>Shell command to execute before rendering a scene. Since CephaloPOV replaces POV-Ray's native animation system, this happens before every frame in an animation.</td></tr>
<tr><td>RW</td><td>N</td><td>preSceneReturn</td><td>string</td><td>Specifies the action to take when the <code>preSceneAction</code> fails. See <code>fatalExecutionReturn</code> for a list of legal values.</td></tr>
<tr><td>RW</td><td>N</td><td>previewEndSize</td><td>integer</td><td>Sets the final block size in pixels for mosaic rendering. This must be an integer that is both a power of two and greater than zero.</td></tr>
<tr><td>RW</td><td>N</td><td>previewStartSize</td><td>integer</td><td>Sets the initial block size in pixels for mosaic rendering. This must be an integer that is both a power of two and greater than zero.</td></tr>
<tr><td>RW</td><td>N</td><td>quality</td><td>integer</td><td>Determines rendering quality in the range (0 - 11), with higher values being better. The supported levels, with duplication to allow for future changes, are 
<table class="sgrid codeDoc">
<thead>

<tr><th>Code</th><th>Meaning</th></tr>
</thead><tbody>
<tr><td>0</td><td>Just show quick colors. Use full ambient lighting only. Quick colors are used only at 5 or below.</td></tr>
<tr><td>1</td><td>Just show quick colors. Use full ambient lighting only. Quick colors are used only at 5 or below.</td></tr>
<tr><td>10</td><td>Compute media, radiosity and subsurface light transport.</td></tr>
<tr><td>11</td><td>Compute media, radiosity and subsurface light transport.</td></tr>
<tr><td>2</td><td>Show specified diffuse and ambient light.</td></tr>
<tr><td>3</td><td>Show specified diffuse and ambient light.</td></tr>
<tr><td>4</td><td>Render shadows, but no extended lights.</td></tr>
<tr><td>5</td><td>Render shadows, including extended lights.</td></tr>
<tr><td>6</td><td>Compute texture patterns, compute photons.</td></tr>
<tr><td>7</td><td>Compute texture patterns, compute photons.</td></tr>
<tr><td>8</td><td>Compute reflected, refracted, and transmitted rays.</td></tr>
<tr><td>9</td><td>Compute media, radiosity and subsurface light transport.</td></tr>
</tbody></table>
</td></tr>
<tr><td>RW</td><td>N</td><td>radFileName</td><td>string</td><td>If specified, manually sets the name of the radiosity cache file.</td></tr>
<tr><td>RW</td><td>N</td><td>radFromFile</td><td>string</td><td>If <code>true</code>, loads sample data from an existing radiosity cache file.</td></tr>
<tr><td>RW</td><td>N</td><td>radToFile</td><td>string</td><td>If <code>true</code>, saves sample data to a radiosity cache file for reuse.</td></tr>
<tr><td>RW</td><td>N</td><td>radVainPretrace</td><td>boolean</td><td>If <code>true</code> (the default), an extra radiosity trace will be taken to improve the quality of the preview. If not needed, this can be turned off to improve rendering speed.</td></tr>
<tr><td>RW</td><td>N</td><td>removeBounds</td><td>boolean</td><td>If <code>true</code> (the default), manual bounds will be removed if automatic bounding control is turned on.</td></tr>
<tr><td>RW</td><td>N</td><td>renderBlockSize</td><td>integer</td><td>Specifies the size of blocks of pixels to be rendered. Must be 4 or greater.</td></tr>
<tr><td>RW</td><td>N</td><td>renderBlockStep</td><td>integer</td><td>Sets the step size for walking through the blocks numbered by <code>renderPattern</code></td></tr>
<tr><td>RW</td><td>N</td><td>renderConsole</td><td>boolean</td><td>If <code>true</code>, POV-Ray rendering information is sent to the console.</td></tr>
<tr><td>RW</td><td>N</td><td>renderFile</td><td>boolean<br/>string</td><td>If <code>true</code>, POV-Ray rendering information is written to <code>RENDER.OUT</code>. Alternatively, a custom filename may be specified here.</td></tr>
<tr><td>RW</td><td>N</td><td>renderPattern</td><td>integer</td><td>Determines the order in which render blocks will be rendered. See the POV-Ray documentation for <a href="http://povray.org/documentation/3.7.0/r3_2.html#r3_2_8_2_1">details</a>.</td></tr>
<tr><td>RW</td><td>N</td><td>samplingMethod</td><td>integer</td><td>Sets the antialiasing sampling method. A value of 1, the default, enables non-recursive sampling, while 2 enables adaptive, recursive sampling.</td></tr>
<tr><td>RW</td><td>N</td><td>splitUnions</td><td>boolean</td><td>If <code>true</code>, manually bound <code>Union</code> objects will be rebound by the automatic bounding system. The default is <code>false</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>startColumn</td><td>integer<br/>float</td><td>Forces the start of output at the specified column if an integer is supplied or a fraction of screen width if a float in the unit interval (0.n) is supplied.</td></tr>
<tr><td>RW</td><td>N</td><td>startRow</td><td>integer<br/>float</td><td>Forces the end of output at the specified row if an integer is supplied or a fraction of screen height if a float in the unit interval (0.n) is supplied.</td></tr>
<tr><td>RW</td><td>N</td><td>statisticConsole</td><td>boolean</td><td>If <code>true</code>, POV-Ray statistics are sent to the console.</td></tr>
<tr><td>RW</td><td>N</td><td>statisticFile</td><td>boolean<br/>string</td><td>If <code>true</code>, POV-Ray statistics are written to <code>STATS.OUT</code>. Alternatively, a custom filename may be specified here.</td></tr>
<tr><td>RW</td><td>N</td><td>testAbort</td><td>boolean</td><td>If <code>true</code>, POV-Ray will poll the keyboard for <code>Ctrl-C</code> to halt the program. If false, <code>Ctrl-C</code> is ignored.</td></tr>
<tr><td>RW</td><td>N</td><td>testAbortCount</td><td>integer</td><td>If <code>testAbort</code> is <code>true</code>, <code>testAbortCount</code> specifies the number of pixels rendered between tests for <code>Ctrl-C</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>userAbortCommand</td><td>string</td><td>Shell command to execute when the user aborts rendering.</td></tr>
<tr><td>RW</td><td>N</td><td>userAbortReturn</td><td>string</td><td>Specifies the action to take when the <code>userAbortAction</code> fails. See <code>fatalExecutionReturn</code> for a list of legal values.</td></tr>
<tr><td>RW</td><td>N</td><td>verbose</td><td>boolean</td><td>If true, POV-Ray will output additional information about each render. Not to be confused with CephaloPOV's <code>-v</code> switch, which only increses the verbosity of its own output.</td></tr>
<tr><td>RW</td><td>N</td><td>videoMode</td><td>char</td><td>A single character/digit which defines the hardware-dependent video mode.</td></tr>
<tr><td>RW</td><td>N</td><td>warningConsole</td><td>boolean</td><td>If <code>true</code>, POV-Ray warning messages are sent to the console.</td></tr>
<tr><td>RW</td><td>N</td><td>warningFile</td><td>boolean<br/>string</td><td>If <code>true</code>, POV-Ray warning messages are written to <code>WARNING.OUT</code>. Alternatively, a custom filename may be specified here.</td></tr>
<tr><td>RW</td><td>N</td><td>warningLevel</td><td>integer</td><td>Specifies POV-Ray's warning level. The legal values are: 
<table class="sgrid codeDoc">
<thead>

<tr><th>Code</th><th>Meaning</th></tr>
</thead><tbody>
<tr><td>0</td><td>Turn off all warnings.</td></tr>
<tr><td>10</td><td>Turn on all warnings (default).</td></tr>
<tr><td>5</td><td>Turn off language version warnings.</td></tr>
</tbody></table>
</td></tr>
<tr><td>RW</td><td>N</td><td>workThreads</td><td>integer</td><td>Sets the number of processor threads in a multicore environment. Defaults to the detected number of cores or 4 if detection is not possible, but may be set as high as 512.</td></tr>
</tbody></table>
</div dh="ImageOptions">

<h5>Methods</h5>

<div class='fsig'>ImageOptions(<i>options</i>)</div>

<p class='fdesc'>The constructor may be called without arguments, returning an
object with its attributes initialized to <code>null</code>. The
<code>options</code> argument may also be a plain JavaScript object containing
named initializers. User programs will rarely have to call the <code>ImageOptions</code>
constructor directly as <code>cpov.imageOptions</code> is already initialized.</p>

<div class='fsig'>xset(<i>valObj</i>)</div>

<p class='fdesc'>This is a convenience function which takes an object full
of key/value pairs and sets several attributes at the same time, much like
the constructor, which avoids having to set them individually. The following
are equivalent:</p>

<div class='code fdesc'>cpov.imageOptions.verbose = true;
cpov.imageOptions.quality = 9;

// is the same as...

cpov.imageOptions.xset({verbose: true, quality: 9});</div>

<h4>cpov.globalSettings</h4>

<p>The <code>cpov.globalSettings</code> class defines the behavior of light in
the image along with a few odds and ends like the character set used for input
files. At startup, <code>cpov.globalSettings</code> is initialized with a
pristine instance of the <code>GlobalSettings</code> class. None of its
parameters are mandatory except for <code>assumedGamma</code>, which is
initialized to a default value of <code>1.0</code>.</p>

<h5>Attributes</h5>

<div dh="GlobalSettings">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>N</td><td>adcBailout</td><td>float</td><td>Defines the Adaptive Depth Control bailout value, which determines when to stop tracing further reflections once they cease to contribute significantly to the color of the current pixel. This defaults to 0.0039 and should not require changing. If it is set to zero, only <code>maxTraceLevel</code> will interrupt the tracing of reflections.</td></tr>
<tr><td>RW</td><td>N</td><td>ambientLight</td><td>Color</td><td>Specifies the color of the ambient light, i.e., the illumination that falls on every object from all directions in the absence of any explicit <code>LightSource</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>assumedGamma</td><td>float</td><td>Defines the working gamma space for the render.</td></tr>
<tr><td>RW</td><td>N</td><td>charset</td><td>string</td><td>Specifies which character set will be used in interpreting the contents of text strings. The supported values are <code>"ascii"</code>, <code>"sys"</code>, and <code>"utf8"</code>. The default is <code>ascii</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>iridWavelength</td><td>Color</td><td>Specifies a color to use in iridescence calculations. The default, <code>[0.70, 0.52, 0.48]</code> will rarely if ever need to be changed, but it is available for experimentation.</td></tr>
<tr><td>RW</td><td>N</td><td>maxIntersections</td><td>integer</td><td>Sets the size of POV-Ray's internal "I-Stacks" for tracking ray/object intersections. The default value for <code>maxIntersections</code> is 64, but if a rendering produces an error message about an I-Stack overflow, you will have to increase this value until the error message disappears.</td></tr>
<tr><td>RW</td><td>N</td><td>maxTraceLevel</td><td>integer</td><td>Sets an upper limit on the number of reflections that a ray can undergo before calculations are stopped and the pixel returns as black. Legal values are in the range 1-256. Increase the value only as needed to fix black spots in reflections as higher values require more memory and time to calculate.</td></tr>
<tr><td>RW</td><td>N</td><td>mmPerUnit</td><td>float</td><td>Sets the number of millimeters per unit of space in the POV-Ray coordinate system, which affects the behavior of subsurface transport. The default is 10, i.e., 1 cm per unit.</td></tr>
<tr><td>RW</td><td>N</td><td>noiseGenerator</td><td>integer</td><td>Specifies which noise generator POV-Ray will use. The default is 2. The legal values are 
<table class="sgrid codeDoc">
<thead>

<tr><th>Code</th><th>Meaning</th></tr>
</thead><tbody>
<tr><td>1</td><td>The original noise generator from POV-Ray 3.1 and earlier</td></tr>
<tr><td>2</td><td>An improved noise generator with fewer artifacts</td></tr>
<tr><td>3</td><td>Perlin noise</td></tr>
</tbody></table>
</td></tr>
<tr><td>RW</td><td>N</td><td>numberOfWaves</td><td>integer</td><td>Specifies the number of waves used by the <code>waves</code> and <code>ripples</code> texture patterns. The default is 10.</td></tr>
<tr><td>RW</td><td>N</td><td>photon</td><td>boolean</td><td>If <code>true</code>, photons are enabled and the <code>photon*</code> parameters are emitted in output.</td></tr>
<tr><td>RW</td><td>N</td><td>photonAdcBailout</td><td>float</td><td>Specifies an Adaptive Depth Control for photons. If not specified, the regular <code>adcBailout</code> will be used.</td></tr>
<tr><td>RW</td><td>N</td><td>photonAutostop</td><td>float</td><td>This is a float in the unit interval (0.0 - 1.0) that determines how much of an object's bounding volume must be tested before aborting. It defaults to 0, but objects with holes often require a higher value.</td></tr>
<tr><td>RW</td><td>N</td><td>photonCount</td><td>integer</td><td>Determines the number of photons to use. Cannot be used at the same time as <code>photonSpacing</code></td></tr>
<tr><td>RW</td><td>N</td><td>photonExpandThresholds</td><td>Array</td><td>An array of a float in the unit interval (0.0 - 1.0) and an integer which define how much the adaptive search radius can be increased before reverting to <code>photonRadius</code> and the minimum number of photons to gather, respectively. The default is <code>[0.2, 40]</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>photonGather</td><td>Array</td><td>This is an array of two integers which specify the minimum and maximum number of photons to gather at each point. The default is <code>[20, 100]</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>photonJitter</td><td>float</td><td>Specifies the amount of jitter to use in the pre-processing step. The default is 0.4 and rarely needs to be changed.</td></tr>
<tr><td>RW</td><td>N</td><td>photonLoadFile</td><td>string</td><td>Specifies a photon map to load instead of performing the calculations.</td></tr>
<tr><td>RW</td><td>N</td><td>photonMaxTraceLevel</td><td>integer</td><td>Sets an upper limit on the number of reflections that a photon can undergo before calculations are stopped. Legal values are in the range 1-256. If unspecified, the global <code>maxTraceLevel</code> is used.</td></tr>
<tr><td>RW</td><td>N</td><td>photonMedia</td><td>Array</td><td>If specified, media photons are enabled. This is an array of an integer and a float. The integer specifies the maximum number of photons to deposit over an interval, and the float specifies the difference in media spacing relative to surface spacing.</td></tr>
<tr><td>RW</td><td>N</td><td>photonRadius</td><td>Array</td><td>This is an array of four floats that specify the gather radius, its multiplier, the media gather radius, and its multiplier.</td></tr>
<tr><td>RW</td><td>N</td><td>photonSaveFile</td><td>string</td><td>Saves the calculated photon map to this file for reuse.</td></tr>
<tr><td>RW</td><td>N</td><td>photonSpacing</td><td>float</td><td>Specifies the average distance between photons on surfaces. Cannot be used at the same time as <code>photonCount</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>radAdcBailout</td><td>float</td><td>Specifies an Adaptive Depth Control for radiosity rays. The default is 0.01.</td></tr>
<tr><td>RW</td><td>N</td><td>radAlwaysSample</td><td>boolean</td><td>If <code>true</code>, new samples will be gathered during the final radiosity pass. This is slower and often produces lower-quality results, so the default is <code>false</code>, but there are some cases where turning it on can correct blotchy imperfections.</td></tr>
<tr><td>RW</td><td>N</td><td>radBrightness</td><td>float</td><td>Specifies the amount by which the brightness of objects should be adjusted before being returned to the rest of the system. The default value is 1.0 and should almost never be changed; individual object properties should be adjusted instead.</td></tr>
<tr><td>RW</td><td>N</td><td>radCount</td><td>Array</td><td>This is an array which specifies the number of radiosity rays emitted when a new radiosity value is needed. The default is 35. The second, optional element sets the number of directions to choose rays from.</td></tr>
<tr><td>RW</td><td>N</td><td>radErrorBound</td><td>float</td><td>Specifies the tolerated error and defaults to 1.8. Lower values are more accurate but require higher <code>radCount</code> values to avoid artifacts and dramatically increase rendering times.</td></tr>
<tr><td>RW</td><td>N</td><td>radGrayThreshold</td><td>float</td><td>This is a float in the unit interval (0.0 - 1.0) that counteracts color bleed by desaturating reflected light. At 0.0 (the default), it has no effect, while at the other extreme, 1.0, reflected light is greyscale only.</td></tr>
<tr><td>RW</td><td>N</td><td>radiosity</td><td>boolean</td><td>If <code>true</code>, radiosity is enabled and the <code>rad*</code> parameters are emitted in output.</td></tr>
<tr><td>RW</td><td>N</td><td>radLowErrorFactor</td><td>float</td><td>The <code>radErrorBound</code> is multiplied by <code>radLowErrorFactor</code> during preliminary passes to reduce the blotchy artifacts that would otherwise occur. The default is 0.5.</td></tr>
<tr><td>RW</td><td>N</td><td>radMaximumReuse</td><td>float</td><td>Sets an upper bound on the reuse of samples. See the POV-Ray documentation for <a href="http://povray.org/documentation/3.7.0/r3_4.html#r3_4_4_3">more details</a>.</td></tr>
<tr><td>RW</td><td>N</td><td>radMaxSample</td><td>float</td><td>Defines an upper limit on the brightness of radiosity samples, which can correct for some brightness artifacts at the expense of realism. Setting <code>radMaxSample</code> to a negative value (the default) will disable it.</td></tr>
<tr><td>RW</td><td>N</td><td>radMinimumReuse</td><td>float</td><td>Sets a lower bound on the reuse of samples. See the POV-Ray documentation for <a href="http://povray.org/documentation/3.7.0/r3_4.html#r3_4_4_3">more details</a>.</td></tr>
<tr><td>RW</td><td>N</td><td>radNearestCount</td><td>integer</td><td>Specifies minimum number of old radiosity values blended together to create a new interpolated value. Defaults to 5 with an upper limit of 20.</td></tr>
<tr><td>RW</td><td>N</td><td>radNormal</td><td>boolean</td><td>If <code>true</code>, radiosity will be affected by normals.</td></tr>
<tr><td>RW</td><td>N</td><td>radPretraceEnd</td><td>float</td><td>Specifies the size of mosaic blocks at the end of the pretrace phase as a fraction of image size. This is float in the unit interval (0.0 - 1.0).</td></tr>
<tr><td>RW</td><td>N</td><td>radPretraceStart</td><td>float</td><td>Specifies the size of mosaic blocks at the start of the pretrace phase as a fraction of image size. This is float in the unit interval (0.0 - 1.0).</td></tr>
<tr><td>RW</td><td>N</td><td>radRecursionLimit</td><td>integer</td><td>Determines how many recursion levels are used to calculate the diffuse inter-reflection. The legal range is 1 - 20, but values above 3 are rarely useful.</td></tr>
<tr><td>RW</td><td>N</td><td>radSubsurface</td><td>boolean</td><td>If <code>true</code>, radiosity calculations will take subsurface light transport into account. This will increase realism where translucent objects are concerned at the expense of increased rendering time.</td></tr>
<tr><td>RW</td><td>N</td><td>subRadiosity</td><td>boolean</td><td>If <code>true</code>, subsurface effects will be applied to incoming radiosity illumination.</td></tr>
<tr><td>RW</td><td>N</td><td>subSamples</td><td>Array</td><td>This is an array of two integers which set the number of samples to use for diffuse scattering and single-scattering approximation. The default for both is 50.</td></tr>
<tr><td>RW</td><td>N</td><td>subsurface</td><td>boolean</td><td>If <code>true</code>, subsurface light transport is enabled and the <code>sub*</code> parameters are emitted in output.</td></tr>
</tbody></table>
</div dh="GlobalSettings">

<h5>Methods</h5>

<div class='fsig'>GlobalSettings(<i>options</i>)</div>

<p class='fdesc'>The constructor may be called without arguments, returning an
object with its attributes initialized to <code>null</code>. The
<code>options</code> argument may also be a plain JavaScript object containing
named initializers. User programs will rarely have to call the <code>GlobalSettings</code>
constructor directly as <code>cpov.globalSettings</code> is already initialized.</p>

<div class='fsig'>xset(<i>valObj</i>)</div>

<p class='fdesc'>This is a convenience function which takes an object full
of key/value pairs and sets several attributes at the same time, much like
the constructor, which avoids having to set them individually. The following
are equivalent:</p>

<div class='code fdesc'>cpov.globalSettings.numberOfWaves = 3;
cpov.globalSettings.charset = "utf8";

// is the same as...

cpov.globalSettings.xset({numberOfWaves: 3, charset: "utf8"});</div>

<h4>cpov Methods</h4>

<p>This section only lists public methods commonly used in user programs.
For the complete list, see the <a
href="#tocInside_the_cpov_Object">developer documentation</a>.</p>

<div class="fsig">cpov.deg2rad(<i>deg</i>)</div>

<p class="fdesc">Converts the value of <code>deg</code> from degrees to radians
and returns the result.</p>

<div class="fsig">cpov.endAnimation()</div>

<p class="fdesc">When called by the user program, this method terminates the
animation loop. If a frame is in progress when it is called, it will not be
output, so it is normally called after file output.</p>

<div class="fsig">cpov.error(<i>level</i>, <i>message</i>, <i>location</i> = "CEPHALOPOV", <i>obj</i> = null)</div>

<p class="fdesc">Outputs an error <code>message</code> using pretty colors if
supported by the terminal. The <code>level</code> argument may be one of
<code>"fatal"</code>, <code>"warn"</code>, <code>"info"</code>, or
<code>"debug"</code>. If <code>level</code> is <code>"fatal"</code>, the program
terminates immediately unless <code>cpov.settings.debug</code> is greater than
<code>1</code>. (This is useful for debugging when working on CephaloPOV
itself.) All other error levels simply emit an error message. This will appear
on the terminal for <code>"warn"</code>, <code>"info"</code>, and
<code>"debug"</code> at <code>cpov.verbosity</code> levels of <code>1</code>,
<code>2</code>, and <code>3</code>, respectively. In all cases, the error will
also be written to <code>cpov.settings.debugLog</code> if initialized.</p>

<p class='fdesc'>The error message is prefixed with the <code>location</code>
where the error occurred, usually a class and method name, and the object <code>serial</code>
and <code>id</code>, if any, are appended to the end of the line.</p>

<div class="fsig">cpov.outputFrame()</div>

<p class="fdesc">The <code>cpov.outputFrame</code> method exists for user
programs to call whenever they have finished setting up a scene. It takes no
arguments, its behavior being determined mostly by
<code>cpov.imageOptions</code> and <code>cpov.globalSettings</code>. That
behavior is already described in great detail in <a
href="#tocThe%20Animation%20Cycles">The Animation Cycles</a> and will not be
repeated here.</p>

<p class="fdesc">There is no return value. If any termination conditions are
met, CephaloPOV will terminate with an exit code of <code>0</code>.</p>

<div class="fsig">cpov.requireOptLib(<i>alias</i>)</div>

<p class="fdesc">CephaloPOV includes a number of optional libraries that are not
automatically loaded at runtime. Each is identified by a mnemonic <code>alias</code>
passed to <code>cpov.requireOptLib</code>, which in turn loads the library and returns
it to the caller. Many of these are ports of POV-Ray include files to JavaScript
identified by their original filename, e.g., <code>colors.inc</code>.</p>

<div class="fsig">cpov.runAnimation()</div>

<p class="fdesc">This is the main animation loop which repeats, calling
<code>cpov.outputFrame()</code> repeatedly until one of its termination
conditions are met or the user program calls <code>cpov.endAnimation</code>.</p>

<h3>Vectors, Colors, and Matrices</h3>

<p>Most of the geometry in POV-Ray is defined in terms of vectors, i.e., arrays of floats
whose interpretation depends on context. For the sake of better type checking, CephaloPOV
implements vectors as distinct classes even though some of them, like <code>VectorUV</code>
and <code>VectorXY</code>, are identical save for their attribute names.</p>

<p>Because initializing vector objects involves more typing than POV-Ray's admirably concise
generic notation, all of CephaloPOV's vector types and other object methods that accept
vectors will take JavaScript arrays as initializers in addition to the generic JavaScript objects that
all CephaloPOV class constructors accept.</p>

<div class='code'>var vec = new VectorXYZ();      // The long way
vec.x = 2;
vec.y = -1;
vec.z = 5.2;

var vec = new VectorXYZ({ x: 2, y: -1, z: 5.2 }); // The shorter generic way

var vec = new VectorXYZ([2, -1, 5.2]);            // The shortest way

// A vector can also copy the values of another vector:

var vec1 = new VectorXYZ([3, 4, 5]);
var vec2 = new VectorXYZ(vec1);

// Since you rarely ever need a bare vector, you can also assign arrays
// to vector attributes in other objects:

var box = new Box();
box.corner1 = [ 0, 0, 0 ];
box.corner2 = [ 1, 1, 1 ];</div>

<p>Like most CephaloPOV objects, all of the vector classes have a <code>toSDL()</code>
method which returns the vector in the form of an SDL string.</p>

<h4>VectorUV</h4>

<p>The <code>VectorUV</code> class is used to define 2D coordinates on the UV
plane for texture mapping. Aside from having coordinates named <code>u</code>
and <code>v</code>, it is otherwise identical to <code>VectorXY</code>.</p>

<h5>Attributes</h5>
<div dh="VectorUV">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>u</td><td>float</td><td>The U coordinate of the vector.</td></tr>
<tr><td>RW</td><td>Y</td><td>v</td><td>float</td><td>The V coordinate of the vector.</td></tr>
</tbody></table>
</div dh="VectorUV">

<h5>Methods</h5>

<div class='fsig'>asArray(<i>mode</i> = "normal")</div>

<p class='fdesc'>Depending on the value of <code>mode</code>, returns the internal
coordinates as a two-element array or, in one case, a <code>null</code>
indicating an error condition. The legal values of <code>mode</code> and their
results are:</p>

<table class='sgrid fdesc'>
    <thead>
        <tr><th>Value</th><th>Results</th></tr>
    </thead><tbody>
        <tr>
            <td><code>"normal"</code></td>
            <td>This is the default. Returns a copy of this.raw in which
            all JavaScript functions have been replaced by their return values.</td>
        </tr><tr>
            <td><code>"literal"</code></td>
            <td>Returns an exact copy of the internal representation.</td>
        </tr><tr>
            <td><code>"calc"</code></td>
            <td>As with <code>"normal"</code>, except that the presence of an SDL
            function will return <code>null</code> instead of the expected array.
            CephaloPOV uses this internally to determine whether a <code>VectorUV</code>
            can be used in numeric computations.</td>
        </tr><tr>
            <td><code>"sdl"</code></td>
            <td>As with <code>"normal"</code>, except that SDL functions are included,
            minus the leading ampersand. CephaloPOV uses this internally to generate
            SDL output.</td>
        </tr>
    </tbody>
</table>

<div class='fsig'>xset(<i>valObj</i>)</div>

<p class='fdesc'>This is a convenience function which takes an object full
of key/value pairs and sets several attributes at the same time, much like
the constructor, which avoids having to set them individually. The following
are equivalent:</p>

<div class='code fdesc'>vec.u = 4;
vec.v = 3.2;;

// is the same as...

vec.xset({u: 4, v: 3.2});</div>

<div class='fsig'>VectorUV(<i>options</i>)</div>

<p class='fdesc'>The constructor may be called without arguments, returning an
object with its attributes initialized to <code>null</code>. The
<code>options</code> argument may also be a plain JavaScript object containing
named initializers, an array of two floats, or another <code>VectorUV</code>
object. The following are all equivalent:</p>

<div class='code fdesc'>var vec1 = new VectorUV({ u: 1, v: 3 });
var vec2 = new VectorUV([1, 3]);
var vec3 = new VectorUV(vec1);</div>

<div class='fsig'>toSDL(<i>stops</i>);</div>

<p class='fdesc'>Returns the SDL representation of the vector as a string,
indented by the optional number of tab <code>stops</code>. If the mandatory
attributes are not specified, a fatal error message is emitted and CephaloPOV
halts.</p>

<div class='fsig'>xset(<i>valObj</i>)</div>

<p class='fdesc'>This is a convenience function which takes an object full
of key/value pairs and sets several attributes at the same time, much like
the constructor, which avoids having to set them individually. The following
are equivalent:</p>

<div class='code fdesc'>vec.u = 4;
vec.v = 3.2;;

// is the same as...

vec.xset({u: 4, v: 3.2});</div>

<h4>VectorXY</h4>

<p>The <code>VectorXY</code> class is used to define 2D coordinates. It is
mostly used to define splines and the outlines of objects which are essentially
sweeps, like the <code>Prism</code>. (For prisms, the points defined are
actually on the XZ plane and the shape is swept along the Y axis, but coming up
with a separate <code>VectorXZ</code> seems excessively pedantic.</p>

<h5>Attributes</h5>

<div dh="VectorXY">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>x</td><td>float</td><td>The X coordinate of the vector.</td></tr>
<tr><td>RW</td><td>Y</td><td>y</td><td>float</td><td>The Y coordinate of the vector.</td></tr>
</tbody></table>
</div dh="VectorXY">

<h5>Methods</h5>

<div class='fsig'>VectorXY(<i>options</i>)</div>

<p class='fdesc'>The constructor may be called without arguments, returning an
object with its attributes initialized to <code>null</code>. The
<code>options</code> argument may also be a plain JavaScript object containing
named initializers, an array of two floats, or another <code>VectorXY</code>
object. The following are all equivalent:</p>

<div class='code fdesc'>var vec1 = new VectorXY({ x: 1, y: 3 });
var vec2 = new VectorXY([1, 3]);
var vec3 = new VectorXY(vec1);</div>

<div class='fsig'>asArray(<i>mode</i> = "normal")</div>

<p class='fdesc'>Depending on the value of <code>mode</code>, returns the internal
coordinates as a two-element array or, in one case, a <code>null</code>
indicating an error condition. The legal values of <code>mode</code> and their
results are:</p>

<table class='sgrid fdesc'>
    <thead>
        <tr><th>Value</th><th>Results</th></tr>
    </thead><tbody>
        <tr>
            <td><code>"normal"</code></td>
            <td>This is the default. Returns a copy of this.raw in which
            all JavaScript functions have been replaced by their return values.</td>
        </tr><tr>
            <td><code>"literal"</code></td>
            <td>Returns an exact copy of the internal representation.</td>
        </tr><tr>
            <td><code>"calc"</code></td>
            <td>As with <code>"normal"</code>, except that the presence of an SDL
            function will return <code>null</code> instead of the expected array.
            CephaloPOV uses this internally to determine whether a <code>VectorXY</code>
            can be used in numeric computations.</td>
        </tr><tr>
            <td><code>"sdl"</code></td>
            <td>As with <code>"normal"</code>, except that SDL functions are included,
            minus the leading ampersand. CephaloPOV uses this internally to generate
            SDL output.</td>
        </tr>
    </tbody>
</table>

<div class='fsig'>toSDL(<i>stops</i>);</div>

<p class='fdesc'>Returns the SDL representation of the vector as a string,
indented by the optional number of tab <code>stops</code>. If the mandatory
attributes are not specified, a fatal error message is emitted and CephaloPOV
halts.</p>

<div class='fsig'>xset(<i>valObj</i>)</div>

<p class='fdesc'>This is a convenience function which takes an object full
of key/value pairs and sets several attributes at the same time, much like
the constructor, which avoids having to set them individually. The following
are equivalent:</p>

<div class='code fdesc'>vec.x = 4;
vec.y = 3.2;;

// is the same as...

vec.xset({x: 4, y: 3.2});</div>

<h4>VectorXYZ</h4>

<p>Probably the most commonly used vector type for most users, the <code>VectorXYZ</code> class
defines points in three-dimensional space.</p>

<h5>Attributes</h5>

<div dh="VectorXYZ">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>x</td><td>float</td><td>The X coordinate of the vector.</td></tr>
<tr><td>RW</td><td>Y</td><td>y</td><td>float</td><td>The Y coordinate of the vector.</td></tr>
<tr><td>RW</td><td>Y</td><td>z</td><td>float</td><td>The Z coordinate of the vector.</td></tr>
</tbody></table>
</div dh="VectorXYZ">

<h5>Methods</h5>

<div class='fsig'>VectorXYZ(<i>options</i>)</div>

<p class='fdesc'>The constructor may be called without arguments, returning an
object with its attributes initialized to <code>null</code>. The
<code>options</code> argument may also be a plain JavaScript object containing
named initializers, an array of three floats, or another <code>VectorXYZ</code>
object. The following are all equivalent:</p>

<div class='code fdesc'>var vec1 = new VectorXYZ({ x: 1, y: 3, z: 4 });
var vec2 = new VectorXYZ([1, 3, 4]);
var vec3 = new VectorXYZ(vec1);</div>

<p class='fdesc'>Depending on the value of <code>mode</code>, returns the internal
coordinates as a three-element array or, in one case, a <code>null</code>
indicating an error condition. The legal values of <code>mode</code> and their
results are:</p>

<table class='sgrid fdesc'>
    <thead>
        <tr><th>Value</th><th>Results</th></tr>
    </thead><tbody>
        <tr>
            <td><code>"normal"</code></td>
            <td>This is the default. Returns a copy of this.raw in which
            all JavaScript functions have been replaced by their return values.</td>
        </tr><tr>
            <td><code>"literal"</code></td>
            <td>Returns an exact copy of the internal representation.</td>
        </tr><tr>
            <td><code>"calc"</code></td>
            <td>As with <code>"normal"</code>, except that the presence of an SDL
            function will return <code>null</code> instead of the expected array.
            CephaloPOV uses this internally to determine whether a <code>VectorXYZ</code>
            can be used in numeric computations.</td>
        </tr><tr>
            <td><code>"sdl"</code></td>
            <td>As with <code>"normal"</code>, except that SDL functions are included,
            minus the leading ampersand. CephaloPOV uses this internally to generate
            SDL output.</td>
        </tr>
    </tbody>
</table>

<div class='fsig'>toSDL(<i>stops</i>);</div>

<p class='fdesc'>Returns the SDL representation of the vector as a string,
indented by the optional number of tab <code>stops</code>. If the mandatory
attributes are not specified, a fatal error message is emitted and CephaloPOV
halts.</p>

<div class='fsig'>xset(<i>valObj</i>)</div>

<p class='fdesc'>This is a convenience function which takes an object full
of key/value pairs and sets several attributes at the same time, much like
the constructor, which avoids having to set them individually. The following
are equivalent:</p>

<div class='code fdesc'>vec.x = 4;
vec.y = 3.2;;

// is the same as...

vec.xset({x: 4, y: 3.2});</div>

<h4>VectorXYZW</h4>

<p>The <code>VectorXYZW</code> class defines points in four-dimensional space,
and as such, it is not often used. One use case is the four-dimensional
<code>JuliaFractal</code>. In the <code>Polynomial</code> type, it is used as a
convenient (and somewhat hackish) way of grouping sets of four floats that are
not actually coordinates.</p>

<h5>Attributes</h5>

<div dh="VectorXYZW">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>x</td><td>float</td><td>The X coordinate of the vector.</td></tr>
<tr><td>RW</td><td>Y</td><td>y</td><td>float</td><td>The Y coordinate of the vector.</td></tr>
<tr><td>RW</td><td>Y</td><td>z</td><td>float</td><td>The Z coordinate of the vector.</td></tr>
<tr><td>RW</td><td>Y</td><td>w</td><td>float</td><td>The W coordinate of the vector.</td></tr>
</tbody></table>
</div dh="VectorXYZW">

<h5>Methods</h5>

<div class='fsig'>VectorXYZW(<i>options</i>)</div>

<p class='fdesc'>The constructor may be called without arguments, returning an
object with its attributes initialized to <code>null</code>. The
<code>options</code> argument may also be a plain JavaScript object containing
named initializers, an array of four floats, or another <code>VectorXYZW</code>
object. The following are all equivalent:</p>

<div class='code fdesc'>var vec1 = new VectorXYZW({ x: 1, y: 3, z: 4, w: -1 });
var vec2 = new VectorXYZW([1, 3, 4, -1]);
var vec3 = new VectorXYZW(vec1);</div>

<p class='fdesc'>Depending on the value of <code>mode</code>, returns the internal
coordinates as a four-element array or, in one case, a <code>null</code>
indicating an error condition. The legal values of <code>mode</code> and their
results are:</p>

<table class='sgrid fdesc'>
    <thead>
        <tr><th>Value</th><th>Results</th></tr>
    </thead><tbody>
        <tr>
            <td><code>"normal"</code></td>
            <td>This is the default. Returns a copy of this.raw in which
            all JavaScript functions have been replaced by their return values.</td>
        </tr><tr>
            <td><code>"literal"</code></td>
            <td>Returns an exact copy of the internal representation.</td>
        </tr><tr>
            <td><code>"calc"</code></td>
            <td>As with <code>"normal"</code>, except that the presence of an SDL
            function will return <code>null</code> instead of the expected array.
            CephaloPOV uses this internally to determine whether a <code>VectorXYZW</code>
            can be used in numeric computations.</td>
        </tr><tr>
            <td><code>"sdl"</code></td>
            <td>As with <code>"normal"</code>, except that SDL functions are included,
            minus the leading ampersand. CephaloPOV uses this internally to generate
            SDL output.</td>
        </tr>
    </tbody>
</table>

<div class='fsig'>toSDL(<i>stops</i>);</div>

<p class='fdesc'>Returns the SDL representation of the vector as a string,
indented by the optional number of tab <code>stops</code>. If the mandatory
attributes are not specified, a fatal error message is emitted and CephaloPOV
halts.</p>

<div class='fsig'>xset(<i>valObj</i>)</div>

<p class='fdesc'>This is a convenience function which takes an object full
of key/value pairs and sets several attributes at the same time, much like
the constructor, which avoids having to set them individually. The following
are equivalent:</p>

<div class='code fdesc'>vec.x = 4;
vec.y = 3.2;;

// is the same as...

vec.xset({x: 4, y: 3.2});</div>

<h4>Color</h4>

<p>The <code>Color</code> class is used to represent RGB colors. In addition to
the usual <code>r</code>, <code>g</code>, and <code>b</code> attributes, it has
two optional attributes, <code>f</code> (filter) and <code>t</code> (transmit).
There is a final optional boolean attribute, <code>sRGB</code> which, if
<code>true</code>, maps the colors to the sRGB color space.</p>

<h5>Attributes</h5>

<div dh="Color">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>r</td><td>float</td><td>The red component of the color, in the unit interval (0.0-1.0).</td></tr>
<tr><td>RW</td><td>Y</td><td>g</td><td>float</td><td>The green component of the color, in the unit interval (0.0-1.0).</td></tr>
<tr><td>RW</td><td>Y</td><td>b</td><td>float</td><td>The blue component of the color, in the unit interval (0.0-1.0).</td></tr>
<tr><td>RW</td><td>N</td><td>f</td><td>float</td><td>The filter component of the color, in the unit interval (0.0-1.0).</td></tr>
<tr><td>RW</td><td>N</td><td>t</td><td>float</td><td>The transmit component of the color, in the unit interval (0.0-1.0).</td></tr>
<tr><td>RW</td><td>N</td><td>srgb</td><td>float</td><td>If <code>true</code>, specifies sRGB gamma values. This will produce an error when POV-Ray parses CephaloPOV's output if <code>cpov.globalSettings.assumedGamma</code> is not set.</td></tr>
</tbody></table>
</div dh="Color">

<h5>Methods</h5>

<div class='fsig'>Color(<i>options</i>)</div>

<p class='fdesc'>The constructor may be called without arguments, returning an
object with its attributes initialized to <code>null</code>. The
<code>options</code> argument may also be a plain JavaScript object containing
named initializers, an array of three to six values, or another
<code>Color</code> object. The following are all equivalent:</p>

<div class='code fdesc'>var color1 = new Color({ r: 1.0, g: 0.2, b: 0.33, f: 0.2, t: 1.0, srgb: true });
var color2 = new Color([1.0, 0.2, 0.33, 0.2, 1.0, true]);
var color3 = new Color(color2);</div>

<p class='fdesc'>Note that the <code>f</code>, <code>t</code>, and
<code>srgb</code> attributes are optional, so none, any, or all of them can be
used, but they must be specified in order when passing a bare array.</p>

<div class='fsig'>toSDL(<i>stops</i>);</div>

<p class='fdesc'>Returns the SDL representation of the vector as a string,
indented by the optional number of tab <code>stops</code>. If the mandatory
attributes are not specified, a fatal error message is emitted and CephaloPOV
halts.</p>

<div class='fsig'>xset(<i>valObj</i>)</div>

<p class='fdesc'>This is a convenience function which takes an object full
of key/value pairs and sets several attributes at the same time, much like
the constructor, which avoids having to set them individually. The following
are equivalent:</p>

<div class='code fdesc'>color.r = 0.2;
vec.g = 1.0;;

// is the same as...

vec.xset({r: 0.2, g: 1.0});</div>

<h4>Matrix</h4>

<p>The <code>Matrix</code> type is the workhorse of transformations and
one of the areas where CephaloPOV differs most from the way POV-Ray handles
transformations, though this is more a matter of syntax than anything else.</p>

<h5>Attributes</h5>

<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>v00</td><td>float</td><td>Row 0, column 0 of the matrix.</td></tr>
<tr><td>RW</td><td>Y</td><td>v01</td><td>float</td><td>Row 0, column 1 of the matrix.</td></tr>
<tr><td>RW</td><td>Y</td><td>v02</td><td>float</td><td>Row 0, column 2 of the matrix.</td></tr>
<tr><td>RW</td><td>Y</td><td>v10</td><td>float</td><td>Row 1, column 0 of the matrix.</td></tr>
<tr><td>RW</td><td>Y</td><td>v11</td><td>float</td><td>Row 1, column 1 of the matrix.</td></tr>
<tr><td>RW</td><td>Y</td><td>v12</td><td>float</td><td>Row 1, column 2 of the matrix.</td></tr>
<tr><td>RW</td><td>Y</td><td>v20</td><td>float</td><td>Row 2, column 0 of the matrix.</td></tr>
<tr><td>RW</td><td>Y</td><td>v21</td><td>float</td><td>Row 2, column 1 of the matrix.</td></tr>
<tr><td>RW</td><td>Y</td><td>v22</td><td>float</td><td>Row 2, column 2 of the matrix.</td></tr>
<tr><td>RW</td><td>Y</td><td>v30</td><td>float</td><td>Row 3, column 0 of the matrix.</td></tr>
<tr><td>RW</td><td>Y</td><td>v31</td><td>float</td><td>Row 3, column 1 of the matrix.</td></tr>
<tr><td>RW</td><td>Y</td><td>v32</td><td>float</td><td>Row 3, column 2 of the matrix.</td></tr>
</tbody></table>

<h5>Methods</h5>

<div class="fsig">Matrix(<i>v00</i>, <i>v01</i>, <i>v02</i>, <i>v10</i>, <i>v11</i>, <i>v12</i>, <i>v20</i>, <i>v21</i>, <i>v22</i>, <i>v30</i>, <i>v31</i>, <i>v32</i>);</div>

<p class='fdesc'>In its basic form, which few users will often use, the
constructor takes twelve floats for each of the values in the matrix, just as it
is done in SDL. Like SDL, there are several short convenience forms for the
basic transformations:</p>

<div class='code fdesc'>var scale     = new Matrix("scale", 1.5, 2, 1);
var translate = new Matrix("translate", 5, 2.2, 0);
var rotate    = new Matrix("rotate", 45, 15, 0);

var scale     = new Matrix("scale", 2.2);
var translate = new Matrix("translate", 5);
var rotate    = new Matrix("rotate", 45);
</div>

<p class='fdesc'>In the first set of the examples above, the name of the
transformation is the first argument, followed by three float arguments, one for
each of the axes. In the second set, the single float is applied to all three
axes. As with POV-Ray, the values for rotations are given in degrees.</p>

<p class='fdesc'>The <code>Matrix</code> constructor has a few additional short
forms. One lets you specify skews without having to construct the whole
matrix by hand. Just pass <code>"skew"</code> as the first argument, and the
second argument is an object containing the axis pairs to perform the skew by,
like so:</p>

<div class='code fdesc'>var skew = new Matrix("skew", { xy: 1.5, zy: 0.2 });</div>

<p class='fdesc'>The complete set of axis pairs is <code>yx</code>,
<code>zx</code>, <code>xy</code>, <code>zy</code>, <code>xz</code>, and
<code>yz</code>. You can omit the pairs you don't need.</p>

<p class='fdesc'>In another, you can just pass <code>"none"</code> as the sole
argument and get a <code>Matrix</code> that does nothing. This is useful if your
"base" transformation (see the <code>Primitive</code> type for more details)
doesn't require any actual transformations.</p>

<div class='fsig'>asArray(<i>mode</i> = "normal")</div>

<p class='fdesc'>Depending on the value of <code>mode</code>, returns the internal
matrix representation as a 12-element array or, in one case, a <code>null</code>
indicating an error condition. The legal values of <code>mode</code> and their
results are:</p>

<table class='sgrid fdesc'>
    <thead>
        <tr><th>Value</th><th>Results</th></tr>
    </thead><tbody>
        <tr>
            <td><code>"normal"</code></td>
            <td>This is the default. Returns a copy of this.raw in which
            all JavaScript functions have been replaced by their return values.</td>
        </tr><tr>
            <td><code>"literal"</code></td>
            <td>Returns an exact copy of the internal representation.</td>
        </tr><tr>
            <td><code>"calc"</code></td>
            <td>As with <code>"normal"</code>, except that the presence of an SDL
            function will return <code>null</code> instead of the expected array.
            CephaloPOV uses this internally to determine whether a <code>Matrix</code>
            can be used in numeric computations.</td>
        </tr><tr>
            <td><code>"sdl"</code></td>
            <td>As with <code>"normal"</code>, except that SDL functions are included,
            minus the leading ampersand. CephaloPOV uses this internally to generate
            SDL output.</td>
        </tr>
    </tbody>
</table>

<div class='fsig'>copyFrom(<i>that</i>)</div>

<p class='fdesc'>Copies the values from <code>that</code> to this <code>Matrix</code>.</p>

<div class='fsig'>isIdentityMatrix()</div>

<p class='fdesc'>Returns <code>true</code> if <code>this.raw</code> is the same
as the identity matrix with which it was initialized. Note that this only compares
literal numeric values. If the members of the array are functions, this method
will return <code>false</code> even if the end result is the identity matrix.</p>

<div class='fsig'>rotate(<i>x</i>, <i>y</i>, <i>z</i>)</div>

<p class='fdesc'>This is a convenience method for applying a rotation to the
current <code>Matrix</code>. Values are in degrees, and if <code>y</code> and
<code>z</code> are <code>undefined</code>, the value of <code>x</code> will be
used for both of them.</p>

<div class='fsig'>scale(<i>x</i>, <i>y</i>, <i>z</i>)</div>

<p class='fdesc'>This is a convenience method for applying a scale
transformation to the current <code>Matrix</code>. If <code>y</code> and
<code>z</code> are <code>undefined</code>, the value of <code>x</code> will be
used for both of them.</p>

<div class='fsig'>skew(<i>pairs</i>)</div>

<p class='fdesc'>This is a convenience method for applying skew transformations
to the current <code>Matrix</code>. As with the similar convenience form in the
constructor, the pairs of axes are passed as members of the <code>pairs</code>
object, e.g.</p>

<div class='fdesc code'>someMatrix.skew({ yx: 1.5 });</div>

<div class='fsig'>translate(<i>x</i>, <i>y</i>, <i>z</i>)</div>

<p class='fdesc'>This is a convenience method for applying a translation to the
current <code>Matrix</code>. If <code>y</code> and <code>z</code> are
<code>undefined</code>, the value of <code>x</code> will be used for both of
them.</p>

<div class='fsig'>toSDL(<i>stops</i>);</div>

<p class='fdesc'>Returns the SDL representation of the matrix as a string,
indented by the optional number of tab <code>stops</code>. Unlike most other
<code>toSDL</code> methods, this one always succeeds because the constructor
either requires or supplies all of the mandatory values.</p>

<div class='fsig'>xMatrix(<i>that</i>);</div>

<p class='fdesc'>Given another <code>Matrix</code>, <code><i>that</i></code>,
returns a new <code>Matrix</code> that is the product of
<code><i>this</i></code> &times; <code><i>that</i></code>.</p>

<div class='fsig'>xPoint(<i>point</i>);</div>

<p class='fdesc'>Given a <code>VectorXYZ</code>, <code><i>point</i></code>,
returns a new <code>VectorXYZ</code> which has been transformed by the
matrix.</p>

<div class='fsig'>xset(<i>valObj</i>)</div>

<p class='fdesc'>This is a convenience function which takes an object full
of key/value pairs and sets several attributes at the same time, much like
the constructor, which avoids having to set them individually. The following
are equivalent:</p>

<div class='code fdesc'>matrix.v01 = 4;
matrix.v02 = 3.2;

// is the same as...

matrix.xset({v01: 4, v02: 3.2});</div>

<h3>Geometric Primitives</h3>

<h4>Primitive</h4>

<p>The <code>Primitive</code> type is the base class for all of the other
geometric primitives. Unless you're implementing a new primitive, perhaps for
one of the experimental forks of POV-Ray like MegaPOV, you don't need to worry
about its internals, but you do need to be familiar with the public attributes
and methods it shares with all of its subclasses.</p>

<h5>Transformations</h5>

<p>Two of those attributes, <code>baseTransform</code> and
<code>transform</code>, are important enough to discuss outside of the
attributes table, below. In order to support several significant features
now and in the future, CephaloPOV distinguishes between an initial
transformation that is effectively part of the definition of an object and
subsequent transformations applied to it. That initial transformation is the
<code>baseTransform</code>, and the subsequent transformations are combined
mathematically in the <code>transform</code> attribute.</p>

<p>When a <code>Primitive</code> is output to SDL, the current value of its
<code>transform</code> attribute is included in the object definition. The
<code>baseTransform</code> is kept internal to CephaloPOV to help with geometric
queries and the scene graph system. Most of the time, you won't have to do
anything more than set the <code>baseTransform</code>, though it can be useful
in user code in snapshot mode, as we will see.</p>

<p>The easiest way and clearest way to establish the <code>baseTransform</code>
is simply to assign it:</p>

<div class='code'>someBox.baseTransform = new Matrix("rotate", 0, 45, 15);</div>

<p>If you don't set <code>baseTransform</code> explicitly, setting
<code>transform</code> will set it at the same time. Naturally, if you are
defining an object that doesn't change from frame to frame and its initial
parameters are fine without any transformations at all, you don't have to bother
with either transform attribute.</p>

<p>Each time thereafter that you set <code>transform</code>, the supplied
<code>Matrix</code> is <em>multiplied</em> by the existing
<code>transform</code> value. Because of the way matrix multiplication works,
this will effectively add the new transformation to the transformations that
have already been applied. If you want to start over fresh with the
<code>baseTransform</code> value, just call the <code>resetTransform</code>
method.</p>

<p>The main purpose of all of this behind-the-scenes plumbing is to provide the
necessary basis for higher-level features like the <span class='ephemeral'>not
yet implemented</span> scene graph, and you don't have to worry about it much in
your own user programs. One exception to this is if you are using snapshot mode,
where multiple output objects can be created using a single primitive object and
repeatedly setting <code>transform</code> and then calling
<code>baseTransform</code>.</p>

<p>Like most other object attributes in CephaloPOV, transformations can be
either the necessary type (in this case <code>Matrix</code>), or a JavaScript
function returning a <code>Matrix</code>, or SDL code supplied as a string with
the usual <code>"&"</code> prefix. Barring bugs, all three are perfectly fine,
but <code>transform</code> is frequently the subject of matrix multiplication at
the JavaScript level. How does this work?</p>

<p>A numeric <code>Matrix</code> performs exactly as expected. SDL strings will
halt the program with an error. If <code>transform</code> is a JavaScript
function returning a <code>Matrix</code>, it will be replaced with its return
value and then altered accordingly. The same applies to JavaScript functions as
individual matrix elements. This is one of the few places that the difference
between the three execution scopes&mdash;CephaloPOV, the user program, and
POV-Ray&mdash;is so important to understand clearly. The power and flexibility
of the approach is great, but you can expect a little eye-crossing confusion at
first.</p>

<h5>Attributes</h5>

<div dh="Primitive">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>N</td><td>active</td><td>boolean</td><td>If <code>active == false</code>, it will not be output to the current .pov frame file. Defaults to <code>true</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>baseTransform</td><td>Matrix</td><td>The <code>baseTransform</code> attribute contains the "default" transformation of the object. As new transformations are applied, the original <code>baseTransform</code> remains unchanged, making it easy to revert to the original state by calling the <code>resetTransform</code> method.</td></tr>
<tr><td>RW</td><td>N</td><td>boundedBy</td><td>Primitive</td><td>Defines a manual bounding volume for the object.</td></tr>
<tr><td>RW</td><td>N</td><td>clippedBy</td><td>Primitive</td><td>Specifies a solid <code>Primitive</code> that the object is clipped by in a manner similar to CSG intersection.</td></tr>
<tr><td>RW</td><td>N</td><td>doubleIlluminate</td><td>boolean</td><td>If <code>true</code>, the object is illuminated on its shadow side.</td></tr>
<tr><td>RW</td><td>N</td><td>finish</td><td>Finish</td><td class='dummy'>TODO: Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce nec tellus quis turpis pretium condimentum ut eget neque. Integer pharetra imperdiet elit, eu malesuada tortor.</td></tr>
<tr><td>RW</td><td>N</td><td>frameBegin</td><td>function</td><td>If defined, this function will be called at the beginning of a frame before output.</td></tr>
<tr><td>RW</td><td>N</td><td>frameEnd</td><td>function</td><td>If defined, this function will be called at the end of a frame after output.</td></tr>
<tr><td>RW</td><td>N</td><td>hollow</td><td>boolean</td><td>If <code>true</code>, this will make an otherwise solid primitive hollow. Has no effect on objects which are not solid.</td></tr>
<tr><td>RW</td><td>N</td><td>id</td><td>string</td><td>An optional, unique string which serves to identify an object. While you can pull objects out of <code>cpov.idMap</code> using this value, it is output in error messages, making it easier to find the offending object.</td></tr>
<tr><td>RW</td><td>N</td><td>interior</td><td>Interior</td><td class="niy">NOT IMPLEMENTED YET</td></tr>
<tr><td>RW</td><td>N</td><td>inverse</td><td>boolean</td><td>If <code>true</code>, the inside and outside of the solid object are swapped. For example, a hollow <code>Sphere</code> would consist of a spherical void in an infinite solid mass. This is mainly useful in CSG objects.</td></tr>
<tr><td>RW</td><td>N</td><td>material</td><td>Material</td><td class="niy">NOT IMPLEMENTED YET</td></tr>
<tr><td>RW</td><td>N</td><td>noImage</td><td>boolean</td><td>If <code>true</code>, the object will be invisible to cameras, but it will still cast shadows and show up in reflections.</td></tr>
<tr><td>RW</td><td>N</td><td>noRadiosity</td><td>boolean</td><td>If <code>true</code>, the object will be invisible to radiosity rays.</td></tr>
<tr><td>RW</td><td>N</td><td>noReflection</td><td>boolean</td><td>If <code>true</code>, the object will not be visible in reflections.</td></tr>
<tr><td>RW</td><td>N</td><td>noShadow</td><td>boolean</td><td>If <code>true</code>, the object will not cast shadows.</td></tr>
<tr><td>RO</td><td>N</td><td>parent</td><td>Primitive</td><td>This is a read-only reference to the parent object of which the current object is a component, e.g., <code>Blob</code>, <code>Mesh</code>, and CSG objects.</td></tr>
<tr><td>RW</td><td>N</td><td>photons</td><td>TODO</td><td class='dummy'>TODO: Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce nec tellus quis turpis pretium condimentum ut eget neque. Integer pharetra imperdiet elit, eu malesuada tortor.</td></tr>
<tr><td>RW</td><td>N</td><td>radiosity</td><td>TOOD</td><td class='dummy'>TODO: Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce nec tellus quis turpis pretium condimentum ut eget neque. Integer pharetra imperdiet elit, eu malesuada tortor.</td></tr>
<tr><td>RW</td><td>N</td><td>satellites</td><td>[Primitive]</td><td>This is an array of <code>Primitive</code> objects to which the same transformations will be applied as the parent. Among other things, this makes it possible to attach one or more <code>Camera</code>s to an object.</td></tr>
<tr><td>RW</td><td>N</td><td>SDLAppend</td><td>string</td><td>A string supplied here (presumably SDL) will be output after the object. It does not require the usual <code>'&'</code> prefix.</td></tr>
<tr><td>RW</td><td>N</td><td>SDLPrepend</td><td>string</td><td>A string supplied here (presumably SDL) will be output before the object. It does not require the usual <code>'&'</code> prefix.</td></tr>
<tr><td>RW</td><td>N</td><td>serial</td><td>integer</td><td>This is a unique read-only integer serial number automatically assigned by CephaloPOV upon object creation. It is displayed in error messages, and objects can be looked up using <code>cpov.serialMap</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>texture</td><td>string</td><td>Pending implementation of CephaloPOV's texture subsystem, this is a literal SDL string which will be output as-is.</td></tr>
<tr><td>RW</td><td>N</td><td>transform</td><td>Matrix</td><td>This is a <code>Matrix</code> representing the current transformation state of the object, as distinct from <code>baseTransform</code>, which represents its original state. <code>Matrix</code> values assigned to the <code>transform</code> attribute are silently multiplied against its current value.</td></tr>
</tbody></table>
</div dh="Primitive">

<h5>Methods</h5>

<div class='fsig'>resetTransform();</div>

<p class='fdesc'>Restores the object's current <code>transform</code> to the
value of its <code>baseTransform</code>.</p>

<div class='fsig'>rotate(<i>x</i>, <i>y</i>, <i>z</i>)</div>

<p class='fdesc'>This is a convenience method for applying a rotation to the
current object. Values are in degrees, and if <code>y</code> and <code>z</code>
are <code>undefined</code>, the value of <code>x</code> will be used for both of
them.</p>

<div class='fsig'>scale(<i>x</i>, <i>y</i>, <i>z</i>)</div>

<p class='fdesc'>This is a convenience method for applying a scale
transformation to the current object. If <code>y</code> and <code>z</code> are
<code>undefined</code>, the value of <code>x</code> will be used for both of
them.</p>

<div class='fsig'>skew(<i>pairs</i>)</div>

<p class='fdesc'>This is a convenience method for applying skew transformations
to the current object. As with the similar convenience form in the constructor,
the pairs of axes are passed as members of the <code>pairs</code> object,
e.g.</p>

<div class='fdesc code'>someObj.skew({ yx: 1.5 });</div>


<div class='fsig'>snapshot();</div>

<p class='fdesc'>If <code>cpov.settings.snapshotMode</code> is <code>true</code>, this
method sends the output of <code>toSDL</code> to the snapshot output buffer,
where it will remain until <code>cpov.outputFrame</code> is called.</p>

<div class='fsig'>toSDL(<i>stops</i>);</div>

<p class='fdesc'>Returns the SDL representation of the <code>Primitive</code> as
a string, indented by the optional number of tab <code>stops</code>. User
programs will seldom if ever call this directly, but it is overridden and called
by the <code>toSDL</code> methods in the subclasses. Those subclass methods will
emit a fatal error message if any mandatory attributes are not specified, but
the <code>Primitive</code> base class has no mandatory attributes, so this call
will always succed.</p>

<div class='fsig'>translate(<i>x</i>, <i>y</i>, <i>z</i>)</div>

<p class='fdesc'>This is a convenience method for applying a translation to the
current object. If <code>y</code> and <code>z</code> are <code>undefined</code>,
the value of <code>x</code> will be used for both of them.</p>

<div class='fsig'>xset(<i>valObj</i>)</div>

<p class='fdesc'>This is a convenience function which takes an object full
of key/value pairs and sets several attributes at the same time, much like
the constructor, which avoids having to set them individually. The following
are equivalent:</p>

<div class='code fdesc'>box.corner1 = [-1, -1, -1];
box.corner2 = [1, 1, 1];

// is the same as...

box.xset({corner1: [-1, -1, -1], corner2: [1, 1, 1]});</div>

<table class="illusBasic">
<tr><td colspan='2'><h4>BicubicPatch</h4></td></tr>
<tr><td>

<p>The <code>BicubicPatch</code> type is a curved surface defined by a
4&nbsp;&times;&nbsp;4 array of <code>VectorXYZ</code> control points which are
interpolated behind the scenes using Bezier splines and converted to a mesh of
triangles. The number of triangles used along the u- and v-axes are defined by
<code>uSteps</code> and <code>vSteps</code>.</p>

<div class='code'>var obj = new BicubicPatch({
    type: 0,
    flatness: 0.01,
    uSteps: 4,
    vSteps: 4,
    points: [
        [0, 2, 0], [0, 0, 1], [0, 0, 2], [0, -2, 3],
        [1, 0, 0], [1, 0, 1], [1, 0, 2], [1,  0, 3],
        [2, 0, 0], [2, 0, 1], [2, 0, 2], [2,  0, 3],
        [3, 2, 0], [3, 0, 1], [3, 0, 2], [3, -2, 3]
    ]
});</div>

</td><td>

    <img src="img/bicubicpatch_basic.png">

</td></tr></table>

<h5>Attributes</h5>

<div dh="BicubicPatch">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>points</td><td>[VectorXYZ]</td><td>The <code>points</code> attribute is an array of 16 <code>VectorXYZ</code> points which define the 4 &times; 4 array of control points that define the patch.</td></tr>
<tr><td>RW</td><td>Y</td><td>type</td><td>integer</td><td>This may be either 0 or 1. Type 0 reduces the amount of memory used to store the patch in memory at the cost of slower rendering. Type 1 does the reverse, consuming more memory but reducing the number of calculations required.</td></tr>
<tr><td>RW</td><td>N</td><td>flatness</td><td>float</td><td>If <code>flatness</code> is 0 (the default), the patch will be subdivided into only as many triangles as specified by <code>uSteps</code> and <code>vSteps</code>. Increasing it up to a maximum of 1.0 will encourage POV-Ray to automatically subdivide the patch into additional triangles as needed.</td></tr>
<tr><td>RW</td><td>N</td><td>uSteps</td><td>integer</td><td>Defines the number of rows of triangles used to create the patch. Most patches can be acceptably rendered using 3 rows.</td></tr>
<tr><td>RW</td><td>N</td><td>vSteps</td><td>integer</td><td>Defines the number of columns of triangles used to create the patch. Most patches can be acceptably rendered using 3 columns.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>BicubicPatch</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csgOperand</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV treats it as similar to one in many ways. For a <code>BicubicPatch</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>BicubicPatch</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>BicubicPatch</code>, this is always <code>false</code>.</td></td></tr>
</tbody></table>
</div dh="BicubicPatch">

<table class="illusBasic">
<tr><td colspan='2'><h4>Blob</h4></td></tr>
<tr><td>

<p>The <code>Blob</code> type is an isosurface of scalar fields produced by
points and lines represented in the <code>components</code> array by
<code>Sphere</code> and <code>Cylinder</code> objects. What this means in
practice is that each object has a field <code>strength</code> that starts at
the center of the object and drops to zero at its <code>radius</code>. The
surface of the blob is wherever the overlapping fields have a value equal to the
blob's <code>threshold</code> value, which defaults to 1.0. The effect is a smooth
surface like drops and strings of honey.</p>

<p>This makes the <code>Blob</code> an excellent tool for building smooth,
organic shapes. In the simple example here, a <code>Blob</code> composed of
three <code>Sphere</code> objects forms a lumpy diagonal line through the demo
stage space.</p>

<div class='code'>var obj = new Blob({
    components: [
        new Sphere({ center: [-1.5, -1.5, -1.5],
            radius: 2, strength: 4 }),
        new Sphere({ center: [   0,    0,    0],
            radius: 2, strength: 4 }),
        new Sphere({ center: [ 1.5,  1.5,  1.5],
            radius: 2, strength: 4 }),
    ]
});</div>

</td><td>

    <img src="img/blob_basic.png">

</td></tr></table>

<h5>Attributes</h5>

<div dh="Blob">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>components</td><td>Array</td><td>This is an array of <code>Sphere</code> and <code>Cylinders</code>, optionally with their <code>strength</code> attributes set.</td></tr>
<tr><td>RW</td><td>N</td><td>hierarchy</td><td>hierarchy</td><td>If <code>false</code>, turn off the internal bounding hierarchy.</td></tr>
<tr><td>RW</td><td>N</td><td>sturm</td><td>boolean</td><td>If <code>true</code>, POV-Ray will use the slower but more accurate Sturmian root solver. Use this if the surface exhibits holes or other imperfections.</td></tr>
<tr><td>RW</td><td>N</td><td>threshold</td><td>float</td><td>The <code>threshold</code> determines the field strength that distinguishes between the inside and outside of a <code>Blob</code>, i.e., <code>threshold</code> defines the surface of a <code>Blob</code>.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Blob</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csgOperand</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV treats it as similar to one in many ways. For a <code>Blob</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Blob</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Blob</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Blob">

<table class="illusBasic">
<tr><td colspan='2'><h4>Box</h4></td></tr>
<tr><td>

<p>The <code>Box</code> type is exactly what it sounds like: a rectangular box.
It is defined by the coordinates of two diagonally opposite corners,
<code>corner1</code> and <code>corner2</code>. Its sides are orthogonal to the
axes, so other orientations will require applying a transformation. The example
at right was created by the following code:</p>

<div class='code'>var obj = new Box({
    corner1: [2, 2, 2],
    corner2: [-2, -2, -2]
});</div>

</td><td>

    <img src="img/box_basic.png">

</td></tr></table>


<h5>Attributes</h5>

<div dh="Box">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>corner1</td><td>VectorXYZ</td><td>The first of two opposite corners of the cube.</td></tr>
<tr><td>RW</td><td>Y</td><td>corner2</td><td>VectorXYZ</td><td>The first of two opposite corners of the cube.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Box</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csgOperand</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV treats it as similar to one in many ways. For a <code>Box</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Box</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Box</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Box">

<h4>Camera</h4>

<p><code>Camera</code> objects provide a point of view in the scene. There can
be many in a scene, but only one can have its <code>active</code> flag set to
<code>true</code> when a frame is output. POV-Ray will happily accept multiple
cameras, but it only uses the last one defined in the <code>.pov</code> file. In
keeping with CephaloPOV's philosophy of catching errors early so you don't have
to puzzle over a broken SDL script, only the first active camera is output and a
warning is issued for the others.</p>

<p>Unlike a <code>LightSource</code>, POV-Ray will for some reason not allow
cameras to be part of CSG operations, hence <code>Camera.csgOperand</code> is
always false. Because it is often extremely useful to attach a camera to an
object and doing so manually would involve a lot of extra code for user
programs, CephaloPOV's <code>Primitive</code> class includes a
<code>satellites</code> attribute that provides an easy workaround. A simple
array of other <code>Primitive</code> objects, transformations applied to the
parent are applied to each of the satellite objects, keeping them in the same
relationship to the parent as when they were defined. Technically, any
<code>Primitive</code> can be used as a satellite, but you're probably best off
sticking to <code>Union</code> or <code>Merge</code> CSG objects, as they are
more robust.</p>


<h5>Attributes</h5>

<div dh="Camera">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>type</td><td>string</td><td>Defines the type of the camera. The legal values are 
<table class="sgrid codeDoc">
<thead>

<tr><th>Code</th><th>Meaning</th></tr>
</thead><tbody>
<tr><td>cylinder</td><td>cylinder</td></tr>
<tr><td>fisheye</td><td>fisheye</td></tr>
<tr><td>meshCamera</td><td>mesh_camera</td></tr>
<tr><td>omnimax</td><td>omnimax</td></tr>
<tr><td>orthographic</td><td>orthographic</td></tr>
<tr><td>panoramic</td><td>panoramic</td></tr>
<tr><td>perspective</td><td>perspective</td></tr>
<tr><td>spherical</td><td>spherical</td></tr>
<tr><td>ultraWideAngle</td><td>ultra_wide_angle</td></tr>
</tbody></table>
</td></tr>
<tr><td>RW</td><td>N</td><td>angle</td><td>float</td><td>Sets the width of the camera's viewing angle in degrees.</td></tr>
<tr><td>RW</td><td>N</td><td>aperture</td><td>float</td><td>A non-zero value will enable simulated focal depth-of-field.</td></tr>
<tr><td>RW</td><td>N</td><td>blurSamples</td><td>[float]</td><td>Specifies the minimum and maximum number of samples to be used when <code>aperture</code> is non-zero.</td></tr>
<tr><td>RW</td><td>N</td><td>bokeh</td><td>Color</td><td>Specifies the bokeh color.</td></tr>
<tr><td>RW</td><td>N</td><td>confidence</td><td>float</td><td>Specifies the confidence interval that determines when enough samples have been taken when <code>aperture</code> is non-zero.</td></tr>
<tr><td>RW</td><td>N</td><td>cylinderType</td><td>integer</td><td>If the cylinder camera type is used, <code>cyliderType</code> must be set with an integer in the range 1-4. These values correspond to 
<table class="sgrid codeDoc">
<thead>

<tr><th>Code</th><th>Meaning</th></tr>
</thead><tbody>
<tr><td>1</td><td>vertical cylinder, fixed viewpoint</td></tr>
<tr><td>2</td><td>horizontal cylinder, fixed viewpoint</td></tr>
<tr><td>3</td><td>vertical cylinder, viewpoint moves along the cylinder's axis</td></tr>
<tr><td>4</td><td>horizontal cylinder, viewpoint moves along the cylinder's axis</td></tr>
</tbody></table>
</td></tr>
<tr><td>RW</td><td>N</td><td>direction</td><td>VectorXYZ</td><td>Sets the direction vector of the camera before it is moved by <code>lookAt</code> and any rotations. For most purposes, you will not need to set <code>direction</code>, but see the POV-Ray docs for <a href="http://povray.org/documentation/3.7.0/r3_4.html#r3_4_2_1_4">more details</a>.</td></tr>
<tr><td>RW</td><td>N</td><td>focalPoint</td><td>VectorXYZ</td><td>Specifies the point at which the image is perfectly focused when <code>aperture</code> is non-zero.</td></tr>
<tr><td>RW</td><td>N</td><td>location</td><td>VectorXYZ</td><td>Specifies the location of the camera.</td></tr>
<tr><td>RW</td><td>N</td><td>lookAt</td><td>VectorXYZ</td><td>Specifies the point at which the camera is aimed.</td></tr>
<tr><td>RW</td><td>N</td><td>right</td><td>VectorXYZ</td><td>Along with <code>up</code>, the <code>right</code> vector determines how POV-Ray calculates the aspect ratio of the image. By default, it is <code>[1.33, 0, 0]</code>. The cylindrical and orthographic cameras have different behaviors, for which see the <a href="http://povray.org/documentation/3.7.0/r3_4.html#r3_4_2_1_5">POV-Ray docs</a>. It also determines the handedness of the coordinate system.</td></tr>
<tr><td>RW</td><td>N</td><td>sky</td><td>VectorXYZ</td><td>Determines where "up" is for the camera. By default, this is [0, 1, 0].</td></tr>
<tr><td>RW</td><td>N</td><td>up</td><td>VectorXYZ</td><td>Along with <code>right</code>, the <code>up</code> vector determines how POV-Ray calculates the aspect ratio of the image. By default, it is <code>[0, 1, 0]</code>. The cylindrical and orthographic cameras have different behaviors, for which see the <a href="http://povray.org/documentation/3.7.0/r3_4.html#r3_4_2_1_5">POV-Ray docs</a>.</td></tr>
<tr><td>RW</td><td>N</td><td>variance</td><td>float</td><td>When <code>aperture</code> is non-zero, <code>variance</code> tells POV-Ray the value of the smallest displayable color difference. The default, 0.0078125, can produce fairly grainy images. To fix this, try a value around 0.00001.</td></tr>
<tr><td>RW</td><td>N</td><td>vertAngle</td><td>float</td><td>For the spherical camera, this defines the vertical angle of the viewing area while <code>angle</code> specifies the horizontal angle.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Camera</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csgOperand</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV treats it as similar to one in many ways. For a <code>Camera</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Camera</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Camera</code>, this is always <code>false</code>.</td></td></tr>
</tbody></table>
</div dh="Camera">

<h5>Methods</h5>

<p>TODO</p>

<table class="illusBasic">
<tr><td colspan='2'><h4>Cone</h4></td></tr>
<tr><td>

<p>The <code>Cone</code> type is deceptively simple. At a minimum, you must
specify a <code>basePoint</code> and a <code>capPoint</code> along with their
respective radii. For the result to be a cone, one of the radii must be zero,
but non-zero values will produce a frustum, i.e., a truncated cone. You can also
remove the endcaps and create a hollow cone by setting <code>open</code> to
true. The example at right was created by the following code:</p>

<div class='code'>var obj = new Cone({
    basePoint: [0, -2, 0],
    baseRadius: 2,
    capPoint: [0, 2, 0],
    capRadius: 0
});</div>

</td><td>

    <img src="img/cone_basic.png">

</td></tr></table>


<h5>Attributes</h5>

<div dh="Cone">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>basePoint</td><td>VectorXYZ</td><td>Defines the location of the center of the cone's base end.</td></tr>
<tr><td>RW</td><td>Y</td><td>baseRadius</td><td>float</td><td>Defines the radius of the cone's base end.</td></tr>
<tr><td>RW</td><td>Y</td><td>capPoint</td><td>VectorXYZ</td><td>Defines the location of the center of the cone's cap end.</td></tr>
<tr><td>RW</td><td>Y</td><td>capRadius</td><td>float</td><td>Defines the radius of the cone's cap end. If this is non-zero, it technically ceases to be a cone and instead becomes a frustum.</td></tr>
<tr><td>RW</td><td>N</td><td>open</td><td>boolean</td><td>If <code>true</code>, the base and the cap are left open, yielding a hollow cone.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Cone</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csgOperand</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV treats it as similar to one in many ways. For a <code>Cone</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Cone</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Cone</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Cone">

<h4>Cubic</h4>

<p>A <code>Cubic</code> is a third-order polynomial surface. It has a single required
attribute like the rest of the polynomial types, <code>coefficients</code>, which is
an array of 20 floats.</p>

<h5>Attributes</h5>

<div dh="Cubic">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>coefficients</td><td>[float]</td><td>An array of 20 floats that act as the coefficients of a third-order polynomial.</td></tr>
<tr><td>RW</td><td>N</td><td>sturm</td><td>boolean</td><td>If <code>true</code>, POV-Ray will use the slower but more accurate Sturmian root solver. Use this if the surface exhibits holes or other imperfections.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Cubic</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csgOperand</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV treats it as similar to one in many ways. For a <code>Cubic</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Cubic</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Cubic</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Cubic">

<table class="illusBasic">
<tr><td colspan='2'><h4>Cylinder</h4></td></tr>
<tr><td>

<p>The <code>Cylinder</code> type produces a solid cylinder by default and
defined by the coordinates of the centers of its two circular ends,
<code>basePoint</code> and <code>capPoint</code>, plus the <code>radius</code>
of both. If the <code>open</code> attribute is true, the end caps are omitted
and the interior is hollow, leaving an infinitely thin tube.</p>

<p>If it is being used as a component in a <code>Blob</code>, the <code>strength</code>
attribute can be used to assign a field strength to the cylinder.</p>

<p>The following code produces the example at right:</p>

<div class='code'>var obj = new Cylinder({
    basePoint: [0, -2, 0],
    capPoint: [0, 2, 0],
    radius: 2,
});</div>

</td><td>

    <img src="img/cylinder_basic.png">

</td></tr></table>

<h5>Attributes</h5>

<div dh="Cylinder">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>basePoint</td><td>VectorXYZ</td><td>Defines the center of the base end of the cylinder.</td></tr>
<tr><td>RW</td><td>Y</td><td>capPoint</td><td>VectorXYZ</td><td>Defines the center of the cap end of the cylinder.</td></tr>
<tr><td>RW</td><td>Y</td><td>radius</td><td>float</td><td>Defines the radius of the cylinder.</td></tr>
<tr><td>RW</td><td>N</td><td>open</td><td>boolean</td><td>If <code>true</code>, the cap and base planes are are eliminating, yielding a hollow tube.</td></tr>
<tr><td>RW</td><td>N</td><td>strength</td><td>float</td><td>Defines the field strength of the cylinder. This is only used when the cylinder is a component of a <code>Blob</code> object.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Cylinder</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csgOperand</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV treats it as similar to one in many ways. For a <code>Cylinder</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Cylinder</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Cylinder</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Cylinder">

<table class="illusBasic">
<tr><td colspan='2'><h4>Difference</h4></td></tr>
<tr><td>

<p>The <code>Difference</code> type is one of the four CSG operations. It has
two required attributes. The <code>positiveComponent</code> is a single object
(which may be another composite CSG object) from which the array of objects in
<code>negativeComponents</code> is subtracted. In this case, one sphere has been
subtracted from another, producing a sphere with a dish-shaped depression in one
side.</p>

<div class='code'>var obj1 = new Sphere({ center: [1,0,-2], radius: 1.5 });
var obj2 = new Sphere({ center: [3,0,-1], radius: 1.5 });
var diff = new Difference({
    positiveComponent: obj1,
    negativeComponents: [obj2]
});</div>

</td><td>

    <img src="img/difference_basic.png">

</td></tr></table>

<h5>Attributes</h5>

<div dh="Difference">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>negativeComponents</td><td>Array</td><td>This is an array of objects to subtract from the <code>positiveComponent</code>.</td></tr>
<tr><td>RW</td><td>Y</td><td>positiveComponent</td><td>Primitive</td><td>This is the single base object from which the object(s) in the <code>negativeComponents</code> array are subtracted.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Difference</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Difference</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Difference</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Difference">

<table class="illusBasic">
<tr><td colspan='2'><h4>Disc</h4></td></tr>
<tr><td>

<p>The <code>Disc</code> type is a two-dimensional circular disc defined by its
<code>center</code>, <code>radius</code>, and <code>normal</code>. As in the
example below, it is possible to turn it into a washer-like ring by specifying a
non-zero <code>holeRadius</code>.</p>

<div class='code'>var obj = new Disc({
    center: [0, 0, 0],
    radius: 2,
    holeRadius: 1,
    normal: [0, 1, 0]
});</div>

</td><td>

    <img src="img/disc_basic.png">

</td></tr></table>

<h5>Attributes</h5>

<div dh="Disc">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>center</td><td>VectorXYZ</td><td>This is the center point of the disc.</td></tr>
<tr><td>RW</td><td>Y</td><td>normal</td><td>VectorXYZ</td><td>This defines the normal or orientation of the disc in space.</td></tr>
<tr><td>RW</td><td>Y</td><td>radius</td><td>float</td><td>Defines the radius of the disc.</td></tr>
<tr><td>RW</td><td>N</td><td>holeRadius</td><td>float</td><td>If supplied and non-zero, defines the radius of the hole in the center of the disc.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Disc</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csgOperand</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV treats it as similar to one in many ways. For a <code>Disc</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Disc</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Disc</code>, this is always <code>false</code>.</td></td></tr>
</tbody></table>
</div dh="Disc">

<table class="illusBasic">
<tr><td colspan='2'><h4>HeightField</h4></td></tr>
<tr><td>

<p>A <code>HeightField</code> takes a bitmapped graphics file and converts it into a triangle mesh in which the height
of each point is determined by either the intensity of the corresponding pixel or, for indexed graphics, its index number.
It is frequently used for creating landscapes.</p>

<p>The resulting mesh fits into a unit cube. The optional <code>waterLevel</code> attribute, set to a value in the unit
interval (0.0 - 1.0), progressively hides a portion of the mesh to simulate water. (It does not provide a water plane; you
will have to do that yourself.) A <code>waterLevel</code> value of 0.0 reveals the entire mesh, while a value of 1.0 hides all of it;
intermediate values hide only part of it.</p>

<p>For complete details on the graphics formats accepted, see the <a
href="http://www.povray.org/documentation/3.7.0/r3_4.html#r3_4_5_1_5">POV-Ray
documentation</a>. The example here uses a 16-bit greyscale PNG file.</p>

<div class='code'>	var obj = new HeightField({
    source: "hf_demo.png",
    waterLevel: 0.4,
    smooth: true,
    texture: yellow
});
var xform = new Matrix("translate", -0.5, -0.5, -0.5);
obj.transform = xform.xMatrix(new Matrix("scale", 6, 3, 6));</div>

</td><td>

    <img src="img/heightfield_basic.png">

</td></tr></table>

<h5>Attributes</h5>

<div dh="HeightField">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>source</td><td>SDL<br/>string</td><td>Defines the source of the points that comprise the height field. This may be either an SDL function or the path to a graphics file.</td></tr>
<tr><td>RW</td><td>N</td><td>gamma</td><td>float<br/>string</td><td>Defines the gamma value to be used in interpreting an image file. This may be either a float or the string <code>"sRGB"</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>hfType</td><td>string</td><td>If <code>source</code> is a graphics file, the <code>hfType</code> attribute declares the file format, which must be one of <code>"exr"</code>, <code>"gif"</code>, <code>"hdr"</code>, <code>"iff"</code>, <code>"jpeg"</code>, <code>"pgm"</code>, <code>"png"</code>, <code>"pot"</code>, <code>"ppm"</code>, <code>"sys"</code>, <code>"tga"</code>, and <code>"tiff"</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>hierarchy</td><td>boolean</td><td>If <code>false</code>, turn off the internal bounding hierarchy.</td></tr>
<tr><td>RW</td><td>N</td><td>premultiplied</td><td>boolean</td><td>Specifies whether the file is stored in premultiplied associated or non-premultiplied straight alpha format, overriding the file format specific default. This keyword has no effect on files without an alpha channel.</td></tr>
<tr><td>RW</td><td>N</td><td>smooth</td><td>boolean</td><td>If <code>true</code>, POV-Ray will manipulate the surface normals of the generated triangles to create a smoother-looking surface.</td></tr>
<tr><td>RW</td><td>N</td><td>waterLevel</td><td>float</td><td>Defines the point below which the height field is hidden. This defaults to 0.0, which corresponds to the bottom of the height field, i.e., nothing is hidden. At the other extreme, 1.0 will cause the entire height field to be hidden. Note that this does not create a plane representing water; you'll have to do that manually.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>HeightField</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csgOperand</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV treats it as similar to one in many ways. For a <code>HeightField</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>HeightField</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>HeightField</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="HeightField">

<table class="illusBasic">
<tr><td colspan='2'><h4>Intersection</h4></td></tr>
<tr><td>

<p>The <code>Intersection</code> type is one of the four CSG operations. Like
all of the CSG operations other than <code>Difference</code>, it has a single
mandatory attribute, <code>components</code>, which is an array of objects. The
result is their set-theoretical intersection, i.e., the space in which all of
the components overlap.</p>

<p>In the example, we have taken the intersection of two overlapping spheres,
yielding an object shaped like the lens of a magnifying glass.</p>

<div class='code'>var obj1 = new Sphere({ center: [1,0,-2], radius: 1.5 });
var obj2 = new Sphere({ center: [3,0,-1], radius: 1.5 });
var intersection = new Intersection({ components: [ obj1, obj2 ] });</div>

</td><td>

    <img src="img/intersection_basic.png">

</td></tr></table>

<h5>Attributes</h5>

<div dh="Intersection">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>components</td><td>[Primitive]</td><td>An array of objects whose intersection will produce the resulting object.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Intersection</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Intersection</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Intersection</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Intersection">

<table class="illusBasic">
<tr><td colspan='2'><h4>IsoSurface</h4></td></tr>
<tr><td>

<p>Short of the dubious goal of writing a JavaScript-to-SDL compiler, complete
independence from POV-Ray's Scene Description Language is not possible in a few
cases. The <code>IsoSurface</code> object is one of these because its sole
required attribute, <code>source</code>, is a function or functions written in
SDL. It's worth the effort of understanding, however, because the definition of
isosurfaces is one of POV-Ray's most powerful features. For complete details, see the
<a href="http://www.povray.org/documentation/3.7.0/r3_4.html#r3_4_5_1_6">POV-Ray docs</a>.</p>

<p>In this example, we're just grabbing an example from the POV-Ray docs to serve
as the <code>source</code> attribute. Don't forget to include the leading <code>'&'</code>
that tells CephaloPOV that it's getting SDL code instead of an ordinary string.</p>

<div class='code'>var obj = new IsoSurface({
    source: "&function{fn_A(x,y,z) + "
        + "pow(Blob_Threshold,(fn_B(x,y,z) + Strength))}"
});</div>

</td><td>

    <img src="img/isosurface_basic.png">

</td></tr></table>

<h5>Attributes</h5>

<div dh="IsoSurface">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>source</td><td>SDL</td><td>This is a string containing the SDL function code which defines the surface.</td></tr>
<tr><td>RW</td><td>N</td><td>accuracy</td><td>float</td><td>Defines the amount of subdivision POV-Ray performs to find the surface, with lower values being more accurate. Defaults to 0.001.</td></tr>
<tr><td>RW</td><td>N</td><td>containedBy</td><td>Sphere<br/>Box</td><td>Defines a <code>Sphere</code> or <code>Box</code> which determines the portion of the (potentially infinite) surface that POV-Ray will render. By default, this is a <code>Box</code> with corners at <code>[1, 1, 1]</code> and <code>[-1, -1, -1]</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>evaluate</td><td>[float]</td><td>This is an array of three floats that optionally guides POV-Ray in dynamically adapting <code>maxGradient</code>. See the official POV-Ray documentation for <a href="specifies whether the file is stored in premultiplied associated or non-premultiplied straight alpha format, overriding the file format specific default. This keyword has no effect on files without an alpha channel.">details.</a></td></tr>
<tr><td>RW</td><td>N</td><td>maxGradient</td><td>float</td><td>Rendering will be faster if POV-Ray knows the maximum gradient of the <code>source</code> function. The <code>maxGradient</code> value defaults to 1.1, but if this too low, holes and other imperfections may appear, and POV-Ray will emit a warning telling you the maximum gradient it found so that you can manually update this value. Beware of raising the value beyond the actual maximum gradient, as this will slow down the render.</td></tr>
<tr><td>RW</td><td>N</td><td>maxTrace</td><td>integer<br/>string</td><td>When used as part of a CSG object, this determines the maximum number of surfaces to look for when constructing the final CSG object. By default, only the <code>containedBy</code> object is examined. For complete accuracy at the expense of speed, use the string <code>"all_intersections".</td></tr>
<tr><td>RW</td><td>N</td><td>open</td><td>boolean</td><td>If <code>true</cope>, the boundaries where the isosurface intersects with the <code>containedBy</code> object will be left open.</td></tr>
<tr><td>RW</td><td>N</td><td>threshold</td><td>float</td><td>The surface appears where the value of <code>source</code> equals this value, which defaults to 0.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>IsoSurface</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csgOperand</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV treats it as similar to one in many ways. For a <code>IsoSurface</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>IsoSurface</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>IsoSurface</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="IsoSurface">

<table class="illusBasic">
<tr><td colspan='2'><h4>JuliaFractal</h4></td></tr>
<tr><td>

<p>The <code>JuliaFractal</code> is a three-dimensional slice of a
four-dimensional Julia fractal set. See the <a
href="http://www.povray.org/documentation/3.7.0/r3_4.html#r3_4_5_1_7">POV-Ray
docs</a> for a little more detail. The CephaloPOV interface follows the POV-Ray
model quite closely, the major difference being that POV-Ray's anonymous algebra
type and function type parameters are combined in <code>type</code>.</p>

<div class='code'>var obj = new JuliaFractal({
    juliaParam: [-0.083, 0.0, -0.83, -0.025],
    type: "quaternion:sqr",
    maxIter: 8,
    precision: 15
});</div>

</td><td class='infinite'>

    <img src="img/julia_basic.png">

</td></tr></table>

<h5>Attributes</h5>

<div dh="JuliaFractal">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>juliaParam</td><td>VectorXYZW</td><td>This is the standard julia parameter, <i>p</i>, in <i>f(h) + p</i>.</td></tr>
<tr><td>RW</td><td>Y</td><td>type</td><td>string</td><td>Specifies the type of julia fractal formula used. The legal values are: 
<table class="sgrid codeDoc">
<thead>
<tr><th>Julia Fractal Types</th></tr>
</thead><tbody>
<tr><td><code>hypercomplex:acos</code></td></tr>
<tr><td><code>hypercomplex:acosh</code></td></tr>
<tr><td><code>hypercomplex:asin</code></td></tr>
<tr><td><code>hypercomplex:atan</code></td></tr>
<tr><td><code>hypercomplex:atanh</code></td></tr>
<tr><td><code>hypercomplex:cos</code></td></tr>
<tr><td><code>hypercomplex:cosh</code></td></tr>
<tr><td><code>hypercomplex:cube</code></td></tr>
<tr><td><code>hypercomplex:exp</code></td></tr>
<tr><td><code>hypercomplex:ln</code></td></tr>
<tr><td><code>hypercomplex:pwr</code></td></tr>
<tr><td><code>hypercomplex:reciprocal</code></td></tr>
<tr><td><code>hypercomplex:sin</code></td></tr>
<tr><td><code>hypercomplex:sinh</code></td></tr>
<tr><td><code>hypercomplex:sqr</code></td></tr>
<tr><td><code>hypercomplex:tan</code></td></tr>
<tr><td><code>hypercomplex:tanh</code></td></tr>
<tr><td><code>quaternion:cube</code></td></tr>
<tr><td><code>quaternion:sqr</code></td></tr>
</tbody></table>
</td></tr>
<tr><td>RW</td><td>N</td><td>distance</td><td>float</td><td>Specifies the distance of the <code>slice</code> from the origin. Defaults to 0.</td></tr>
<tr><td>RW</td><td>N</td><td>maxIter</td><td>integer</td><td>Determines the number of iterations used to find the surface of the fractal, with higher values being more accurate but slower to render. The default is 20.</td></tr>
<tr><td>RW</td><td>N</td><td>power</td><td>VectorXY</td><td>For the <code>hypercomplex:pwr</code> formula, this <code>VectorXY</code> contains the X and Y exponents used in the calculations. Has no effect on other formula types.</td></tr>
<tr><td>RW</td><td>N</td><td>precision</td><td>integer</td><td>Determines the accuracy of the calculations for finding the surface of the julia set. The default is 20. Higher values result in greater accuracy but longer rendering times.</td></tr>
<tr><td>RW</td><td>N</td><td>slice</td><td>VectorXYZW</td><td>Specifies the 3D slice through 4D space used to view the fractal. Defaults to <code>[0, 0, 0, 1]</code>.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>JuliaFractal</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csgOperand</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV treats it as similar to one in many ways. For a <code>JuliaFractal</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>JuliaFractal</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>JuliaFractal</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="JuliaFractal">

<table class="illusBasic">
<tr><td colspan='2'><h4>Lathe</h4></td></tr>
<tr><td>

<p>The <code>Lathe</code> object is a surface of revolution created by sweeping
a spline around the y-axis, centered at the origin. The resulting object is
solid, but the spline will not produce a closed curve unless the first and last
points are the same.</p>

<p>A <code>Lathe</code> is much more flexible than the other surface of revolution
object, <code>Sor</code>, but it is also substantially slower to render.</p>

<div class='code'>var obj = new Lathe({
    points: [
        [0, -1.2],
        [1, -1.2],
        [1, -0.8],
        [0.8, -0.6],
        [0.8, -0.4],
        [1, -0.4],
        [1, -0.2],
        [0.8, -0.2],
        [0.8, 0],
        [1, 0],
        [1, 0.2],
        [0.8, 0.2],
        [0.6, 0.8],
        [0.6, 1.2],
        [0.8, 1.2],
        [0.8, 1.4],
        [0, 1.4]
    ],
    type: "linearSpline"
});</div>

</td><td class='infinite'>

    <img src="img/lathe_basic.png">

</td></tr></table>

<h5>Attributes</h5>

<div dh="Lathe">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>points</td><td>VectorXY</td><td>An array of points defining the spline. Linear splines require at least two points, quadratic splines require at least three, and cubic and bezier splines require at least four.</td></tr>
<tr><td>RW</td><td>Y</td><td>type</td><td>string</td><td>Determines the type of spline used to define the profile. Legal types are <code>"bezierSpline"</code>, <code>"cubicSpline"</code>, <code>"linearSpline"</code>, and <code>"quadraticSpline"</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>sturm</td><td>boolean</td><td>If <code>true</code>, POV-Ray will use the slower but more accurate Sturmian root solver. Use this if the surface exhibits holes or other imperfections.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Lathe</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csgOperand</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV treats it as similar to one in many ways. For a <code>Lathe</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Lathe</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Lathe</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Lathe">

<h4>LightSource</h4>

<p>TODO</p>

<h5>Attributes</h5>

<div dh="LightSource">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>color</td><td>Color</td><td>Specifies the color of the light source.</td></tr>
<tr><td>RW</td><td>Y</td><td>location</td><td>VectorXYZ</td><td>Specifies the location of the light source.</td></tr>
<tr><td>RW</td><td>Y</td><td>type</td><td>string</td><td>Determines the type of the light. The legal values are <code>"cylinder"</code>, <code>"point"</code>, and <code>"spotlight"</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>adaptive</td><td>float</td><td>Used with area lights. If defind, POV-Ray will use adaptive sampling in an attempt to speed up rendering. Higher values are more accurate.</td></tr>
<tr><td>RW</td><td>N</td><td>areaIllumination</td><td>boolean</td><td>If <code>true</code>, the experimental support in POV-Ray 3.7 for full area light diffuse and specular illumination is enabled.</td></tr>
<tr><td>RW</td><td>N</td><td>areaLight</td><td>boolean</td><td>If <code>true</code>, the light becomes an area light, and <code>axis1</code>, <code>axis2</code>, <code>size1</code>, and <code>size2</code> must be defined.</td></tr>
<tr><td>RW</td><td>N</td><td>axis1</td><td>VectorXYZ</td><td>When <code>areaLight</code> is <code>true</code>, <code>axis1</code> defines the orientation of the area light along one axis.</td></tr>
<tr><td>RW</td><td>N</td><td>axis2</td><td>VectorXYZ</td><td>When <code>areaLight</code> is <code>true</code>, <code>axis2</code> defines the orientation of the area light along one axis.</td></tr>
<tr><td>RW</td><td>N</td><td>circular</td><td>boolean</td><td>Used with area lights. If <code>true</code>, the default rectilinear grid is modified to approximate a circle or ellipse.</td></tr>
<tr><td>RW</td><td>N</td><td>fadeDistance</td><td>float</td><td>Defines the distance at which the light will be at full intensity.</td></tr>
<tr><td>RW</td><td>N</td><td>fadePower</td><td>float</td><td>Defines the rate at which light intensity decreases with distance beyond <code>fadeDistance</code>. A value of 1 is linear, 2 is quadratic, and so on.</td></tr>
<tr><td>RW</td><td>N</td><td>falloff</td><td>float</td><td>If specified, <code>falloff</code> describes a larger cone than <code>radius</code> within which the light fades from its original intensity to nothing. Note that this will still cast sharp shadows.</td></tr>
<tr><td>RW</td><td>N</td><td>jitter</td><td>boolean</td><td>Used with area lights. If <code>true</code>, the positions of the lights are randomly moved during rendering so that banding effects are minimized. Should not be used with animations.</td></tr>
<tr><td>RW</td><td>N</td><td>looksLike</td><td>Primitive</td><td>Assigns an object (with an implicit <code>noShadow</code> flag) to act as the physical source of the light.</td></tr>
<tr><td>RW</td><td>N</td><td>mediaAttenuation</td><td>boolean</td><td>If <code>true</code>, the light will be attenuated by passing through media. The default is <code>false</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>mediaInteraction</td><td>boolean</td><td>If <code>true</code> (the default), the light will interact with media.</td></tr>
<tr><td>RW</td><td>N</td><td>orient</td><td>boolean</td><td>Used with area lights, and causes the array of lights to be oriented toward every surface being tested. The <code>orient</code> flag can only be used along with <code>circular</code> when both axes are of equal length and use an equal number of samples.</td></tr>
<tr><td>RW</td><td>N</td><td>parallel</td><td>boolean</td><td>If <code>true</code>, all of the light rays will be parallel to the line between <code>location</code> and <code>pointAt</code>. This is useful for simulating very distant light sources like the sun, but be aware that shadows cease to work behind the light plane.</td></tr>
<tr><td>RW</td><td>N</td><td>pointAt</td><td>VectorXYZ</td><td>Specifies the point the spotlight is aimed at.</td></tr>
<tr><td>RW</td><td>N</td><td>projectedThrough</td><td>Primitive</td><td>Specifies an object through which the light rays must pass in order to be visible.</td></tr>
<tr><td>RW</td><td>N</td><td>radius</td><td>float</td><td>Specifies the angle of the cone of light produced by a spotlight.</td></tr>
<tr><td>RW</td><td>N</td><td>shadowless</td><td>boolean</td><td>If <code>true</code>, the light will neither cast shadows nor cause highlights.</td></tr>
<tr><td>RW</td><td>N</td><td>size1</td><td>float</td><td>When <code>areaLight</code> is <code>true</code>, <code>size1</code> defines the number of rows of lights.</td></tr>
<tr><td>RW</td><td>N</td><td>size2</td><td>float</td><td>When <code>areaLight</code> is <code>true</code>, <code>size2</code> defines the number of columns of lights.</td></tr>
<tr><td>RW</td><td>N</td><td>tightness</td><td>float</td><td>The <code>tightness</code> attribute is a number between 0 and 100 that modifies the relationship between <code>radius</code> and <code>falloff</code>. Counterintuitively, lower values produce a sharper, brighter spotlight and higher values produce a dimmer, softer spotlight. To exercise complete control over the spotlight with <code>tightness</code> alone, set <code>radius = 0</code> and <code>falloff = 90</code>.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>LightSource</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csgOperand</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV treats it as similar to one in many ways. For a <code>LightSource</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>LightSource</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>LightSource</code>, this is always <code>false</code>.</td></td></tr>
</tbody></table>
</div dh="LightSource">

<table class="illusBasic">
<tr><td colspan='2'><h4>Merge</h4></td></tr>
<tr><td>

<p>The <code>Merge</code> type is one of the four CSG operations. Like all of
the CSG operations other than <code>Difference</code>, it has a single mandatory
attribute, <code>components</code>, which is an array of objects. The result is
their set-theoretical union, which is different from the original ad hoc
collection of objects in that it can be treated as a single object and
tranformed and textured as a whole, as well as participating in further CSG
operations.</p>

<p>A <code>Merge</code> differs from the otherwise identical <code>Union</code>
by eliminating the hidden inner surfaces. This doesn't matter with opaque
objects, of course, but it is often useful when creating transparent or
translucent objects.</p>

<p>In the example, we have merged two spheres, resulting in a single object
that looks, um, exactly like two spheres.</p>

<div class='code'>var obj1 = new Sphere({ center: [1,0,-2], radius: 1.5 });
var obj2 = new Sphere({ center: [3,0,-1], radius: 1.5 });
var merge = new Merge({ components: [ obj1, obj2 ] });</div>

</td><td>

    <img src="img/merge_basic.png">

</td></tr></table>

<h5>Attributes</h5>

<div dh="Merge">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>components</td><td>Array</td><td>An array of objects to merge.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Merge</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Merge</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Merge</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Merge">

<table class="illusBasic">
<tr><td colspan='2'><h4>Mesh</h4></td></tr>
<tr><td>

<p>TODO</p>

<div class='code'>var obj = new PlaceholderObj({
    // TODO
});</div>

</td><td>

    <img src="img/placeholder_basic.png">

</td></tr></table>

<h5>Attributes</h5>

<div dh="Mesh">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>triangles</td><td>[Triangle]</td><td>The array of <code>Triangle</code>s comprising the mesh.</td></tr>
<tr><td>RW</td><td>N</td><td>hierarchy</td><td>boolean</td><td>If <code>false</code>, turn off the internal bounding hierarchy.</td></tr>
<tr><td>RW</td><td>N</td><td>insideVector</td><td>VectorXYZ</td><td>For the <code>Mesh</code> to be solid, it must be completely closed and have a defined <code>insideVector</code>.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Mesh</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csgOperand</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV treats it as similar to one in many ways. For a <code>Mesh</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Mesh</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Mesh</code>, this is always <code>false</code>.</td></td></tr>
</tbody></table>
</div dh="Mesh">

<table class="illusBasic">
<tr><td colspan='2'><h4>Ovus</h4></td></tr>
<tr><td>

<p>The <code>Ovus</code> type is one of POV-Ray's more interesting and versatile
geometric primitives. It consists of two spheres defined by
<code>bottomRadius</code> and <code>topRadius</code> such that the center of the
top sphere is positioned on the top of the bottom sphere, and then a smooth
curved surface connects the two. The center of the bottom sphere is at the
origin, and the centers of both spheres are aligned along the y-axis.</p>

<p>In the example code below, the result is the egg-like shape to the right, but
a wide variety of other shapes can be constructed with it.</p>

<div class='code'>var obj = new Ovus({
    bottomRadius: 2,
    topRadius: 1
});</div>

</td><td>

    <img src="img/ovus_basic.png">

</td></tr></table>

<h5>Attributes</h5>

<div dh="Ovus">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>bottomRadius</td><td>float</td><td>Sets the radius of the bottom sphere.</td></tr>
<tr><td>RW</td><td>Y</td><td>topRadius</td><td>float</td><td>Sets the radius of the top sphere.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Ovus</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csgOperand</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV treats it as similar to one in many ways. For a <code>Ovus</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Ovus</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Ovus</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Ovus">

<table class="illusBasic">
<tr><td colspan='2'><h4>Parametric</h4></td></tr>
<tr><td>

<p>Along with <code>IsoSurface</code>, the <code>Parametric</code> type is one of the
places where CephaloPOV cannot shield you from the POV-Ray Scene Description Language, or
at least a subset of it. However, also like <code>IsoSurface</code>, the <code>Parametric</code>
type is one of POV-Ray's most powerful features, so it's well worth the effort of understanding
the <a href="http://www.povray.org/documentation/3.7.0/r3_4.html#r3_4_5_1_10">POV-Ray docs</a> and a
few online <a href="http://www.f-lohmueller.de/pov_tut/all_shapes/shapes570e.htm">tutorials</a> unless you're
especially math-averse. (And if so, do you know where you are?)</p>

<p>The short version is that <code>Parametric</code> objects are hollow surfaces defined by three functions
that map the UV-plane to explicit <i>xyz</i>-coordinates whereas <code>IsoSurface</code> objects are solid and
have surfaces implicitly defined by a single function yielding a potential field. Ergo, in place of the single <code>source</code>
attribute of the <code>IsoSurface</code>, a <code>Parametric</code> has an attribute for each of the three
axes, <code>funcX</code>, <code>funcY</code>, and <code>funcZ</code>.</p>

<div class='code'>var p2 = 2 * Math.PI;

var obj = new Parametric({
    funcX: "&function { 1.0 * (1 - 0.5 * v / pi) "
        + "* sin(5 * v + 0.5 *pi) "
        + "* (1 - cos(u)) + 0.2 * sin(5 * v + 0.5 * pi) }",
    funcY: "&function { 8 * 0.5 * v / pi + 1.0 "
        + "* (1 - 0.5 * v / pi) * sin(u) }",
    funcZ: "&function { 1.0 * (1 - 0.5 * v / pi) "
        + "* cos(5 * v + 0.5 * pi) "
        + * (1 - cos(u)) + 0.2 * cos(5 * v + 0.5 * pi) }",
    uv1: [0, 0],
    uv2: [p2, p2],
    accuracy: 0.0035,
    precomputeDepth: 18,
    precomputeX: true,
    precomputeY: true,
    precomputeZ: true,
    maxGradient: 10,
    containedBy: new Box({
        corner1: [-p2, -p2, -p2],
        corner2: [p2, 8/3 *p2, p2],
    }),
});
obj.transform = new Matrix("scale", 0.4, 0.4, 0.4);
obj.transform = new Matrix("rotate", 0, 90, 0);</div>

</td><td>

    <img src="img/parametric_basic.png">

</td></tr></table>

<h5>Attributes</h5>

<div dh="Parametric">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>funcX</td><td>SDL</td><td>Determines the X coordinate of the surface.</td></tr>
<tr><td>RW</td><td>Y</td><td>funcY</td><td>SDL</td><td>Determines the Y coordinate of the surface.</td></tr>
<tr><td>RW</td><td>Y</td><td>funcZ</td><td>SDL</td><td>Determines the Z coordinate of the surface.</td></tr>
<tr><td>RW</td><td>Y</td><td>uv1</td><td>VectorUV</td><td>Specifies one corner of the UV plane to which the surface is mapped.</td></tr>
<tr><td>RW</td><td>Y</td><td>uv2</td><td>VectorUV</td><td>Specifies the other corner of the UV plane to which the surface is mapped.</td></tr>
<tr><td>RW</td><td>N</td><td>accuracy</td><td>float</td><td>Defines the amount of subdivision POV-Ray performs to find the surface, with lower values being more accurate. Defaults to 0.001.</td></tr>
<tr><td>RW</td><td>N</td><td>containedBy</td><td>Sphere<br/>Box</td><td>Defines a <code>Sphere</code> or <code>Box</code> which determines the portion of the (potentially infinite) surface that POV-Ray will render. By default, this is a <code>Box</code> with corners at <code>[1, 1, 1]</code> and <code>[-1, -1, -1]</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>maxGradient</td><td>float</td><td>Rendering will be faster if POV-Ray knows the maximum gradient of the surface functions. The <code>maxGradient</code> value defaults to 1.1, but if this too low, holes and other imperfections may appear, and POV-Ray will emit a warning telling you the maximum gradient it found so that you can manually update this value. Beware of raising the value beyond the actual maximum gradient, as this will slow down the render.</td></tr>
<tr><td>RW</td><td>N</td><td>precomputeDepth</td><td>integer</td><td>If defined, <code>precomputeDepth</code> can speed up rendering at the expense of memory. The maximum value is 20. At least one of <code>precomputeX</code>, <code>precomputeY</code>, or <code>precomputeZ</code> must be <code>true</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>precomputeX</td><td>boolean</td><td>Enables precalculation of the X coordinate during subdivision of parametric surfaces. <code>precomputeDepth</code> must also be defined.</td></tr>
<tr><td>RW</td><td>N</td><td>precomputeY</td><td>boolean</td><td>Enables precalculation of the Y coordinate during subdivision of parametric surfaces. <code>precomputeDepth</code> must also be defined.</td></tr>
<tr><td>RW</td><td>N</td><td>precomputeZ</td><td>boolean</td><td>Enables precalculation of the Z coordinate during subdivision of parametric surfaces. <code>precomputeDepth</code> must also be defined.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Parametric</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csgOperand</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV treats it as similar to one in many ways. For a <code>Parametric</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Parametric</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Parametric</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Parametric">

<table class="illusBasic">
<tr><td colspan='2'><h4>Plane</h4></td></tr>
<tr><td>

<p>Arguably POV-Ray's simplest primitive, the <code>Plane</code> is an infinite
solid dividing all space into two halves. It is defined by a
<code>distance</code> from the origin and a <code>normal</code> which determines
the orientation of its surface. It provides a convenient infinite ground plane,
of course, but because it creates a solid half-surface, you can use a CSG
<code>Intersection</code> of planes to create complex shapes like solid
polyhedra.</p>

<p>In the example below, the plane is oriented perpendicularly to the y-axis at
the origin. Its infinite extent is amusingly clear in the rendering to the
right, where our standard demonstration stage looks like it has been caught in a
flood!</p>

<div class='code'>var obj = new Plane({
    distance: 0,
    normal: [0, 1, 0]
});</div>

</td><td class='infinite'>

    <img src="img/plane_basic.png">

</td></tr></table>

<h5>Attributes</h5>

<div dh="Plane">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>distance</td><td>float</td><td>Specifies the distance the plane lies from the origin along the <code>normal</code> vector. This is multiplied by the normal, so if <code>distance</code> is 2 and <code>normal</code> is <code>[0, 2, 0]</code>, the plane will lie 4 units from the origin.</td></tr>
<tr><td>RW</td><td>Y</td><td>normal</td><td>VectorXYZ</td><td>Defines the surface normal of the plane, i.e., a vector that points up perpendicularly from the surface of the plane.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Plane</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csgOperand</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV treats it as similar to one in many ways. For a <code>Plane</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Plane</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Plane</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Plane">

<table class="illusBasic">
<tr><td colspan='2'><h4>Poly</h4></td></tr>
<tr><td>

<p>The <code>Poly</code> type offers a generic interface to create polynomial
surfaces of orders 2 to 35. You must specify the <code>order</code> of the
polynomial and then supply its <code>coefficients</code>, the number of which
depends on the order:</p>

<div class='code'>n = ((order + 1) * (order + 2) * (order + 3)) / 6;</div>

<p>(CephaloPOV will helpfully throw a fatal error if you get the number of
coefficients wrong.)</p>

<p>The example below, adapted from POV-Ray's <code>shapesq.inc</code> file, is a
variant of a lemniscate.</p>

<div class='code'>var obj = new Poly({
    order: 6,
    coefficients: [
         4, 0, 0, 0, 0, 0, 0, 0, 0, -4,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         1, 0, 0, 0, 0, 0, 0, 0, 0, 0,
         0, 1, 0, 0
    ],
    texture: yellow
});
obj.transform = new Matrix("scale", 2, 2, 2);</div>

</td><td>

    <img src="img/poly_basic.png">

</td></tr></table>

<h5>Attributes</h5>

<div dh="Poly">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>coefficients</td><td>[float]</td><td>An array defining the coefficients of the polynomial. The number of coefficients required is equal to ((<code>order</code> + 1) * (<code>order</code> + 2) * (<code>order</code> + 3)) / 6.</td></tr>
<tr><td>RW</td><td>Y</td><td>order</td><td>integer</td><td>Specifies the order of the polynomial. Must be in the range 2 to 35.</td></tr>
<tr><td>RW</td><td>N</td><td>sturm</td><td>boolean</td><td>If <code>true</code>, POV-Ray will use the slower but more accurate Sturmian root solver. Use this if the surface exhibits holes or other imperfections.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Poly</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csgOperand</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV treats it as similar to one in many ways. For a <code>Poly</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Poly</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Poly</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Poly">

<table class="illusBasic">
<tr><td colspan='2'><h4>Polygon</h4></td></tr>
<tr><td>

<p>Another versatile two-dimensional primitive, the <code>Polygon</code> type is
defined by it's sole <code>points</code> parameter, which is an array of
<code>VectorXY</code> points listing the vertices of an arbitrary polygon on the
XY-plane. For a simple polygon, a line will automatically connect the first
and last points. If the first point of the polygon is repeated, subsequent points
create an additional polygon which, if it is enclosed in the first (or another) polygon,
defines a hole in it.</p>

<p>In the example code below, two rectangles are defined with the second being a hole
in the first.</p>

<div class='code'>var obj = new Polygon({
    points: [[-2, 2], [2, 2], [2, -2], [-2, -2], [-2, 2],
        [-1, 1], [1, 1], [1, -1], [-1, -1], [-1, 1]],
});</div>

</td><td class='infinite'>

    <img src="img/polygon_basic.png">

</td></tr></table>

<h5>Attributes</h5>

<div dh="Polygon">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>points</td><td>[VectorXY]</td><td>This is an array of at least three <code>VectorXY</code> objects defining the vertices of the polygon.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Polygon</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csgOperand</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV treats it as similar to one in many ways. For a <code>Polygon</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Polygon</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Polygon</code>, this is always <code>false</code>.</td></td></tr>
</tbody></table>
</div dh="Polygon">

<table class="illusBasic">
<tr><td colspan='2'><h4>Polynomial</h4></td></tr>
<tr><td>

<p>The <code>Polynomial</code> type is another arbitrary polynomial shape object
that provides an alternative to the <code>Poly</code> type, and like it, it must
have an <code>order</code> in the range 2&ndash;35. The coefficients are encoded
in an array of <code>VectorXYZW</code> where the <code>x</code>, <code>y</code>,
and <code>z</code> attributes signify the powers of the respective
indeterminates and <code>w</code> is repurposed to contain the coefficient.</p>

<p>As noted in the description of <code>Poly</code>, the order determines the
number of coefficients thus:</p>

<div class='code'>n = ((order + 1) * (order + 2) * (order + 3)) / 6;</div>

<p>In the example shown, a sphere is produced by a second-order polynomial.</p>

<div class='code'>var obj = new Polynomial({
    order: 2,
    coefficients: [
        [2, 0, 0,  1],
        [0, 2, 0,  1],
        [0, 0, 2,  1],
        [0, 0, 0, -1]
    ]
});</div>

</td><td>

    <img src="img/polynomial_basic.png">

</td></tr></table>

<h5>Attributes</h5>

<div dh="Polynomial">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>coefficients</td><td>[VectorXYZW]</td><td>An array of <code>VectorXYZW</code> defining the coefficients of the polynomial. The choice of <code>VectorXYZW</code> is a bit of a convenience hack as it doesn't encode a 4D cartesian point. Instead, the X, Y, and Z values specify the corresponding powers of the coefficient and W specifies the value. The members of the array can be specified in any order.</td></tr>
<tr><td>RW</td><td>Y</td><td>order</td><td>integer</td><td>Specifies the order of the polynomial. Must be in the range 2 to 35.</td></tr>
<tr><td>RW</td><td>N</td><td>sturm</td><td>boolean</td><td>If <code>true</code>, POV-Ray will use the slower but more accurate Sturmian root solver. Use this if the surface exhibits holes or other imperfections.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Polynomial</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csgOperand</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV treats it as similar to one in many ways. For a <code>Polynomial</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Polynomial</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Polynomial</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Polynomial">

<table class="illusBasic">
<tr><td colspan='2'><h4>Prism</h4></td></tr>
<tr><td>

<p>The <code>Prism</code> type is the three-dimensional analogue of the
<code>Polygon</code>. It sweeps the shape defined by the array of
<code>VectorXY</code> in the <code>points</code> parameter along the y-axis from
<code>height1</code> to <code>height2</code>. The points may define multiple
sub-polygons provided that each polygon is closed by repeating the first point
as the last.</p>

<p>Unlike <code>Polygon.points</code>, <code>Prism.points</code> may specify
more than just simple linear splines depending on the value of <code>type</code>.</p>

<p>The example below uses the same <code>points</code> argument as the example for
the <code>Polygon</code>.</p>

<div class='code'>var obj = new Polygon({
    height1: -2,
    height2: 2,
    type: "linearSpline",
    points: [[-2, 2], [2, 2], [2, -2], [-2, -2], [-2, 2],
        [-1, 1], [1, 1], [1, -1], [-1, -1], [-1, 1]],
});</div>

</td><td class='infinite'>

    <img src="img/prism_basic.png">

</td></tr></table>

<h5>Attributes</h5>

<div dh="Prism">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>height1</td><td>float</td><td>Specifies the Y coordinate of the top of the prism.</td></tr>
<tr><td>RW</td><td>Y</td><td>height2</td><td>float</td><td>Specifies the Y coordinate of the bottom of the prism.</td></tr>
<tr><td>RW</td><td>Y</td><td>points</td><td>Array</td><td>The array of spline points to be swept along the Y axis. This can specify multiple sub-shapes: to close a shape, simply repeat the first coordinate. When using any <code>type</code> other than <code>linearSpline</code>, all shapes must be closed.</td></tr>
<tr><td>RW</td><td>Y</td><td>type</td><td>string</td><td>Specifies the spline type used for the prism. The legal values are <code>"bezierSpline"</code>, <code>"conicSweep"</code>, <code>"cubicSpline"</code>, <code>"linearSpline"</code>, <code>"linearSweep"</code>, and <code>"quadraticSpline"</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>open</td><td>boolean</td><td>If <code>true</code>, the top and bottom of the prism are left open.</td></tr>
<tr><td>RW</td><td>N</td><td>sturm</td><td>boolean</td><td>If <code>true</code>, POV-Ray will use the slower but more accurate Sturmian root solver. Use this if the surface exhibits holes or other imperfections.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Prism</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csgOperand</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV treats it as similar to one in many ways. For a <code>Prism</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Prism</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Prism</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Prism">

<table class="illusBasic">
<tr><td colspan='2'><h4>Quadric</h4></td></tr>
<tr><td>

<p>The <code>Quadric</code> type is an optimized second-order polynomial
shape. Its sole required attribute is <code>coefficients</code>, an array
of 10 floats.</p>

<p>The example shown is an infinite hyperboloid aligned with the y-axis.</p>

<div class='code'>var obj = new Quadric({
    coefficients: [ 1, -1, 1, 0, 0, 0, 0, 0, 0, -1 ],
    texture: yellow
});</div>

</td><td>

    <img src="img/quadric_basic.png">

</td></tr></table>

<h5>Attributes</h5>

<div dh="Quadric">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>coefficients</td><td>Array</td><td>An array of 10 floats defining the coefficients of a second-order polynomial.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Quadric</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csgOperand</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV treats it as similar to one in many ways. For a <code>Quadric</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Quadric</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Quadric</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Quadric">

<table class="illusBasic">
<tr><td colspan='2'><h4>Quartic</h4></td></tr>
<tr><td>

<p>The <code>Quartic</code> type is an optimized fourth-order polynomial shape.
Its sole required attribute is <code>coefficients</code>, an array of 35
floats.</p>

<p>The example here is a torus, albeit one that renders more slowly than
the optimized, dedicated <code>Torus</code> type.</p>

<div class='code'>var obj = new Quartic({
    coefficients: [
        1, 0, 0, 0, 2, 0, 0, 2, 0, -104,
        0, 0, 0, 0, 0, 0, 0, 0, 0, 0,
        1, 0, 0, 2, 0, 56, 0, 0, 0, 0,
        1, 0, -104, 0, 784
    ],
    texture: yellow
});
obj.transform = new Matrix("scale", 0.2, 0.2, 0.2);</div>

</td><td>

    <img src="img/quartic_basic.png">

</td></tr></table>

<h5>Attributes</h5>

<div dh="Quartic">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>coefficients</td><td>Array</td><td>An array of 35 floats defining the coefficients of a fourth-order polynomial.</td></tr>
<tr><td>RW</td><td>N</td><td>sturm</td><td>boolean</td><td>If <code>true</code>, POV-Ray will use the slower but more accurate Sturmian root solver. Use this if the surface exhibits holes or other imperfections.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Quartic</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csgOperand</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV treats it as similar to one in many ways. For a <code>Quartic</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Quartic</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Quartic</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Quartic">

<table class="illusBasic">
<tr><td colspan='2'><h4>Sor</h4></td></tr>
<tr><td>

<p>The <code>Sor</code> object, in addition to being an example of how camelCase
breaks down when forced to ingest acronyms, is a simpler and faster form of a
surface of revolution than the <code>Lathe</code> object. It supports only a
single type of smoothly interpolated curve which cannot be closed and can have
only a single radius (x) value at any given point (y), i.e., it's a normal
mathematical function. However, unlike a <code>Lathe</code>, a <code>Sor</code>
has an <code>open</code> attribute which, if <code>true</code>, eliminates the
normal endcaps and yields a hollow shape.</p>

<div class='code'>var obj = new Sor({
    points: [
        [0,   -1.4],
        [0,   -1.3],
        [1,   -1.2],
        [1,   -0.8],
        [0.8, -0.6],
        [0.8, -0.5],
        [1,   -0.4],
        [1,   -0.3],
        [0.8, -0.2],
        [0.8,  0.1],
        [1,    0.2],
        [1,    0.3],
        [0.8,  0.4],
        [0.6,  0.8],
        [0.6,  1.2],
        [0.8,  1.3],
        [0.8,  1.4],
        [0,    1.5],
        [0,    1.6]
    ]
});</div>

</td><td class='infinite'>

    <img src="img/sor_basic.png">

</td></tr></table>

<h5>Attributes</h5>

<div dh="Sor">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>points</td><td>VectorXY</td><td>An array of at least two points which define the open curve used to generate the surface.</td></tr>
<tr><td>RW</td><td>N</td><td>open</td><td>boolean</td><td>If <code>true</code>, the base and the cap are left open, yielding a hollow surface of revolution.</td></tr>
<tr><td>RW</td><td>N</td><td>sturm</td><td>boolean</td><td>If <code>true</code>, POV-Ray will use the slower but more accurate Sturmian root solver. Use this if the surface exhibits holes or other imperfections.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Sor</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csgOperand</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV treats it as similar to one in many ways. For a <code>Sor</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Sor</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Sor</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Sor">

<table class="illusBasic">
<tr><td colspan='2'><h4>Sphere</h4></td></tr>
<tr><td>

<p>The <code>Sphere</code> is defined by the coordinates of its
<code>center</code> and the measure of its <code>radius</code>. The example at
right was created by the following code:</p>

<div class='code'>var obj = new Sphere({
    center: [0, 0, 0],
    radius: 2
});</div>

<p>The optional <code>strength</code> parameter does nothing with an independent
<code>Sphere</code>, but when the object is part of a <code>Blob</code>, it sets
the field strength.

</td><td>

    <img src="img/sphere_basic.png">

</td></tr></table>

<h5>Attributes</h5>

<div dh="Sphere">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>center</td><td>VectorXYZ</td><td>Defines the center point of the sphere.</td></tr>
<tr><td>RW</td><td>Y</td><td>radius</td><td>float</td><td>Specifies the radius of the sphere.</td></tr>
<tr><td>RW</td><td>N</td><td>strength</td><td>float</td><td>If and only if the <code>Sphere</code> is being used as a blob component, <code>strength</code> is a float defining its field strength.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Sphere</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csgOperand</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV treats it as similar to one in many ways. For a <code>Sphere</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Sphere</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Sphere</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Sphere">

<table class="illusBasic">
<tr><td colspan='2'><h4>SphereSweep</h4></td></tr>
<tr><td>

<p>A <code>SphereSweep</code> is a shape consisting of the space occupied by a
sphere moving along a spline. The radius of the sphere can vary over time. It is
defined by an array of spheres, with a minimum of two for a linear spline
or four spheres for a bezier spline or a cubic spline.</p>

<p>For the sake of brevity, the example consists of a linear spline arranged in
a rectangle with two different sizes of spheres acting as control points, but
you can construct arbitrarily complicated shapes with a <code>SphereSweep</code>.</p>

<div class='code'>var obj = new SphereSweep({
    spheres: [
        new Sphere({ center: [-1, 1, -1], radius: 0.25 }),
        new Sphere({ center: [-1, 1, 1],  radius: 0.5  }),
        new Sphere({ center: [1, -1, 1],  radius: 0.25 }),
        new Sphere({ center: [1, -1, -1], radius: 0.5  }),
        new Sphere({ center: [-1, 1, -1], radius: 0.25 }),
    ],
    type: "linearSpline"
});</div>

</td><td>

    <img src="img/spheresweep_basic.png">

</td></tr></table>

<h5>Attributes</h5>

<div dh="SphereSweep">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>spheres</td><td>Array</td><td>The array of <code>Sphere</code>s whose positions are interpolated to create the sweep.</td></tr>
<tr><td>RW</td><td>Y</td><td>type</td><td>string</td><td>Sets the spline type to be used for the sweep. The legal values are <code>"bezierSpline"</code>, <code>"cubicSpline"</code>, and <code>"linearSpline"</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>tolerance</td><td>float</td><td>Defines the depth tolerance used for intersection calculations. The default value, 0.000001, should be adequate in most cases. If imperfections appear on the surface of the sweep, try increasing it to 0.0001.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>SphereSweep</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csgOperand</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV treats it as similar to one in many ways. For a <code>SphereSweep</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>SphereSweep</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>SphereSweep</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="SphereSweep">

<table class="illusBasic">
<tr><td colspan='2'><h4>Superellipsoid</h4></td></tr>
<tr><td>

<p>The <code>Superellipsoid</code> type implements what is more properly known
as a superquadric ellipsoid whose shape can vary from a cube with rounded edges
to fat, egg-like cylinders. It is defined solely by two float parameters,
<code>e</code> and <code>n</code>, the so-called east-west and north-south
exponents, respectively. It occupies roughly the same space as a <code>Box</code>
with corners at <code>[1, 1, 1]</code> and <code>[-1, -1, -1]</code>.</p>

<p>As the example code and rendering indicate, when <code>e</code> and <code>n</code>
have the same value, the result is a cube with rounded edges. When both values reach
1.0, the result is equivalent to a unit sphere.</p>

<div class='code'>var obj = new Superellipsoid({
    e: 0.25,
    n: 0.25
});</div>

</td><td class='infinite'>

    <img src="img/superellipsoid_basic.png">

</td></tr></table>

<h5>Attributes</h5>

<div dh="Superellipsoid">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>e</td><td>float</td><td>Defines the so-called <em>east-west</em> exponent.</td></tr>
<tr><td>RW</td><td>Y</td><td>n</td><td>float</td><td>Defines the so-called <em>north-south</em> exponent.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Superellipsoid</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csgOperand</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV treats it as similar to one in many ways. For a <code>Superellipsoid</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Superellipsoid</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Superellipsoid</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Superellipsoid">

<table class="illusBasic">
<tr><td colspan='2'><h4>Text</h4></td></tr>
<tr><td>

<p>The <code>Text</code> type is very similar to the <code>Prism</code> type,
the main difference being that instead of specifying a spline yourself, you hand
it a string and the pathname of a TrueType font or a TrueType collection from
which the first font will be used.</p>

<p>Fonts, even professionally-designed ones, vary in their obedience to
conventions, so some experimentation is often needed. In most cases, individual
characters will be one unit high. The extruded text will begin at the origin and
run in the +x direction along the x-axis. The front of the text will be parallel
to the xy-plane and the extrusion will go in the +z direction.</p>

<div class='code'>var obj = new Text({
    displayText: "CPOV",
    font: "BebasNeueBold.ttf",
    fontType: "ttf",
    thickness: 0.25,
    offset: 0
});
obj.transform = new Matrix("scale", 2, 2, 2);
obj.transform = new Matrix("translate", 0, 0, -1);</div>

</td><td>

    <img src="img/text_basic.png">

</td></tr></table>

<h5>Attributes</h5>

<div dh="Text">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>displayText</td><td>string</td><td>This contains the text to be rendered.</td></tr>
<tr><td>RW</td><td>Y</td><td>font</td><td>string</td><td>The filename of the font.</td></tr>
<tr><td>RW</td><td>Y</td><td>fontType</td><td>string</td><td>Specifies the file format of the font being used. Legal values are <code>"ttc"</code>, and <code>"ttf"</code>.</td></tr>
<tr><td>RW</td><td>Y</td><td>offset</td><td>float</td><td>Specifies extra space to be placed between characters, 0 for none.</td></tr>
<tr><td>RW</td><td>Y</td><td>thickness</td><td>float</td><td>Specifies the front-to-back thickness of the extruded character shapes.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Text</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csgOperand</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV treats it as similar to one in many ways. For a <code>Text</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Text</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Text</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Text">

<table class="illusBasic">
<tr><td colspan='2'><h4>Torus</h4></td></tr>
<tr><td>

<p>The <code>Torus</code> type specifies a torus with its major and minor radii.
If you think of a torus as the surface described by a smaller two-dimensional
ring swept perpendicularly to a larger ring, the <code>majorRadius</code> is the
radius of the larger ring, and the <code>minorRadius</code> is the radius of the
smaller ring.</p>

<p>The example code and rendering demonstrates a <code>Torus</code> with a minor radius
of 0.5 units and a major radius of 2 units.</p>

<div class='code'>var obj = new Torus({
    minorRadius: 0.5,
    majorRadius: 2
});</div>

</td><td class='infinite'>

    <img src="img/torus_basic.png">

</td></tr></table>

<h5>Attributes</h5>

<div dh="Torus">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>majorRadius</td><td>float</td><td>Defines the major radius of the torus, which is the circle along which the perpendicular circle defined by <code>minorRadius</code> is swept.</td></tr>
<tr><td>RW</td><td>Y</td><td>minorRadius</td><td>float</td><td>Defines the minor radius of the torus, which is the radius of its cross section.</td></tr>
<tr><td>RW</td><td>N</td><td>sturm</td><td>float</td><td>If <code>true</code>, POV-Ray will use the slower but more accurate Sturmian root solver. Use this if the surface exhibits holes or other imperfections.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Torus</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csgOperand</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV treats it as similar to one in many ways. For a <code>Torus</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Torus</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Torus</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Torus">

<table class="illusBasic">
<tr><td colspan='2'><h4>Triangle</h4></td></tr>
<tr><td>

<p>The <code>Triangle</code> type describes a triangular patch that can be used
independently or as part of a mesh. There are two kinds of triangles in
POV-Ray, <code>triangle</code> and <code>smooth_triangle</code>, and both
are subsumed in CephaloPOV's <code>Triangle</code>.</p>

<p>A (plain) triangle has only three required attributes, <code>corner1</code>,
<code>corner2</code>, and <code>corner3</code>, all <code>VectorXYZ</code>
objects with an obvious purpose.</p>

<p>A smooth triangle takes four more attributes. The first is
<code>smooth</code>, which must be <code>true</code>, in addition to which
<code>normal1</code>, <code>normal2</code>, and <code>normal3</code> must be
set. This enables the use of Phong shading. If <code>smooth</code> is
<code>false</code>, the triangle will be output as a plain triangle. Toggling
between the two can be useful for speeding up preview renders or effects in
animations.</p>

<div class='code'>var obj = new Triangle({
    corner1: [ -1, -1, -1 ],
    corner2: [  1, -1, -1 ],
    corner3: [  0,  1,  1 ],
    texture: yellow
});</div>

</td><td>

    <img src="img/triangle_basic.png">

</td></tr></table>

<h5>Attributes</h5>

<div dh="Triangle">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>corner1</td><td>VectorXYZ</td><td>Defines the first corner of the triangle.</td></tr>
<tr><td>RW</td><td>Y</td><td>corner2</td><td>VectorXYZ</td><td>Defines the second corner of the triangle.</td></tr>
<tr><td>RW</td><td>Y</td><td>corner3</td><td>VectorXYZ</td><td>Defines the third corner of the triangle.</td></tr>
<tr><td>RW</td><td>N</td><td>normal1</td><td>VectorXYZ</td><td>Specifies the surface normal for <code>corner1</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>normal2</td><td>VectorXYZ</td><td>Specifies the surface normal for <code>corner2</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>normal3</td><td>VectorXYZ</td><td>Specifies the surface normal for <code>corner3</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>smooth</td><td>boolean</td><td>If <code>smooth</code> is <code>true</code> and <code>normal1...3</code> are defined, the triangle will be output as a smooth triangle.</td></tr>
<tr><td>RW</td><td>N</td><td>textures</td><td>VectorXYZ</td><td class='dummy'>TODO: Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce nec tellus quis turpis pretium condimentum ut eget neque. Integer pharetra imperdiet elit, eu malesuada tortor.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Triangle</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csgOperand</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV treats it as similar to one in many ways. For a <code>Triangle</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Triangle</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Triangle</code>, this is always <code>false</code>.</td></td></tr>
</tbody></table>
</div dh="Triangle">

<table class="illusBasic">
<tr><td colspan='2'><h4>Union</h4></td></tr>
<tr><td>

<p>The <code>Union</code> type is one of the four CSG operations. Like all of
the CSG operations other than <code>Difference</code>, it has a single mandatory
attribute, <code>components</code>, which is an array of objects. The result is
their set-theoretical union, which is different from the original ad hoc
collection of objects in that it can be treated as a single object and
tranformed and textured as a whole, as well as participating in further CSG
operations.</p>

<p>A <code>Union</code> differs from the otherwise identical <code>Merge</code>
by retaining the hidden inner surfaces. This doesn't matter with opaque
objects, of course, but it is often useful when creating transparent or
translucent objects.</p>

<p>In the example, we have merged two spheres, resulting in a single object
that looks, um, exactly like two spheres.</p>

<div class='code'>var obj1 = new Sphere({ center: [1,0,-2], radius: 1.5 });
var obj2 = new Sphere({ center: [3,0,-1], radius: 1.5 });
var union = new Union({ components: [ obj1, obj2 ] });</div>

</td><td>

    <img src="img/union_basic.png">

</td></tr></table>

<h5>Attributes</h5>

<div dh="Union">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>components</td><td>Array</td><td>This is the array of objects to be combined by the CSG <code>Union</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>splitUnion</td><td>boolean</td><td>If the composite object lacks holes, setting <code>splitUnion</code> to <code>false</code> can speed up rendering. Defaults to <code>true</code>.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Union</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Union</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Union</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Union">

<h2>Internals: Hacking CephaloPOV</h2>

<p><span class='h2num'></span>This section, it will surprise absolutely no one,
started as a simple reference to help me get through the first version and be able
to tolerate the fairly frequent and sometimes lengthy interruptions during which code
you wrote with your own hands becomes <i>someone else's code</i>. The same information
serves well as a guide for other developers, so I'm making an effort to keep it up
to date and flesh it out. That said, you know how far I am from completing the end-user
docs? I am even further away from finishing the developer docs.</p>

<p>In the meantime, feel free to ask questions on the development mailing list,
and if you feel like adding to the documentation (hint, hint) then just submit a
pull request.</p>

<p><br/><br/><br/><br/><br/><br/><br/><br/><br/></p>

<h3>Platform Details</h3>

<p>CephaloPOV is developed and tested using something close to the latest
production release of Node. As of 2/13/2019, this is version 11.9.0. The oldest
version I have tested it on is the 10.15.1 LTS release. At some point in the
relatively near future, I will set up a VM with the current LTS release so I
will at least know if a change breaks things. That said, I am making no
commitment to maintain compatibility with older versions of Node, but if you
encounter a regression with different versions of Node, I will be happy to see
if there's a way to fix it without being bound to something other than the
latest Node version. I will be even happier if <em>you</em> figure it out and
submit a pull request with a fix.</p>

<p>For various practical reasons, my personal development machine is an older
laptop running Windows 7 along with Cygwin. The main CephaloPOV program is
tested running from the Windows command prompt, as well as Cygwin's version of
<code>bash</code> and whatever reasonably current Linux distribution I happen to
have handy at the time. If you're going to work on CephaloPOV, you probably want
to do it under Linux or Windows+Cygwin, as the build and test scripts are
neither tested nor maintained for the Windows shell. As with the main program, I
am happy to look into platform compatibility issues, but grinding out MS-DOS
batch files to maintain parity with the corresponding <code>bash</code> scripts
is not going to be a high priority for me.</p>

<p>In general, I am trying very hard to avoid doing anything that would require
platform-specific code, mainly because I don't want to be responsible for
maintaining a port to platforms I do not have ready access to. I am not opposed
to someone contributing platform-specific features, but only if the contributors
are willing to maintain their contributions.</p>

<h3>The File Manifest</h3>

<p>Only the important files are listed here. Things like individual graphics
files for the documentation and generic infrastructure like
<code>.gitignore</code> are omitted.</p>

<div class="code">/build.js .............. Generates classes.js and parts of the documentation.
/cpov.js ............... Contains the main loop, mostly because typing "cpov"
                             is quicker than typing "cephalopov".
/illus.js .............. CephaloPOV program for generating illustrations for
                             the docs.
/docs/index.html ....... The main documentation file, parts of which are updated
                             from the *Def.js files by build.js.
/docs/src .............. The POV-Ray files generated by illus.js end up here.
/lib/cephalopov.js ..... Contains the main program logic.
/lib/classes.js ........ All of the JS classes used by CephaloPOV; generated
                             by build.js.
/lib/colorsInc.js ...... Color definitions converted from POV-Ray's colors.inc.
/lib/file.js ........... (Extremely) simple file i/o object.
/lib/gsDef.js .......... Definition of the GlobalSettings class; used by build.js.
/lib/ioDef.js .......... Definition of the ImageOptions class; used by build.js
/lib/miscDef.js ........ Contains lookup tables, mostly used for data validation.
/lib/objDef.js ......... Definitions for JS classes wrapping POV-Ray graphics
                             primitives; used by build.js.
/lib/primitiveDef.js ... Definition of the Primitive class; used by build.js.
/lib/snippets.js ....... Manually produced code for inclusion in classes.js.
/lib/vectorDef.js ...... Definitions of Vector* and Color classes; used by build.js.
/LICENSE ............... All your base are belong to, well, all of us.
/README.md ............. Generic README for GitHub and NPMjs
/tests/* ............... Various test scripts</div>



<h3>The Build Process</h3>

<p>The build process for CephaloPOV is a bit eccentric. It arose during the
process of settling on the current architecture, which was the fourth attempt at
doing so. I was determined to get it right and not settle on a sub-optimal
solution simply because of the effort that went into building it or the effort
that would be required to replace it with something else.</p>

<p>Consequently, it is a data-driven code generation process. Classes are defined
in a number of definition files, e.g., <code>objDef.js</code>, <code>PrimitiveDef.js</code>, etc.,
and this drives the creation of the main code file, <code>classes.js</code> and
parts of the documentation. Earlier versions were purely declarative, but that
resulted in an apparently endless process of coding exceptions and edge cases, so
the current version uses automatic code generation where it is convenient and clear,
but it grabs named blocks of custom code from <code>snippets.js</code> where that
is easier.</p>

<p>It should be noted that both the definition files and their processor,
<code>build.js</code>, may be eliminated once CephaloPOV is complete and has
been stable for a while. Persons who want to fork CephaloPOV and go in their
own direction might want to at least consider doing away with it now, but for
the time being, modifying the program means dealing with the code generation
system, so it is documented here.</p>

<h4>build.js</h4>

<p>As noted above, <code>build.js</code> manages the build process. It's an
ordinary command line JavaScript program that you will find in CephaloPOV's root
directory. Pass it the <code>-h</code> switch for usage instructions:</p>

<div class='code'>$ node build.js -h

Usage: build [options]

-c, --classes   Generate classes.js
-d, --docs      Update autogen text in index.html
-s, --snippets  Regenerate snippets.js --&gt; snippets.new.js
-o, --objlist   Produce list of object classes
-h, --help      Display this text</div>

<p>The first two options, <code>--classes</code> and <code>--docs</code>, are
the only essential ones. The <code>--classes</code> switch will rebuild
<code>classes.js</code> by reading from the various <code>*Def.js</code> files
and <code>snippets.js</code>. In so doing, <code>classes.js</code> is
overwritten and replaced. The <code>--docs</code> switch rebuilds <em>parts</em>
of the documentation in <code>docs/index.html</code> by replacing the HTML in
specially marked sections. Text outside of those sections is left unaltered.</p>

<p>The other two options, <code>--snippets</code> and <code>--objlist</code>,
are convenience tools. The <code>--snippets</code> switch just reads
<code>snippets.js</code> and writes it back out to <code>snippets.new.js</code>
with a little bit of formatting cleanup. The <code>--objlist</code> switch
simply outputs a list of generated classes, which of course excludes classes
that are entirely manually defined, such as <code>Matrix</code>.</p>

<p>It's only fair to warn you that while <code>build.js</code> is not a large
program, parts of it are pretty hairy, so tread with caution if you want to
modify it.</p>

<h4>The *Def.js Definition Files</h4>

<p>Each of the definition files consists of a JavaScript object or objects
defining the parameters of a generated class and specifying the names of chunks
from <code>snippets.js</code> to fill in specialized functionality. The format
of the definition objects is pretty simple and not at all hard to figure out even
without documentation, but we'll walk through a (hypothetical) object that exercises
all of the features at once.</p>

<p>At the top level of each object are some or all of the following members:</p>

<div class='code'>something: {
    superclass: "Primitive",
    desc: "The something class implements some geometric primitive.",
    conArgs: false,
    conBlock: false,
    snippets: ["Cylinder.toSDL"],
    immutable: { finite: true, solid: true, csg: false, csgOperand: false },
    mutable: [ ... ]
}</div>

<p>The <code>superclass</code> member defines the parent class, if any. For base classes,
this can be omitted. The <code>desc</code> member holds a human-readable description of
the class for the docs. (This isn't actually in use yet, but it eventually will be. In
the meantime, it's okay to leave it <code>false</code>.)</p>

<p>If you look through the generated code in <code>classes.js</code>, you'll
notice that almost all of the constructor methods take a single argument,
<code>options</code>. This is the default produced when <code>conArgs</code>.
Should you wish to override this behavior, <code>conArgs</code> can be set to a
string which will be placed in the constructor signature.</p>

<p>The <code>conBlock</code> member can be a string containing the name of a
snippet to insert into the constructor method after the declaration of the
mutable members (for which, see below). It is usually <code>false</code>.</p>

<p>The <code>snippets</code> member is either <code>false</code> or it is an
array of strings containing the names of snippets to include in the class. They
are inserted after the generated methods in the order given.</p>

<p>As noted in the user documentation, all primitive types have a set of
<code>immutable</code> (i.e., read-only) attributes. These are specified as an
object whose keys are the desired attribute names and values. These are
converted into accessor functions during code generation.</p>

<p>The final and largest part of the class definition appears in the
<code>mutable</code> member, which defines the mutable attributes of the class
and/or specifies a snippet to handle them. They look something like this:</p>

<div class='code'>mutable: [
    {
        name:  "location",
        req:   true,
        valid: "cpov.isClassInstance(val, 'VectorXYZ') || (val = cpov.convertToVector('VectorXYZ', val))",
        err:   "location must be a VectorXYZ.",
        desc:  "Specifies the location of the light source.",
        tname: "VectorXYZ"
    },
    // ...</div>

<p>The <code>name</code> member corresponds to the name of the accessor methods.
Their internal representations are stored with an underscore prefix, e.g.,
<code>_name</code>, because JavaScript doesn't yet support actual private object
members. These are largely initialized to <code>null</code> in the constructor.
The <code>req</code> member is a boolean which determines whether or not the
member must be initialized prior to being output as SDL code.</p>

<p>Validation at assignment time is performed by the code snippet in
<code>valid</code>, which on failure outputs the error message defined in
<code>err</code>. The description of the member in the documentation is provided
by <code>desc</code>, and the contents of <code>tname</code> are used in the
docs to specify the type of the class member.</p>

<p>There are a few additional members that are not show in the example above. In a few
cases, the autogenerated accessor methods are inadequate, so <code>custom</code>
specifies the name of a snippet to use instead. For mutable members that are managed by
CephaloPOV, like the <code>parent</code> members of objects contained by other
objects, setting <code>dperm</code> to <code>"RO"</code> will make them read-only
to user programs. Attributes containing other objects will also have a <code>child</code>
member with a value of either <code>"scalar"</code> or <code>"array"</code>, which
tells CephaloPOV that those objects' <code>parent</code> attributes must be updated
upon assignment.</p>

<h4>snippets.js</h4>

<p>Everything sufficiently complex or specialized that it is easier to code manually
than to generate lives in <code>snippets.js</code>. The organization of the file is
extremely simple. Each code block begins with a specially formatted comment to define
its name, and the associated code continues until the next special comment or the
end of the file, whichever comes first. The special comments look like this:</p>

<div class='code'><b>// SomeArbitraryName //</b>---------------------------------------------------------</div>

<p>The comment must begin in the first column, and the spaces between the
slashes and the name are required. The name itself cannot contain spaces.
Everything following the trailing slashes is ignored; the dashed line is just
for easy readability.</p>

<p>And that's it for <code>snippets.js</code>: it's just a collection of named
chunks of code which are inserted in the generated classes as directed by the
<code>snippets</code> member of the class definitions in the <code>*Def.js</code>
files.</p>

<p>In case you're wondering about motivations, you should know that the first
version attempted to automate nearly everything, but then I ended up spending
more and more time maintaining and extending a version of
<code>build.js</code> that was increasingly resembling a compiler. The current
version mostly handles the tedious boilerplate involved in wrapping POV-Ray's
collection of primitives into JavaScript classes, making it easy to update and
debug those portions. Everything else ends up in <code>snippets.js</code>,
including the occasional entire class definition, as with
<code>Matrix</code>.</p>

<h3>Inside the cpov Object</h3>

<p>Nearly everything other than class definitions and user code lives in the
global <code>cpov</code> object, a singleton which is initialized in
<code>cephalopov.js</code>.

<h4>Data</h4>

<p>TODO</p>

<h4>Methods</h4>

<p>Because most of the code in CephaloPOV lives in classes, the
<code>cpov</code> object's methods consist mainly of small generic data
validation, data conversion, and odd utility functions. The validation and
conversion methods are particularly important because they are used throughout
the various classes to implement CephaloPOV's type system, so it is worth taking
the time to familiarize yourself with them.</p>

<div class="fsig">cpov.arrayToTextList(<i>items</i>)</div>

<p class="fdesc">Used in error messages and the auto-generated parts of the
documentation, this function takes an array of strings and returns a string in
which they are delimited by commas and the conjunction "or". For example,
<code>["one", "two", "three"]</code> becomes <code>"one, two, or
three"</code>.</p>

<div class="fsig">cpov.convertToVector(<i>type</i>, <i>val</i>)</div>

<p class="fdesc">Setter methods in CephaloPOV objects that accept types
<code>VectorXY</code>, <code>VectorUV</code>, <code>VectorXYZ</code>,
<code>VectorXYZW</code>, or <code>Color</code> will also accept bare arrays
just like the constructors for those classes. This is not coincidentally accomplished by
passing <code>val</code> to the constructor for <code>type</code> and
returning the result. Validation of <code>val</code> is left to the class'
constructor and setter methods.</p>

<div class="fsig">cpov.convertToVectorArray(<i>type</i>, <i>val</i>)</div>

<p class="fdesc">This is just the array version of
<code>cpov.convertToVector</code>, where <code>val</code> is an array of numeric
arrays instead of a single array. Returns the an array of objects of the
specified <code>type</code>.</p>

<div class="fsig">cpov.deg2rad(<i>deg</i>)</div>

<p class="fdesc">Converts the value of <code>deg</code> from degrees to radians
and returns the result.</p>

<div class="fsig">cpov.endAnimation()</div>

<p class="fdesc">When called by the user program, this method terminates the
animation loop. If a frame is in progress when it is called, it will not be
output, so it is normally called after file output.</p>

<div class="fsig">cpov.error(<i>level</i>, <i>message</i>, <i>location</i> = "CEPHALOPOV", <i>obj</i> = null)</div>

<p class="fdesc">Outputs an error <code>message</code> using pretty colors if
supported by the terminal. The <code>level</code> argument may be one of
<code>"fatal"</code>, <code>"warn"</code>, <code>"info"</code>, or
<code>"debug"</code>. If <code>level</code> is <code>"fatal"</code>, the program
terminates immediately unless <code>cpov.settings.debug</code> is greater than
<code>1</code>. (This is useful for debugging when working on CephaloPOV
itself.) All other error levels simply emit an error message. This will appear
on the terminal for <code>"warn"</code>, <code>"info"</code>, and
<code>"debug"</code> at <code>cpov.verbosity</code> levels of <code>1</code>,
<code>2</code>, and <code>3</code>, respectively. In all cases, the error will
also be written to <code>cpov.settings.debugLog</code> if initialized.</p>

<p class='fdesc'>The error message is prefixed with the <code>location</code>
where the error occurred, usually a class and method name, and the object <code>serial</code>
and <code>id</code>, if any, are appended to the end of the line.</p>

<div class="fsig">cpov.indentTextBlock(<i>block</i>, <i>stops</i>)</div>

<p class="fdesc">Takes a <code>block</code> of text in the form of a single
string with embedded newlines and prefaces each line with the specified number
of tab <code>stops</code>, returning the result. This function is heavily used
in code generation.</p>

<div class="fsig">cpov.inheritsFrom(<i>val</i>, <i>classname</i>)</div>

<p class="fdesc">Returns a boolean indicating whether object <code>val</code>
is an instance of <code>classname</code>.</p>

<div class="fsig">cpov.initObject(<i>obj</i>, <i>vals</i>)</div>

<p class="fdesc">Standard initialization routine for most objects. Attempts to
assign the values in <code>vals</code>, a simple JavaScript <code>Object</code>
to the CephaloPOV object <code>obj</code>. Attributes that do not exist in
<code>obj</code> will be ignored, and the setter methods of <code>obj</code> may
throw a fatal error if the values fail whatever validation is applied to them.
This routine is used for objects without an explicitly defined
<code>conBlock</code>.</p>

<div class="fsig">cpov.isArrayOfBaseClass(<i>val</i>, <i>classname</i>, <i>min</i>, <i>max</i>)</div>

<p class="fdesc">Returns <code>true</code> if <code>val</code> is an array of
objects of any class inheriting from base class <code>classname</code> with
<code>min</code> to <code>max</code> elements, <code>false</code> otherwise.</p>

<div class="fsig">cpov.isArrayOfClass(<i>val</i>, <i>classname</i>, <i>min</i>, <i>max</i>)</div>

<p class="fdesc">Returns <code>true</code> if <code>val</code> is an array of
objects of class <code>classname</code> with <code>min</code> to
<code>max</code> elements, <code>false</code> otherwise.</p>

<div class="fsig">cpov.isArrayOfFloats(<i>val</i>, <i>min</i>, <i>max</i>)</div>

<p class="fdesc">Returns <code>true</code> if <code>val</code> is an array of
floats (i.e., type <code>Number</code>) with <code>min</code> to
<code>max</code> elements, <code>false</code> otherwise.</p>

<div class="fsig">cpov.isArrayOfInts(<i>val</i>, <i>min</i>, <i>max</i>)</div>

<p class="fdesc">Returns <code>true</code> if <code>val</code> is an array of
integers with <code>min</code> to <code>max</code> elements, <code>false</code>
otherwise. See <code>cpov.isInt</code> for what constitutes an integer in
JavaScript's int-less type system.</p>

<div class="fsig">cpov.isArrayOfNonEmptyStrings(<i>val</i>, <i>min</i>, <i>max</i>)</div>

<p class="fdesc"><p class="fdesc">Returns <code>true</code> if <code>val</code>
is an array of non-empty <code>String</code>s with <code>min</code> to
<code>max</code> elements, <code>false</code> otherwise.</p>

<div class="fsig">cpov.isArrayOfStrings(<i>val</i>, <i>min</i>, <i>max</i>)</div>

<p class="fdesc"><p class="fdesc">Returns <code>true</code> if <code>val</code>
is an array of <code>String</code>s with <code>min</code> to <code>max</code>
elements, <code>false</code> otherwise.</p>

<div class="fsig">cpov.isArrayOfSubclass(<i>val</i>, <i>classname</i>)</div>

<p class="fdesc">Returns <code>true</code> if <code>val</code> is a member of a
class inheriting from <code>classname</code>, <code>false</code> otherwise.</p>

<div class="fsig">cpov.isBetween(<i>val</i>, <i>min</i>, <i>max</i>)</div>

<p class="fdesc">Returns <code>true</code> if <code>min</code> &lt;
<code>val</code> &gt; <code>max</code>, <code>false</code> otherwise. See
also <code>cpov.isWithin</code>.</p>

<div class="fsig">cpov.isBoolean(<i>val</i>)</div>

<p class="fdesc">Returns <code>true</code> if <code>val</code> is of type
<code>boolean</code>, <code>false</code> otherwise. Note that it is the type
of <code>val</code> that is being tested for, not its literal boolean value.</p>

<div class="fsig">cpov.isChar(<i>val</i>)</div>

<p class="fdesc">Returns <code>true</code> if <code>val</code> is of type
<code>String</code> with a length of <code>1</code>, <code>false</code> otherwise. JavaScript
of course does not have a <code>char</code> type; we're just emulating one for
POV-Ray's sake using single-character strings.</p>

<div class="fsig">cpov.isClassInstance(<i>val</i>, <i>classname</i>)</div>

<p class="fdesc">Returns <code>true</code> if <code>val</code> is a member of
class <code>classname</code>, <code>false</code> otherwise.</p>

<div class="fsig">cpov.isFloat(<i>val</i>)</div>

<p class="fdesc">Returns a boolean indicating whether <code>val</code> is a
<code>Number</code>. It is so named because POV-Ray makes a distinction between
floats and ints, and hopefully JavaScript will eventually be able to make the
same distinction.</p>

<div class="fsig">cpov.isInArray(<i>val</i>, <i>array</i>)</div>

<p class="fdesc">Returns <code>true</code> if <code>val</code> appears as an
element of <code>array</code>, <code>false</code> otherwise.</p>

<div class="fsig">cpov.isInt(<i>val</i>)</div>

<p class="fdesc">Returns <code>true</code> if <code>val</code> is an integer,
which for the purposes of JavaScript's lack of true integers means that the type
of <code>val</code> is <code>Number</code> and it has no fractional part.
Returns <code>false</code> otherwise.</p>

<div class="fsig">cpov.isKey(<i>val</i>, <i>object</i>)</div>

<p class="fdesc">Returns <code>true</code> if <code>object[val]</code> is
defined, <code>false</code> otherwise.</p>

<div class="fsig">cpov.isNonEmptyString(<i>val</i>)</div>

<p class="fdesc">Returns <code>true</code> if <code>val</code> is of type
<code>String</code> and has a non-zero <code>length</code>, <code>false</code>
otherwise.</p>

<div class="fsig">cpov.isNull(<i>val</i>)</div>

<p class="fdesc">Returns <code>true</code> if </code>val</code> is
<code>null</code>, <code>false</code> otherwise.</p>

<div class="fsig">cpov.isNullOrFunction(<i>val</i>)</div>

<p class="fdesc">Returns <code>true</code> if <code>val</code> is
<code>null</code>, an object of type <code>Function</code>, or an SDL function,
i.e., a string beginning with <code>"&amp;"</code>. In all other cases, it returns
<code>false</code>.</p>

<div class="fsig">cpov.isNullOrJSFunction(<i>val</i>)</div>

<p class="fdesc">Returns <code>true</code> if <code>val</code> is
<code>null</code> or an object of type <code>Function</code>. In all other
cases, including SDL function strings, it returns <code>false</code>.</p>

<div class="fsig">cpov.isPowerOfTwo(<i>val</i>)</div>

<p class="fdesc">Returns <code>true</code> if <code>val</code> is a power of
two, <code>false</code> otherwise. As implemented, it only operates in the
interval 2<sup>0</sup>&ndash;2<sup>64</sup>.</p>

<div class="fsig">cpov.isSDLFunction(<i>val</i>)</div>

<p class="fdesc">Returns <code>true</code> if <code>val</code> is an SDL
function, which for the purposes of CephaloPOV is a <code>String</code> beginning
with an ampersand, i.e., <code>"&amp;"</code>.</p>

<div class="fsig">cpov.isString(<i>val</i>)</div>

<p class="fdesc">Returns <code>true</code> if <code>val</code> is of type
<code>String</code>, <code>false</code> otherwise.</p>

<div class="fsig">cpov.isUnusedId(<i>val</i>, <i>obj</i>)</div>

<p class="fdesc">CephaloPOV objects may contain a user-supplied GUID. This
function tests whether <code>val</code> is already in use with another object.
If not, it adds <code>obj</code> to <code>cpov.idMap</code> with <code>val</code>
as an index and returns <code>true</code>. If <code>val</code> is already in
use, it returns <code>false</code> instead.</p>

<div class="fsig">cpov.isUnusedSerial(<i>val</i>, <i>obj</i>)</div>

<p class="fdesc">In addition to optional user-supplied GUIDs (see <code>cpov.isUnusedId</code>, above),
<em>every</em> CephaloPOV object has a unique serial number.  This
function tests whether <code>val</code> is already in use with another object.
If not, it adds <code>obj</code> to <code>cpov.serialMap</code> with <code>val</code>
as an index and returns <code>true</code>. If <code>val</code> is already in
use, it returns <code>false</code> instead.</p>

<div class="fsig">cpov.isWithin(<i>val</i>, <i>min</i>, <i>max</i>)</div>

<p class="fdesc">Returns <code>true</code> if <code>min</code> &le;
<code>val</code> &ge; <code>max</code>, <code>false</code> otherwise. See
also <code>cpov.isBetween</code>.</p>

<div class="fsig">cpov.keysToTextList(<i>obj</i>)</div>

<p class="fdesc">This function converts the keys of <code>obj</code> to an array
and wraps each element in single quotes before passing it to
<code>cpov.arrayToTextList</code> to convert it into a comma-delimited string
for use in the auto-generated parts of the documentation.</p>

<div class="fsig">cpov.objectImport(<i>filename</i>)</div>

<p class="fdesc">Takes a <code>filename</code>, which is currently always
<code>snippets.js</code>, and parses it using specially formatted comments of
the form</p>

<div class='code fdesc'>// Keyname //-------------------------------------------------------------------</div>

<p class='fdesc'>where the initial slash appears in the first column. The
keyname is extracted and used to index the following text up to the next special
comment. Although the examples you will see in <code>snippets.js</code> all have
a line of trailing dashes, everything past the last slash is ignored. The spaces
on either side of the keyname are mandatory, and the name itself cannot contain
any whitespace.</p>

<p class='fdesc'>The resulting object is returned and used for inserting the
named blocks of code into the generated code, mostly in
<code>classes.js</code>.</p>

<div class="fsig">cpov.outputFrame()</div>

<p class="fdesc">The <code>cpov.outputFrame</code> method exists for user
programs to call whenever they have finished setting up a scene. It takes no
arguments, its behavior being determined mostly by
<code>cpov.imageOptions</code> and <code>cpov.globalSettings</code>. That
behavior is already described in great detail in <a
href="#tocThe%20Animation%20Cycles">The Animation Cycles</a> and will not be
repeated here.</p>

<p class="fdesc">There is no return value. If any termination conditions are
met, CephaloPOV will terminate with an exit code of <code>0</code>.</p>

<div class="fsig">cpov.parseCLI(<i>optionMap</i>)</div>

<p class="fdesc">Another function that will eventually migrate elsewhere,
perhaps into its own package, <code>cpov.parseCLI</code> is a simple command
line parser which implements the subset of the usual *nix conventions that
CephaloPOV actually needs. It is passed a single argument, the
<code>optionMap</code> object, thus:</p>

<div class='code fdesc'>var optionMap = {
    infile:     { short: "i", vals: [ ] },  // accumulates values
    outfiles:   { short: "o", vals: [ ] },
    preamble:   { short: "p", vals: [ ] },
    sdlinclude: { short: "s", vals: [ ] },
    verbose:    { short: "v", cnt: 0 },     // accumulates appearance counts
    quietMode:  { short: "q", cnt: 0 },
    debug:      { short: "d", cnt: 0 },
    help:       { short: "h", cnt: 0 },
}</div>

<p class='fdesc'>The keys of the <code>optionMap</code> are the long options,
the <code>short</code> members in the value objects are the short options. If a
<code>vals</code> array is provided, arguments to the switch are accumulated
therein. If a <code>cnt</code> counter is provided, the number of appearances of
the switch are counted therein. You can't do both.</p>

<p class='fdesc'>The <code>optionMap</code> is altered in place. If malformed
user input is encountered, the program is terminated with a call to
<code>cpov.error</code>.</p>

<div class="fsig">cpov.primitiveDefIdentifier(<i>obj</i>)</div>

<p class="fdesc">Given a CephaloPOV object, returns a unique string consisting
of the form <code>#serial:id</code>. If the object does not have an <code>id</code>,
both it and the interstitial colon are omitted. This is appended to the error
messages emitted by <code>cpov.error</code>.</p>

<div class="fsig">cpov.requireOptLib(<i>alias</i>)</div>

<p class="fdesc">CephaloPOV includes a number of optional libraries that are not
automatically loaded at runtime. Each is identified by a mnemonic <code>alias</code>
passed to <code>cpov.requireOptLib</code>, which in turn loads the library and returns
it to the caller. Many of these are ports of POV-Ray include files to JavaScript
identified by their original filename, e.g., <code>colors.inc</code>.</p>

<div class="fsig">cpov.round(<i>n</i>, <i>d</i>)</div>

<p class="fdesc">Takes a number, <code>n</code>, and returns it rounded
to <code>d</code> decimal places.</p>

<div class="fsig">cpov.runAnimation()</div>

<p class="fdesc">This is the main animation loop which repeats, calling
<code>cpov.outputFrame()</code> repeatedly until one of its termination
conditions are met or the user program calls <code>cpov.endAnimation</code>.</p>

<div class="fsig">cpov.tab(<i>stops</i>)</div>

<p class="fdesc">One of the functions used in formatting generated code, both
JavaScript and SDL, returns a string containing <code>4 * stops</code>
spaces. Do not submit a pull request changing this to tabs or other numbers of
spaces, or I will curse you and your progeny.</p>

<div class="fsig">cpov.testStage(<i>type</i>, <i>size</i>)</div>

<p class="fdesc">Returns an array of objects that serve as stages or backdrops
for geometric objects generated for tests and illustrations in the CephaloPOV
documentation.</p>

<p class="fdesc">If <code>type</code> is given as <code>"corner"</code>, the generated
stage consists of three adjacent faces of a cube around one corner in the same
configuration as a corner reflector. The faces are <code>size</code> units square and
the axes run through the centroids of each face. If <code>type</code> is <code>"triplane"</code>,
then the stage takes the form of three translucent planes intersecting at the origin.</p>

<p class="fdesc">Cameras and lighting are included in the stage. It is assumed that the final
image will have a 1:1 aspect ratio, so you will have to adjust the camera
parameters, particularly <code>camera.right</code>, if you want a different
aspect ratio.</p>

<p class="fdesc">It is highly likely that this function will be extended and
changed in backwards-incompatible ways to serve the needs of documentation and
testing, so if you want to use it outside of CephaloPOV itself, it's best to
make your own copy of the function.</p>

<div class="fsig">cpov.timerStats(<i>start</i>, <i>end</i>, <i>units</i> = 1)</div>

<p class="fdesc">This function is used to calculate performance statistics. It
takes a <code>start</code> and <code>end</code> time and a number of work
<code>units</code>, and it returns an object containing the elapsed time in
milliseconds and seconds and the average times per unit. (The units are usually
frames.)</p>

<h2>Appendices</h2>

<p><span class='h2num'></span>The appendices contain further details and discussions about
CephaloPOV and ray tracing supplementary to the main text.</p>

<p><br/><br/><br/><br/><br/><br/><br/><br/><br/></p>

<h3>Matrices</h3>

<p>SDL matrices are an abbreviated form of the entire matrix being used. The
fourth column is invariant and therefore omitted from its SDL representation and
inaccessible within CephaloPOV, but we show it below in grey for the
math-curious. You <em>don't</em> have to know much about matrix math to use the
<code>Matrix</code> class. Like SDL, CephaloPOV offers shortcuts to the
individual transformations in the form of special arguments to the
<code>Matrix</code> constructor and the <code>apply</code> method.</p>

<h4>Translation, Scaling, and Skewing</h4>

<p>Red elements determine scaling, blue elements determine translation, and
green elements determine skewing. (The grey elements, as previously mentioned,
are invariant and hidden in both POV-Ray and CephaloPOV.) Note that there are
three elements for each axis when scaling and translating, but there are six
elements for skewing, because skew transformations involve relationships between
pairs of axes.</p>

<table class='matrixDemo'>
    <tr><th></th><th>Column<br/>0</th><th>Column<br/>1</th><th>Column<br/>2</th><th>Column<br/>3</th></tr>
    <tr>
        <th>Row<br/>0</th>
        <td class='scale'><div class='cpName'>v00</div><div class='op'>Scale X</div></td>
        <td class='skew'><div class='cpName'>v01</div><div class='op'>Skew Y by X</div></td>
        <td class='skew'><div class='cpName'>v02</div><div class='op'>Skew Z by X</div></td>
        <td class='implicit'><div class='cpName'>(v03)</div><div class='op'>0</div></td>
    </tr><tr>
        <th>Row<br/>1</th>
        <td class='skew'><div class='cpName'>v10</div><div class='op'>Skew X by Y</div></td>
        <td class='scale'><div class='cpName'>v11</div><div class='op'>Scale Y</div></td>
        <td class='skew'><div class='cpName'>v12</div><div class='op'>Skew Z by Y</div></td>
        <td class='implicit'><div class='cpName'>(v13)</div><div class='op'>0</div></td>
    </tr><tr>
        <th>Row<br/>2</th>
        <td class='skew'><div class='cpName'>v20</div><div class='op'>Skew X by Z</div></td>
        <td class='skew'><div class='cpName'>v21</div><div class='op'>Skew Y by Z</div></td>
        <td class='scale'><div class='cpName'>v22</div><div class='op'>Scale Z</div></td>
        <td class='implicit'><div class='cpName'>(v23)</div><div class='op'>0</div></td>
    </tr><tr>
        <th>Row<br/>3</th>
        <td class='translate'><div class='cpName'>v30</div><div class='op'>Translate X</div></td>
        <td class='translate'><div class='cpName'>v31</div><div class='op'>Translate Y</div></td>
        <td class='translate'><div class='cpName'>v32</div><div class='op'>Translate Z</div></td>
        <td class='implicit'><div class='cpName'>(v33)</div><div class='op'>1</div></td>
    </tr>
</table>

<p>An important thing to notice here is that while the matrix elements that
determine translation and skewing are 0 if no translation or skewing is to be
done, the elements that define scaling must be 1 when no scaling is to be done,
i.e., it's an identity element. Setting the scaling elements to zero will make
the object disappear!</p>

<p>Another thing to notice about scaling is that negative values will
<em>reflect</em> the object across the relevant axis. In the special case of 1,
this will be a perfect mirror image; other values will stretch or squash the
object.</p>

<h4>Rotation</h4>

<p>Rotation is a little more complicated because it requires the use of
trigonometric functions. This is handled for you by the Matrix class'
<code>rotate</code> constructor argument, but it's worth understanding in case
you want to try doing the calculations yourself or trying variations to see what
they do.</p>

<p>Since the values for rotations around the axes overlap, we'll omit the
invariant fourth column and the translation row so we can cram all three
rotation matrices into a single row. In this case, we'll color the rotation
elements red, the single scale identity element blue, and everything else grey.
If you're entirely innocent of trigonometry, know that <i>cos</i> and <i>sin</i>
are the trigonometric functions cosine and sine, which are implemented in
JavaScript as the <code>Math.cos()</code> and <code>Math.sin()</code> methods.
The angle of rotation is conventionally represented by the Greek letter theta,
&theta;, and is specified in radians, though POV-Ray and CephaloPOV expect you
to use degrees instead and quietly translate degrees into radians for you.</p>


<table style='width: 100%;'>
    <tr>
        <td style='width: 33%;'>

            <table class='matrixDemo'>
                <tr><th colspan='4'>Rotation around the X axis</th></tr>
                <tr><th></th><th>Col.<br/>0</th><th>Col.<br/>1</th><th>Col.<br/>2</th></tr>
                <tr>
                    <th>Row<br/>0</th>
                    <td class='ident'><div class='cpName'>v00</div><div class='op'>1</div></td>
                    <td class='null'><div class='cpName'>v01</div><div class='op'>0</div></td>
                    <td class='null'><div class='cpName'>v02</div><div class='op'>0</div></td>
                </tr><tr>
                    <th>Row<br/>1</th>
                    <td class='null'><div class='cpName'>v10</div><div class='op'>0</div></td>
                    <td class='rotate'><div class='cpName'>v11</div><div class='op'><i>cos</i>(&theta;)</div></td>
                    <td class='rotate'><div class='cpName'>v12</div><div class='op'><i>sin</i>(&theta;)</div></td>
                </tr><tr>
                    <th>Row<br/>2</th>
                    <td class='null'><div class='cpName'>v20</div><div class='op'>0</div></td>
                    <td class='rotate'><div class='cpName'>v21</div><div class='op'>-<i>sin</i>(&theta;)</div></td>
                    <td class='rotate'><div class='cpName'>v22</div><div class='op'><i>cos</i>(&theta;)</div></td>
                </tr>
            </table>

        </td><td style='width: 33%;'>

            <table class='matrixDemo'>
                <tr><th colspan='4'>Rotation around the Y axis</th></tr>
                <tr><th></th><th>Col.<br/>0</th><th>Col.<br/>1</th><th>Col.<br/>2</th></tr>
                <tr>
                    <th>Row<br/>0</th>
                    <td class='rotate'><div class='cpName'>v00</div><div class='op'><i>cos</i>(&theta;)</div></td>
                    <td class='null'><div class='cpName'>v01</div><div class='op'>0</div></td>
                    <td class='rotate'><div class='cpName'>v02</div><div class='op'>-<i>sin</i>(&theta;)</div></td>
                </tr><tr>
                    <th>Row<br/>1</th>
                    <td class='null'><div class='cpName'>v10</div><div class='op'>0</div></td>
                    <td class='ident'><div class='cpName'>v11</div><div class='op'>1</div></td>
                    <td class='null'><div class='cpName'>v12</div><div class='op'>0</div></td>
                </tr><tr>
                    <th>Row<br/>2</th>
                    <td class='rotate'><div class='cpName'>v20</div><div class='op'><i>sin</i>(&theta;)</div></td>
                    <td class='null'><div class='cpName'>v21</div><div class='op'>0</div></td>
                    <td class='rotate'><div class='cpName'>v22</div><div class='op'><i>cos</i>(&theta;)</div></td>
                </tr>
            </table>

        </td><td style='width: 33%;'>

            <table class='matrixDemo'>
                <tr><th colspan='4'>Rotation around the Z axis</th></tr>
                <tr><th></th><th>Col.<br/>0</th><th>Col.<br/>1</th><th>Col.<br/>2</th></tr>
                <tr>
                    <th>Row<br/>0</th>
                    <td class='rotate'><div class='cpName'>v00</div><div class='op'><i>cos</i>(&theta;)</div></td>
                    <td class='rotate'><div class='cpName'>v01</div><div class='op'><i>sin</i>(&theta;)</div></td>
                    <td class='null'><div class='cpName'>v02</div><div class='op'>0</div></td>
                </tr><tr>
                    <th>Row<br/>1</th>
                    <td class='rotate'><div class='cpName'>v10</div><div class='op'>-<i>sin</i>(&theta;)</div></td>
                    <td class='rotate'><div class='cpName'>v11</div><div class='op'><i>cos</i>(&theta;)</div></td>
                    <td class='null'><div class='cpName'>v12</div><div class='op'>0</div></td>
                </tr><tr>
                    <th>Row<br/>2</th>
                    <td class='null'><div class='cpName'>v20</div><div class='op'>0</div></td>
                    <td class='null'><div class='cpName'>v21</div><div class='op'>0</div></td>
                    <td class='ident'><div class='cpName'>v22</div><div class='op'>1</div></td>
                </tr>
            </table>

        </td>
    </tr>
</table>

<p>Note the sign of the sine functions. These are specific to the left-handed
coordinate system that POV-Ray uses. In a right-handed system, you'd reverse the
signs.</p>

<p>If you want to know more, Jeff Lee's <a
href="https://www.shipbrook.net/jeff/raytrace/matrix.html">POV-Ray-specific
tutorial</a> is a good place to start, as are these <a
href="https://courses.cs.washington.edu/courses/cse457/99au/handouts/lectures/3d-transformations.pdf">course
notes</a>. To dig deeper than that&mdash;and there's a <em>lot</em> more you can
do with matrices&mdash;the topic is covered in depth in 3D graphics and linear
algebra textbooks. And don't be scared off: it's far more tedious than
difficult. Choose a simple shape, try fiddling with different elements and
different functions, and look at the results of a rendering.</p>


<h3>Administrivia</h3>

<h4>TODO</h4>

<h5>Version 0.0.2</h5>

<table class='sgrid todo'>
    <thead>
        <tr>
            <th>Status</th>
            <th>Type</th>
            <th>Pri</th>
            <th>Description</th>
        </tr>
    <thead><tbody>
        <!-- <tr><td></td><td><td></td></td><td></td></tr> -->

        <tr><td class='pending'>pending</td><td>TST</td><td>C&bigstar;</td><td><code>Camera</code>: <code>transformLink</code> and support code, i.e., <code>parent</code> setting and transformation pairing.</td></tr>

        <tr><td class='pending'>pending</td><td>I+T</td><td>D3</td><td><code>Camera</code> description and example</td></tr>
        <tr><td class='pending'>pending</td><td>I+T</td><td>D3</td><td>Multi-<code>Camera</code> <code>active</code> test at generation time.</td></tr>
        <tr><td class='pending'>pending</td><td>I+T</td><td>D4</td><td><code>LightSource</code> description and example</td></tr>

        <tr><td class='pending'>pending</td><td>IMP</td><td>c</td><td><code>Camera.normal</code></td></tr>

        <tr><td class='pending'>pending</td><td>I+T</td><td>c</td><td><code>LightSource</code>: Implement restrictions for area lights generally and the orient keyword in particular.</td></tr>
        <tr><td class='pending'>pending</td><td>I+T</td><td>c</td><td><code>LightSource.looksLike</code></td></tr>
        <tr><td class='pending'>pending</td><td>I+T</td><td>c</td><td><code>LightSource.projectedThrough</code></td></tr>

        <tr><td class='pending'>pending</td><td>DOC</td><td>D6</td><td>Document internal optional libraries.</td></tr>
        <tr><td class='pending'>pending</td><td>DOC</td><td>D7</td><td>Document the various spline types.</td></tr>

        <!-- Tests -->

        <tr><td class='pending'>pending</td><td>I+T</td><td>c</td><td>Separate repo for tests/examples and a <em>lot</em> of stuff to go into it before the next version.</td></tr>

    </tbody>
</table>

<h5>Version 0.0.3</h5>

<table class='sgrid todo'>
    <thead>
        <tr>
            <th>Status</th>
            <th>Type</th>
            <th>Pri</th>
            <th>Description</th>
        </tr>
    <thead><tbody>
        <!-- <tr><td></td><td><td></td></td><td></td></tr> -->

        <!-- Mesh/Mesh2 -->

        <tr><td class='pending'>pending</td><td>I+T</td><td>&nbsp;</td><td><code>Mesh2</code> description and example</td></tr>
        <tr><td class='pending'>pending</td><td>I+T</td><td>&nbsp;</td><td>Compact output format for <code>Triangle</code>s in <code>Mesh</code></td></tr>
        <tr><td class='pending'>pending</td><td>I+T</td><td>&nbsp;</td><td><code>Mesh/Triangle</code>: Improve constructor validation</td></tr>
        <tr><td class='pending'>pending</td><td>I+T</td><td>&nbsp;</td><td><code>uvVectors</code> member in <code>Triangle</code>, check <code>Mesh</code> compatibility.</td></tr>
        <tr><td class='pending'>pending</td><td>I+T</td><td>&nbsp;</td><td><code>Mesh2</code></td></tr>

        <!-- Object documentation -->

        <tr><td class='pending'>pending</td><td>I+T</td><td>&nbsp;</td><td><code>Mesh</code> description and example</td></tr>


        <tr><td class='pending'>pending</td><td>I+T</td><td>&nbsp;</td><td>Make sure <code>Primitive.destroy</code> recurses through child objects.</td></tr>
        <tr><td class='pending'>pending</td><td>I+T</td><td>&nbsp;</td><td>Validate <code>Polynomial.order</code>.</td></tr>
        <tr><td class='pending'>pending</td><td>I+T</td><td>&nbsp;</td><td><code>copy()</code> method across classes, both shallow and deep</td></tr>
        <tr><td class='pending'>pending</td><td>I+T</td><td>&nbsp;</td><td><code>cpov.js</code>: More selective scope management, untangle internal dependencies</td></tr>
        <tr><td class='pending'>pending</td><td>I+T</td><td>&nbsp;</td><td>Management of array attributes</td></tr>
        <tr><td class='pending'>pending</td><td>I+T</td><td>&nbsp;</td><td>Execution: Oversee execution directly</td></tr>
        <tr><td class='working'>working</td><td>I+T</td><td>&nbsp;</td><td>Texture subsystem</td></tr>
            <tr><td class='working'>working</td><td>I+T</td>&nbsp;<td></td><td class='subtask'><code>Normal</code> and <code>NormalMap</code></td></tr>
            <tr><td class='working'>working</td><td>I+T</td>&nbsp;<td></td><td class='subtask'><code>Pigment</code> and <code>PigmentMap</code></td></tr>
            <tr><td class='working'>working</td><td>I+T</td>&nbsp;<td></td><td class='subtask'><code>Texture</code> and <code>TextureMap</code></td></tr>
        <tr><td class='pending'>pending</td><td>I+T</td><td>&nbsp;</td><td><code>Primitive</code></td></tr>
        <tr><td class='pending'>pending</td><td>I+T</td><td>&nbsp;</td><td class='subtask'><code>Primitive.interior</code></td></tr>
        <tr><td class='pending'>pending</td><td>I+T</td><td>&nbsp;</td><td class='subtask'><code>Primitive.interiorTexture</code></td></tr>
        <tr><td class='pending'>pending</td><td>I+T</td><td>&nbsp;</td><td class='subtask'><code>Primitive.photons</code></td></tr>
        <tr><td class='pending'>pending</td><td>I+T</td><td>&nbsp;</td><td class='subtask'><code>Primitive.radiosity</code></td></tr>
        <tr><td class='pending'>pending</td><td>I+T</td><td>&nbsp;</td><td class='subtask'><code>Primitive.texture</code></td></tr>
        <tr><td class='pending'>pending</td><td>I+T</td><td>&nbsp;</td><td>Atmospheric effects</td></tr>
        <tr><td class='pending'>pending</td><td>I+T</td><td>&nbsp;</td><td>Reports</td></tr>
        <tr><td class='pending'>pending</td><td>I+T</td><td>&nbsp;</td><td>Illustration stage generator: <span class='fixme'>translucent</span> XYZ planes, n x n, <span class='fixme'>adjust camera</span></td></tr>
        <tr><td class='pending'>pending</td><td>I+T</td><td>&nbsp;</td><td><code>LightSource.mediaAttenuation</code></td></tr>
        <tr><td class='pending'>pending</td><td>I+T</td><td>&nbsp;</td><td><code>LightSource.mediaInteraction</code></td></tr>
    </tbody>
</table>

<h5>Backlog</h5>

<table class='sgrid todo'>
    <thead>
        <tr>
            <th>Status</th>
            <th>Type</th>
            <th>Pri</th>
            <th>Description</th>
        </tr>
    <thead><tbody>
        <!-- <tr><td></td><td></td><td></td></tr> -->
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>TBD</td><td>A large set of sample functions/variants for the <code>IsoSurface</code> type and the polynomials.</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>TBD</td><td>Additional splines, easing functions, esp. Catmull-Rom</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>TBD</td><td>Angles in the unit interval</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>TBD</td><td>Automatic normal calculations, etc., for <code>Triangle</code> and <code>Mesh/Mesh2</code> Maybe native code or an external util.</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>TBD</td><td>Color and texture SDL generation, i.e., in separate file to use directly with POV-Ray</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>TBD</td><td>Direct support for ffmpeg/avisynth + Google speech API</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>TBD</td><td>Drag in some color libraries, theme generators</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>TBD</td><td>Eric Haines' table of object intersections, collision detection</td></tr>
        <tr><td class='tbd'>TBD</td><td>TDB</td><td>TBD</td><td>External batch rendering util.</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>TBD</td><td>Fix <code>inputFileName</code> and <code>outputFileName</code> in <code>ImageOptions</code> if needed.</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>TBD</td><td>Geometric query system</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>TBD</td><td>https://www.npmjs.com/package/ml-matrix (?)</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>TBD</td><td>Level-of-Detail</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>TBD</td><td>Macro/Function generation, i.e., in separate file to use directly with POV-Ray</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>TBD</td><td>Object serialization and packages.</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>TBD</td><td>Parametric compound types, i.e., not the <code>Parametric</code> primitive.</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>TBD</td><td>Particle systems</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>TBD</td><td>Polyhedron library</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>TBD</td><td>Porting of functions/presets in .inc files</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>TBD</td><td>Script execution on events</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>TBD</td><td>Script to parse as much as possible of POV-Ray .inc files into JS/cpov</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>TBD</td><td>Specify a config file from the command line.</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>TBD</td><td>Spline-builder UI</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>TBD</td><td>Stereo pseudo-cameras</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>TBD</td><td>Reorg: Script to pretty-print definition files</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>TBD</td><td>Wrap Array attributes with Proxies to enforce type (?)</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>TBD</td><td>Turtle graphics -- snapshot mode forms part of the basis for this.</td></tr>
    </tbody>
</table>


<h4>CephaloPOV Scene Graph</h4>

<p>Master objects are defined relative to the origin. More precisely, the origin is
their primary point of articulation. In each frame, they are transformed to
their current frame-state.</p>

<p>Possibly, a relationship between A and B is stated in the form of B's point of
articulation relative to some explicit or implicit point in A. In its most basic
form, this would amount to free movement of B relative to its attachment point
to A. PSII could provide a set of standard constraints, e.g., ball joint, hinge,
track, etc., which could be built upon or supplanted by the user.</p>

<p>This suggests a separate assembly process for objects with moving parts, which
means that ordinary native CSG objects can go ahead just fine. Converting them
into master objects amounts to just positioning them appropriately relative to
the origin after construction.</p>


<h4>Changelog</h4>

<p>Oh geez, not yet.</p>


</body>
</html>
