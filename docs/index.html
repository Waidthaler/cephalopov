<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>CephaloPOV Documentation</title>
<style type="text/css">

@font-face { font-family: ArchivoNarrow; src: url("fonts/archivonarrow/ArchivoNarrow-Regular.ttf"); }
@font-face { font-family: ArchivoNarrow; src: url("fonts/archivonarrow/ArchivoNarrow-Bold.ttf"); font-weight: bold; }
@font-face { font-family: ArchivoNarrow; src: url("fonts/archivonarrow/ArchivoNarrow-BoldItalic.ttf"); font-weight: bold; font-style: italic; }
@font-face { font-family: ArchivoNarrow; src: url("fonts/archivonarrow/ArchivoNarrow-Italic.ttf"); font-style: italic; }

@font-face { font-family: ArchivoNarrowSemiBold; src: url("fonts/archivonarrow/ArchivoNarrow-SemiBold.ttf"); }
@font-face { font-family: ArchivoNarrowSemiBold; src: url("fonts/archivonarrow/ArchivoNarrow-SemiBoldItalic.ttf"); font-style: italic; }

@font-face { font-family: ArchivoNarrowMedium; src: url("./fonts/archivonarrow/ArchivoNarrow-Medium.ttf"); }
@font-face { font-family: ArchivoNarrowMedium; src: url("./fonts/archivonarrow/ArchivoNarrow-MediumItalic.ttf"); font-style: italic; }

@font-face { font-family: Chivo; src: url("./fonts/chivo/Chivo-Bold.ttf"); font-weight: bold; }
@font-face { font-family: Chivo; src: url("./fonts/chivo/Chivo-BoldItalic.ttf"); font-weight: bold; font-style: italic; }
@font-face { font-family: Chivo; src: url("./fonts/chivo/Chivo-Italic.ttf"); font-style: italic; }
@font-face { font-family: Chivo; src: url("./fonts/chivo/Chivo-Regular.ttf"); }

@font-face { font-family: ChivoBlack; src: url("./fonts/chivo/Chivo-Black.ttf"); }
@font-face { font-family: ChivoBlack; src: url("./fonts/chivo/Chivo-BlackItalic.ttf"); font-style: italic; }

@font-face { font-family: ChivoLight; src: url("./fonts/chivo/Chivo-Light.ttf"); }
@font-face { font-family: ChivoLight; src: url("./fonts/chivo/Chivo-LightItalic.ttf"); font-style: italic; }

@font-face { font-family: Inconsolata; src: url("./fonts/inconsolata/Inconsolata-Bold.ttf"); font-weight: bold; }
@font-face { font-family: Inconsolata; src: url("./fonts/inconsolata/Inconsolata-Regular.ttf"); }

@font-face { font-family: RobotoBlack; src: url("./fonts/roboto/Roboto-Black.ttf"); }
@font-face { font-family: RobotoBlack; src: url("./fonts/roboto/Roboto-BlackItalic.ttf"); font-style: italic; }

@font-face { font-family: Roboto; src: url("./fonts/roboto/Roboto-Bold.ttf"); font-weight: bold; }
@font-face { font-family: Roboto; src: url("./fonts/roboto/Roboto-BoldItalic.ttf"); font-weight: bold; font-style: italic; }
@font-face { font-family: Roboto; src: url("./fonts/roboto/Roboto-Italic.ttf"); font-style: italic; }
@font-face { font-family: Roboto; src: url("./fonts/roboto/Roboto-Regular.ttf"); }

@font-face { font-family: RobotoLight; src: url("./fonts/roboto/Roboto-Light.ttf"); }
@font-face { font-family: RobotoLight; src: url("./fonts/roboto/Roboto-LightItalic.ttf"); font-style: italic; }

@font-face { font-family: RobotoMedium; src: url("./fonts/roboto/Roboto-Medium.ttf"); }
@font-face { font-family: RobotoMedium; src: url("./fonts/roboto/Roboto-MediumItalic.ttf"); font-style: italic; }

@font-face { font-family: RobotoThin; src: url("./fonts/roboto/Roboto-Thin.ttf"); }
@font-face { font-family: RobotoThin; src: url("./fonts/roboto/Roboto-ThinItalic.ttf"); font-style: italic; }

@font-face { font-family: RobotoCondensed; src: url("./fonts/robotocondensed/RobotoCondensed-Bold.ttf"); font-weight: bold; }
@font-face { font-family: RobotoCondensed; src: url("./fonts/robotocondensed/RobotoCondensed-BoldItalic.ttf"); font-weight: bold; font-style: italic; }
@font-face { font-family: RobotoCondensed; src: url("./fonts/robotocondensed/RobotoCondensed-Italic.ttf"); font-style: italic; }
@font-face { font-family: RobotoCondensed; src: url("./fonts/robotocondensed/RobotoCondensed-Regular.ttf"); }

@font-face { font-family: RobotoCondensedLight; src: url("./fonts/robotocondensed/RobotoCondensed-Light.ttf"); }
@font-face { font-family: RobotoCondensedLight; src: url("./fonts/robotocondensed/RobotoCondensed-LightItalic.ttf"); font-style: italic; }

@font-face { font-family: LogicTwentyFive; src: url("./fonts/Logic twenty-five A.ttf"); }

body,table,input { font: 10pt Roboto; }
body { width: 7.5in; margin-left: auto; margin-right: auto; counter-reset: h2counter; }
div.code { white-space: pre; font: 10pt Inconsolata; background-color: #E1F1F7; border: 1px dashed #3C607B; margin-top: 1em; margin-bottom: 1em; padding: 1em; clear: both; }
code { font: bold 10pt Inconsolata; }
pre { font: 10pt Inconsolata; }
.beta { color: #A00; }
p,li { text-align: justify; }
.fixme { color: #A00; background-color: #FF0; font-weight: bold; }
a { text-decoration: none; }

h1 { counter-reset: h2counter; font: 36pt ChivoBlack; position: relative; color: #3C607B; top: 36pt; text-shadow: 2pt 2pt 2pt #AAA; }
h2 { counter-reset: h3counter; font-size: 22pt; color: white; background-color: #3C607B; padding: 0.25em 0.0em 0.25em 0.5em; margin-top: 2.5em; margin-bottom: 0.6em; font-family: ChivoBlack; border-top-right-radius: 40px; text-shadow: 2pt 2pt #263E4F; }
h3 { counter-reset: h4counter; font-size: 14pt; color: white; background-color: #3C607B; margin-top: 2em; margin-bottom: 0.5em; padding: 0.15em 0.15em 0.15em 0.35em; font-family: Chivo; }
h4 { counter-reset: h5counter; font-size: 14pt; color: #263E4F; margin-top: 1.5em; margin-bottom: 0.3em; border-bottom: 1.5pt solid #263E4F; font-family: Chivo; }
h5 { font-size: 13pt; color: #263E4F; margin-top: 1em; margin-bottom: 0.4em; font-family: Chivo; }
h6 { font-size: 11pt; color: #263E4F; margin-top: 1em; margin-bottom: 0.4em; font-family: Chivo; font-weight: bold; }

span.h2num { margin: 0pt 0pt 36pt 12pt; font: 144pt LogicTwentyFive; float: right; position: relative; bottom: 18pt; left: 13pt; color: #3C607B; }
span.h2num:before { content: counter(h2counter); }

h2:before { counter-increment: h2counter; content: counter(h2counter) "\0000a0\0000a0";                                               }
h3:before { counter-increment: h3counter; content: counter(h2counter) "." counter(h3counter) "\0000a0\0000a0";                        }
h4:before { counter-increment: h4counter; content: counter(h2counter) "." counter(h3counter) "." counter(h4counter) "\0000a0\0000a0"; }

div.h1 { margin-left: 0em; counter-reset: toc2counter; }
div.h2 { margin-left: 0em; counter-reset: toc3counter; font: bold 13pt Chivo; margin-top: 0.75em; }
div.h3 { margin-left: 1em; counter-reset: toc4counter; font: bold 12pt Chivo; margin-top: 0.25em; }
div.h4 { margin-left: 2em; counter-reset: toc5counter; font: 11pt Chivo; }
div.h5 { margin-left: 3em; font: 10pt Chivo; }

div.h2:before { counter-increment: toc2counter; content: counter(toc2counter) "\0000a0\0000a0";                                               }
div.h3:before { counter-increment: toc3counter; content: counter(toc2counter) "." counter(toc3counter) "\0000a0\0000a0";                        }
div.h4:before { counter-increment: toc4counter; content: counter(toc2counter) "." counter(toc3counter) "." counter(toc4counter) "\0000a0\0000a0"; }

p { margin-top: 0em; margin-bottom: 0.75em; }
ul.spacious li { padding-top: 0.5em; }
ol.spacious li { padding-top: 0.5em; }

table.matrixDemo { background-color: black; border-spacing: 1pt; margin-left: auto; margin-right: auto; font-size: 90%; margin-top: 1em; margin-bottom: 2em; }
table.matrixDemo th { color: white; width: 20%; padding: 0.5em; }
table.matrixDemo td { background-color: white; vertical-align: top; padding: 0.25em; }
table.matrixDemo td.implicit { background-color: #CCC; }
table.matrixDemo td.scale { background-color: #FAA; }
table.matrixDemo td.translate { background-color: #AAF; }
table.matrixDemo td.skew { background-color: #AFA; }
table.matrixDemo td.rotate { background-color: #FAA; }
table.matrixDemo td.ident { background-color: #AAF; }
table.matrixDemo td.null { background-color: #CCC; }
table.matrixDemo div.cpName { text-align: center; font: bold 10pt Inconsolata; }
table.matrixDemo div.op { text-align: center; font-weight: bold; margin-top: 0.25em; }

table.sgrid { background-color: #263E4F; border-spacing: 1pt; margin-top: 0.5em; }
table.sgrid > thead { color: white; }
table.sgrid > tbody { background-color: white; }
table.sgrid > td { padding-left: 0.5em; padding-right: 0.5em; vertical-align: top; }
table.sgrid th { background-color: #3C607B; }

table.todo { width: 100%; }
table.todo td.pending { text-align: center; background-color: #A00;    color: yellow; font-weight: bold; white-space: nowrap; }
table.todo td.working { text-align: center; background-color: yellow;  color: #A00;   font-weight: bold; white-space: nowrap; }
table.todo td.done    { text-align: center; background-color: #060;    color: white;  font-weight: bold; white-space: nowrap; }
table.todo td.tbd     { text-align: center; background-color: #3C607B; color: white;  font-weight: bold; white-space: nowrap; }
table.todo td.subtask { padding-left: 3em; }

table.attrs { width: 100%; font-family: RobotoCondensed; }
table.attrs > tbody > tr > td { padding: 0.25em; }
table.attrs > tbody > tr > td:nth-child(1) { white-space: pre; text-align: center; }
table.attrs > tbody > tr > td:nth-child(2) { text-align: center; }
table.attrs > tbody > tr > td:nth-child(3) { font-family: Inconsolata; font-weight: bold; }
table.attrs > tbody > tr > td:nth-child(4) { font-family: Inconsolata; }
table.attrs > tbody > tr > td:nth-child(5) { padding-left: 0.5em; padding-right: 0.5em; white-space: normal; font-family: RobotoCondensed; width: 100%; }
table.attrs > tbody > tr > td { vertical-align: top; }
table.attrs > tbody > tr > td.dummy { color: #888; background-color: #FFE; }
table.attrs > tbody > tr > td.niy { color: #A00; font: bold 10pt Roboto; }

table.codeDoc { margin-left: auto; margin-right: auto; margin-bottom: 1em; font-family: RobotoCondensed;}
table.codeDoc td { text-align: left; padding-left: 0.5em; padding-right: 0.5em; }
table.codeDoc > tbody > tr > td:nth-child(1) { text-align: center; font-weight: bold; }

div.fsig { font: bold 10pt Inconsolata; margin-bottom: 0.3em; margin-top: 1em; }
p+div.fsig { margin-top: 1.25em; }
.fdesc { margin-left: 1em; }

table.illusBasic td { vertical-align: top; }
table.illusBasic td.infinite { padding-left: 1em; }
</style>

<script src="jquery-3.3.1.min.js"></script>

<script>

function buildTOC() {
    var content = [ ];
    $("h1,h2,h3,h4").each(function(idx) {
        var parts = $(this).html().split("\0000a0\0000a0");
        var name = "toc" + parts[0];
        name = name.replace(/\./g, "_");
        $(this).before("<a name='" + name + "'></a>");
        content.push("<div class='" + this.tagName.toLowerCase() + "'><a href='#" + name + "'>" + $(this).html() + "</a></div>");
    });
    $("#toc").html(content.join("\n"));
    $("div.h1").html("");
}

$(document).ready(function() {
    buildTOC();
});

</script>

</head>
<body>
<img src='cplogo_small.png' style='float: right; margin-left: 1em; margin-bottom: 1em; position: relative; top: 12pt;'>
<h1>CephaloPOV v0.1&alpha;<br/>User's Manual</h1>

<h2>Introduction</h2>

<p><span class='h2num'></span>CephaloPOV is a JavaScript scripting engine for POV-Ray. It is implemented as
a Node command line program that loads a user script and executes it in an
environment in which it can manipulate various JavaScript classes that map to
POV-Ray's native objects, in addition to having full access to the Node
ecosystem. CephaloPOV takes care of generating POV-Ray Scene Description
Language files, both for static scenes and multi-frame animations.</p>

<p><i>The documentation as it stands is more or less complete as far as CephaloPOV
itself is concerned, but the longer-term goal of being self-sufficient without
requiring familiarity with POV-Ray is still a good ways away.</i></p>

<h3>Table of Contents</h3>

<div id='toc'></div>

<h3>What you need (and don't need) to know</h3>

<p>One of the major design goals of CephaloPOV is to be accessible to anyone who
has basic competency in JavaScript without requiring prior experience with
POV-Ray or having to know its Scene Description Language (SDL). However, POV-Ray
is an enormous program with a vast array of features, and it will be quite some
time before this manual is a complete substitute for POV-Ray's own extensive
documentation. In the meantime, POV-Ray novices should refer to the <a
href="http://povray.org/documentation/3.7.0/index.html">official
documentation</a>.</p>

<p>Having said all that, another major design goal of CephaloPOV is to interoperate
as smoothly as possible with SDL. You can use existing SDL code with (and within)
CephaloPOV JavaScript code, and it is easy to go the other way, incorporating
the output of CephaloPOV scripts into SDL.</p>

<p>As far as JavaScript expertise goes, you can get by with a basic knowledge of
the language. CephaloPOV uses ES6 classes instead of bare prototypes for most
things, but unless you intend to extend them, you can treat them just like
prototypes. If you're a JavaScript expert, you can of course do much more than a
beginner, but that is a simple matter of programmer skill and not a matter of
CephaloPOV's API.</p>

<p>POV-Ray is a non-interactive 3D graphics program, so knowledge of analytic
geometry will always be to your advantage, but both POV-Ray and CephaloPOV are
designed to be usable to anyone who understands three-dimensional Cartesian
coordinates. <span class='ephemeral'>In the future, CephaloPOV will offer a
sophisticated but easy-to-use geometric query system that will let you leverage
quite complex math without having to understand the details, but that's still
a ways off.</span></p>


<h2>Tutorial</h2>

<p><span class='h2num'></span>This section will take you step-by-step through
learning how to use CephaloPOV and all its features. It will be, sadly, likely the
last section to be completed.</p>

<p><br/><br/><br/><br/></p>

<h2>Reference</h2>

<p><span class='h2num'></span>The reference section contains a complete summary
of the CephaloPOV API.</p>

<p><br/><br/><br/><br/><br/><br/><br/></p>

<h3>Documentation Conventions</h3>

<p>Code and literals in body text are distinguished by the use of a
<code>fixed-pitch font</code>. Blocks of code appear in boxes like the
one below:</p>

<div class='code'>cpov.primitiveDefIdentifier = function(obj) {
    var result = [ ];
    result.push("#" + obj.serial);
    if(obj.id !== null)
        result.push(obj.id);
    return result.join(":");
}</div>

<p>Most tables of object attributes have a standard set of columns:</p>

<ol class="spacious">

<li>The first (unlabeled) column specifies the read and write permissions
of the attribute, <code>RO</code> for read-only or <code>RW</code> for
read-write.</li>

<li><em>Req:</em> Indicates whether the field is required using <code>Y</code>
or <code>N</code>. This is left blank for read-only attributes.</li>

<li><em>Name:</em> Gives the name of the attribute. This is left unqualified
in object class descriptions, but where the global <code>cpov</code> object
is described, it is given in full, e.g., <code>cpov.currentFrame</code>.</li>

<li><em>Type(s):</em> Lists the type or types accepted by the setter function.
This is usually a single type, but if multiple types are accepted, they will
be listed one after the other.</li>

<li><em>Description:</em> Contains the full details you'll need to use the
attribute, including default values, if any.</li>

</ol>

<h3>API Conventions</h3>

<h4>Naming</h4>

<p>To make things easier for experienced POV-Ray users, the
<code>snake_cased</code> names of objects and properties in SDL, with a few
exceptions (mostly truncations), are converted directly into the
camelCased names which are the norm in JavaScript. Class names
begin with a capital letter, so <code>julia_fractal</code> becomes
<code>JuliaFractal</code>.

<h4>Type Discipline</h4>

<p>To avoid making the user painfully debug cases where CephaloPOV accepts an
erroneous value and writes it into the SDL output files, CephaloPOV imposes a
stricter type discipline than the default JavaScript type system:</p>

<ul class='spacious'>

    <li>The most important rule is that primitive types are <em>never</em>
    silently converted to other types. If a parameter or method calls for a
    string and you pass a number (or vice versa), you'll get a fatal error. The
    string <code>"2"</code> and the number <code>2</code> are as different in
    CephaloPOV as if it had been written in C.</li>

    <li>CephaloPOV is particularly picky about numbers. JavaScript has only one
    numeric type, <code>Number</code>, which is internally a double-precision
    floating point number. CephaloPOV, however, distinguishes between floats and
    integers. If the API expects an integer, you must pass a whole number;
    fractional values will be rejected. This is to avoid the unexpected behavior
    that might come from truncating or rounding the fractional part.</li>

    <li>The big exception to all this is that the constructors for nearly all of
    the classes take optional shortcut forms for the sake of convenience. In
    most cases, this is an ordered list of the minimum required arguments, e.g.,
    <code>corner1</code> and <code>corner2</code> for a <code>Box</code>.</li>

    <li>The other exception concerns the various <code>Vector*</code>,
    <code>Color</code>, and <code>Matrix</code> types which are heavily used
    throughout the API. For example, anywhere a <code>VectorXYZ</code> is
    required, you can pass a three-element array of floats&mdash;<code>[ 0, 1,
    2.3 ]</code>&mdash;to avoid the tedious boilerplate code of explicitly
    instantiating the class.</li>

    <li>All parameters are initialized to <code>null</code> and can be set to
    <code>null</code> at any time, with the caveat that required parameters must
    have non-<code>null</code> values at output time. Optional parameters with
    <code>null</code> values are not output and thus have their default values
    from POV-Ray's perspective.</li>

</ul>

<h4>Type Indiscipline</h4>

<p>The type discipline that CephaloPOV imposes is useful from the standpoint of
avoiding careless bugs, but it is only enforced upon static data. In almost
every case, object parameters in CephaloPOV can be replaced with either
JavaScript callback functions or SDL functions.</p>

<p>SDL functions are specified as strings beginning with <code>"&"</code>. (The
leading ampersand is stripped off before output.) CephaloPOV presently has no way
of determining the validity of SDL code, so you'll need to know exactly what you're
doing. This also means that CephaloPOV can't use SDL functions in its internal
calculations. For example, if you assign an SDL function returning a vector to
an object parameter, that object cannot be transformed within CephaloPOV.</p>

<p>JavaScript parameters are somewhat easier to deal with. Each callback is
called as needed with the global <code>cpov</code> object and the object it
belongs to, e.g.:</p>

<div class='code'>yourFunction(cpov, obj);</div>

<p>On the receiving end, getting the return type right is left to the user as
CephaloPOV does not perform any validation tests upon it. CephaloPOV may also
call user functions at any time, so they should not have any side-effects or
internal state. Unlike SDL function strings, the return values of user functions
<em>can</em> be used in calculations just like a static value, but beware of
cases where an operation writes a value back to the
parameter&mdash;transformations are a good example&mdash;which will result in
the dynamic user function being replaced by a static value. All that said, with
a little care, JavaScript callbacks can be an incredibly powerful tool.</p>

<p>To get around the limitations on side-effects and internal state, remember
that every <code>Primitive</code> object has two callback methods,
<code>frameBegin</code> and <code>frameEnd</code>. These methods are guaranteed
to only be called by CephaloPOV at the beginning and end of a frame, exactly
once for each object.</p>

<h3>The Animation Cycles</h3>

<p>From CephaloPOV's perspective, every user program is an animation. Static
scenes are just animations with a single frame. If you're only making static
scenes, you don't need to know much about the animation features beyond setting
up a scene and triggering its output. Conversely, once you know how to create
static scenes, there's not much more you have to know in order to create
animations.</p>

<p>One of the major design goals of CephaloPOV was to have more flexible options
than POV-Ray's native animation system which, while more than adequate for many
animations, can be awkward for others. Consequently, there are two main ways to
produce animations in CephaloPOV:</p>

<ul class='spacious'>

    <li><b>Snapshot Mode:</b> In snapshot mode, which is triggered by setting
    <code>cpov.snapshotMode</code> to <code>true</code>, the user provides the
    main loop. Objects are created and destroyed as needed, but they remain
    invisible until their <code>snapshot</code> methods are called. When
    <code>cpov.outputFrame()</code> is called, the <code>.pov</code> file for
    the frame is output. This mode is often used for still scenes as well. It is
    important to remember that object <code>active</code> flags are still
    respected in snapshot mode.</li>

    <li><b>Automatic Mode:</b> In automatic mode, the user program does not call
    <code>cpov.outputFrame()</code> directly; instead, it hands off control to
    <code>cpov.runAnimation()</code>. Before each frame is output, the
    <code>cpov.frameBegin</code> callback function is called, followed by each
    object's own <code>frameBegin</code> callbacks. The frame is then output.
    Afterwards, each object's <code>frameEnd</code> callback is called, followed
    by the global <code>cpov.frameEnd</code> callback. Finally, both the animation
    time clock variable, <code>cpov.clockTime</code> is incremented by <code>cpov.tickVal</code>,
    and the frame number, <code>cpov.currentFrame</code>, is incremented. The cycle
    repeats until any of the callbacks invokes <code>cpov.endAnimation</code>.</li>

</ul>

<p>Aside from the greater flexibility of writing procedural code in JavaScript
instead of SDL, having both a time counter and a frame counter in automatic mode
can make certain kinds of animations and programming styles easier. At the same
time, the ability to work within the implicit Newtonian time of the native
POV-Ray animation system is preserved.</p>

<h4>Animation Parameters</h4>

<p>The animation loop is configured through attributes of the global <code>cpov</code>
object. All of them are directly writeable by the user program, but some of them should
be manipulated with care as noted in the table below.</p>

<div>
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>cpov.clockTime</td><td>float</td><td>This attribute holds the current clock time for the animation. It defaults to <code>0.0</code>.</td></tr>
<tr><td>RW</td><td>Y</td><td>cpov.currentFrame</td><td>integer</td><td>The number of the current frame. In most cases, you should treat this as a read-only value, but there is no reason you can't at least change it to a higher number to skip frames if you do it at the end of the animation loop.</td></tr>
<tr><td>RW</td><td>Y</td><td>cpov.endFrame</td><td>integer</td><td>The user program will halt if and when <code>cpov.currentFrame</code> is greater than this number. Defaults to <code>Infinity</code>.</td></tr>
<tr><td>RW</td><td>Y</td><td>cpov.endTime</td><td>float</td><td>The user program will halt if and when <code>cpov.clockTime</code> is greater than this number. Defaults to <code>Infinity</code>.</td></tr>
<tr><td>RW</td><td>Y</td><td>cpov.frameBegin</td><td>function</td><td>This is a user-supplied callback function which is called at the beginning of the animation loop. It is passed the global <code>cpov</code> object as its sole argument.</td></tr>
<tr><td>RW</td><td>Y</td><td>cpov.frameEnd</td><td>function</td><td>This is a user-supplied callback function which is called at the end of the animation loop. It is passed the global <code>cpov</code> object as its sole argument.</td></tr>
<tr><td>RW</td><td>Y</td><td>cpov.outputBase</td><td>string</td><td>The generated <code>.pov</code> and <code>.ini</code> filenames will be based on this template, which defaults to <code>cpov0000</code>. The first sequence of zeroes in the template string will be replaced with the frame number, left-padded with to the same number of digits as the zero sequence.</td></tr>
<tr><td>RW</td><td>Y</td><td>cpov.snapshotMode</td><td>boolean</td><td>If <code>true</code>, puts CephaloPOV in snapshot mode.</td></tr>
<tr><td>RW</td><td>Y</td><td>cpov.snapshots</td><td>array</td><td>This is an array containing the output SDL strings which will be written to the <code>.pov</code> file at the end of the frame loop. Normally read-only, but if you know what you're doing, feel free to <code>push()</code> additional content to it.</td></tr>
<tr><td>RW</td><td>Y</td><td>cpov.startFrame</td><td>integer</td><td>The user program will run but not produce any output until <code>cpov.currentFrame</code> is greater than or equal to this number. Defaults to <code>0</code>.</td></tr>
<tr><td>RW</td><td>Y</td><td>cpov.startTime</td><td>float</td><td>The user program will run but not produce any output until <code>cpov.clockTime</code> is greater than or equal to this number. Defaults to <code>0</code>.</td></tr>
<tr><td>RW</td><td>Y</td><td>cpov.tickVal</td><td>float</td><td>Contains the value added to <code>cpov.clockTime</code> after each iteration of the animation loop. Defaults to <code>1.0</code>.</td></tr>
</tbody>
</table>

<h4>Snapshot Mode</h4>

<p>Snapshot mode is arguably the easier of the two animation modes to get
started with, especially if the animation is simple or you want to construct
your own animation loop to suit your needs. Just set
<code>cpov.snapshotMode</code> to <code>true</code>, which disables the built-in
loop.</p>

<div class="code">cpov.snapshotMode = true;</div>

<p>All you need to do after that is create your objects and call their
<code>snapshot</code> methods. If you move them afterwards, you can call
<code>snapshot</code> again to "plot" them in their new positions. And once
you've created a snapshot of every object you want in the frame, call
<code>cpov.outputFrame</code> to generate the
<code>.pov</code>/<code>.ini</code> files and clear the snapshot buffer.</p>

<p>Two things are important to remember in snapshot mode. First, your light
sources and cameras are objects themselves, so you have to remember to add their
snapshots to the buffer in each frame. Second, objects don't magically cease to
exist if you only use them once. This may not matter much in short, simple
animations, but if you are creating a lot of single-use objects, you'll want to
call their <code>destroy</code> methods to avoid filling up memory.</p>

<p>The script that generates the illustrations for this documentation uses
snapshot mode. Here's a somewhat simplified version of what it does. (See <code>/docs/illus.js</code>
if you want to dig into the full, somewhat hairy details.) First, it just does
the usual setup and housekeeping, the only germane part of which is the first
line that activates snapshot mode:</p>

<div class="code"><b>cpov.snapshotMode                = true;  // Don't forget this part</b>
cpov.imageOptions.height         = 320;
cpov.imageOptions.width          = 320;
cpov.imageOptions.outputFileType = "N";
cpov.imageOptions.createIni      = true;
cpov.imageOptions.outputAlpha    = true;
cpov.imageOptions.antialias      = true;
cpov.imageOptions.antialiasDepth = 9;
cpov.globalSettings.ambientLight = [0.25, 0.25, 0.25];</div>

<p>Then it creates the generic texture string that all of the object examples
reuse, and it calls an undocumented internal function to produce the stage
objects, which come as an array with two members, the stage and lights, and the
camera. We go ahead and push those right into the snapshot buffer.</p>

<div class='code'>var texture = "texture { pigment { color <1, 1, 0> }}";
var stage   = cpov.testStage("corner", 6);
stage[0].snapshot();
stage[1].snapshot();</div>

<p>Because this isn't actually an animation, the script sets <code>cpov.outputBase</code>
at the beginning of each "frame" to make it easier to find the files. (I'm mentioning
this to point out that snapshot mode is also a convenient way to crank out a bunch of
static images.)</p>

<div class="code">cpov.outputBase = "./docs/src/box_basic";</div>

<p>Now we can get down to business and create our example box:</p>

<div class="code">var obj = new Box({
    corner1: [2,2,2],
    corner2: [-2, -2, -2],
    texture: texture
});
obj.snapshot();</div>

<p>And that's it as far as objects go. We just need to output the frame and clean
up after ourselves:</p>

<div class="code">cpov.outputFrame();  // This outputs box_basic.pov and box_basic.ini
obj.destroy();</div>

<p>Naturally, if you're only doing a single frame or a short animation with
relatively few objects, you don't have to bother with calling
<code>destroy</code>, but it's a good habit to get into before you start working
on more ambitious projects.</p>


<h4>Automatic Mode</h4>

<p>Automatic mode is not actually any harder to use than snapshot mode. In fact,
it's a lot easier because it automates a lot of the stuff you'd otherwise have
to do manually, but it does require you to understand the CephaloPOV animation
loop, at least if you want to avoid tying yourself into knots. Let's just get
that out of the way first:</p>

<ol class="spacious">
    <li>The global <code>cpov.frameBegin</code> callback is called.</li>
    <li>Each object's individual <code>frameBegin</code> callback is called.</li>
    <li>All <code>active</code> objects are written to file by <code>cpov.outputFrame</code>.</li>
    <li>Each object's individual <code>frameEnd</code> callback is called.</li>
    <li>The global <code>cpov.frameEnd</code> callback is called.</li>
    <li>The <code>cpov.clockTime</code> is incremented by <code>cpov.tickVal</code> and <code>cpov.currentFrame</code> is incremented.</li>
</ol>

<p>This loop starts when your program calls <code>cpov.runAnimation</code> and
continues until either your program calls <code>cpov.endAnimation</code>,
<code>cpov.clockTime</code> exceeds <code>cpov.endTime</code>, or
<code>cpov.currentFrame</code> exceeds <code>cpov.endFrame</code>. Besides
setting up the initial scene, all you have to do is write the necessary
<code>beginFrame</code> and <code>endFrame</code> callbacks.</p>


<h5>Callbacks</h5>

<p>As far as the callbacks are concerned, how you want to structure things is up
to you. If you want, you can stuff all of your logic into
<code>cpov.beginFrame</code> and/or <code>cpov.endFrame</code>. You can also
leave them set to <code>null</code> and pack everything into the
<code>beginFrame</code> and <code>endFrame</code> methods of individual objects.
You can also use both. CephaloPOV is not opinionated about your code.</p>

<p>All of the callbacks are the same. Each one is called with a single argument,
the global <code>cpov</code> object, which it can then interrogate to determine
the current clock value and frame number, as well as use
<code>cpov.serialMap</code> or <code>cpov.idMap</code> to find other objects.
You can feel free to attach additional data and function members to
<code>cpov</code> as well.</p>

<h5>Using the Clock and the Frame Count</h5>

<p>The animation clock, <code>cpov.clockTime</code>, is a continuous
floating-point value that is incremented by <code>cpov.tickVal</code> at the end
of each frame and measures time inside the animation. The current frame number,
<code>cpov.currentFrame</code>, is a discrete integer value that increases by
one at the end of each frame, and which effectively measures the number of times
that the simulated world of the animation has been sampled.</p>

<p>You can just use one or the other if your needs are simple enough, but the
combination of the two is powerful enough to make it worth understanding their
relationship. [TODO]</p>


<h3>Global Parameters</h3>

<p>POV-Ray has two sets of global parameters which remain separate here. The
first, represented in CephaloPOV by the <code>cpov.imageOptions</code> object,
corresponds to POV-Ray's command line switches and the contents of
<code>.ini</code> files. The second is the <code>global_settings</code> block in
<code>.pov</code> scene files, which is represented by
<code>cpov.globalSettings</code>.</p>

<!-- From the standpoint of CephaloPOV, there doesn't appear to be a compelling
reason to keep these separate, so the interface may be refactored in the future.
-->

<h4>ImageOptions</h4>

<p>The <code>ImageOptions</code> class represents the global parameters that are
set either by POV-Ray command line switches or by <code>.ini</code> files.
CephaloPOV itself never uses the command line switches, but they are output in a
comment at the beginning of the generated <code>.ini</code> files for the
curious. It should be noted that not all of the values that can be set in a
<code>.ini</code> file have corresponding command line switches.</p>

<p>By default, CephaloPOV initializes <code>cpov.imageOptions</code> with an
<code>ImageOptions</code> object at the beginning of a job. You can create
additional <code>ImageOptions</code> objects, but only the one assigned to
<code>cpov.imageOptions</code> when <code>cpov.outputFrame()</code> is called is
actually used.</p>

<p>All of the parameters are optional except for <code>height</code> and
<code>width</code>.</p>

<h5>Attributes</h5>

<div dh="ImageOptions">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>height</td><td>integer</td><td>Height of output image in pixels.</td></tr>
<tr><td>RW</td><td>Y</td><td>width</td><td>integer</td><td>Width of output image in pixels.</td></tr>
<tr><td>RW</td><td>N</td><td>allConsole</td><td>boolean</td><td>If <code>true</code>, POV-Ray debug messages, fatal errors, rendering info, statistics, and warnings are sent to the console.</td></tr>
<tr><td>RW</td><td>N</td><td>allFile</td><td>boolean<br/>string</td><td>If <code>true</code>, POV-Ray debug messages, fatal errors, rendering info, statistics, and warnings are written to <code>ALLTEXT.OUT</code>. Alternatively, a custom filename may be specified here.</td></tr>
<tr><td>RW</td><td>N</td><td>antialias</td><td>boolean</td><td>If <code>true</code>, enables antialiasing.</td></tr>
<tr><td>RW</td><td>N</td><td>antialiasDepth</td><td>integer</td><td>Specifies the number of rows and columns within each pixel to be super-sampled. Values in the range 1-9 are permitted, and the default is 3.</td></tr>
<tr><td>RW</td><td>N</td><td>antialiasGamma</td><td>float</td><td>Sets the gamma to be used in antialiasing.</td></tr>
<tr><td>RW</td><td>N</td><td>antialiasThreshold</td><td>float</td><td>Defines the amount by which a pixel must differ from its neighbors to trigger supersampling. The default is 0.3.</td></tr>
<tr><td>RW</td><td>N</td><td>appendFile</td><td>boolean</td><td>If <code>true</code>, output from the various runtime log files will be appended to existing files. If <code>false</code>, runtime log files will be overwritten.</td></tr>
<tr><td>RW</td><td>N</td><td>bitsPerColor</td><td>integer</td><td>Specifies the number of bits per color channel in the image file. This only affects PNG and PNM output, which allow 5-16 bits per channel.</td></tr>
<tr><td>RW</td><td>N</td><td>bounding</td><td>boolean</td><td>If <code>true</code> (the default), turns automatic bounding control on.</td></tr>
<tr><td>RW</td><td>N</td><td>boundingMethod</td><td>integer</td><td>If set to 1 (the default), the POV-Ray 3.0+ automatic bounding system is used. If set to 2, the new (and very much beta) Binary Space Partitioning method is used.</td></tr>
<tr><td>RW</td><td>N</td><td>boundingThreshold</td><td>integer</td><td>Sets the minimum number of objects that must be in a scene before automatic bounding control is used. Defaults to 25.</td></tr>
<tr><td>RW</td><td>N</td><td>bspBaseAccessCost</td><td>float</td><td>Parameter for the beta Binary Space Partioning System. See <a href="http://www.realtimerendering.com/resources/RTNews/html/rtnv17n1.html#art8">this article</a> for details.</td></tr>
<tr><td>RW</td><td>N</td><td>bspChildAccessCost</td><td>float</td><td>Parameter for the beta Binary Space Partioning System. See <a href="http://www.realtimerendering.com/resources/RTNews/html/rtnv17n1.html#art8">this article</a> for details.</td></tr>
<tr><td>RW</td><td>N</td><td>bspIsectCost</td><td>float</td><td>Parameter for the beta Binary Space Partioning System. See <a href="http://www.realtimerendering.com/resources/RTNews/html/rtnv17n1.html#art8">this article</a> for details.</td></tr>
<tr><td>RW</td><td>N</td><td>bspMaxDepth</td><td>float</td><td>Parameter for the beta Binary Space Partioning System. See <a href="http://www.realtimerendering.com/resources/RTNews/html/rtnv17n1.html#art8">this article</a> for details.</td></tr>
<tr><td>RW</td><td>N</td><td>bspMissChance</td><td>float</td><td>Parameter for the beta Binary Space Partioning System. See <a href="http://www.realtimerendering.com/resources/RTNews/html/rtnv17n1.html#art8">this article</a> for details.</td></tr>
<tr><td>RW</td><td>N</td><td>debugConsole</td><td>boolean</td><td>If <code>true</code>, POV-Ray debug messages are sent to the console.</td></tr>
<tr><td>RW</td><td>N</td><td>debugFile</td><td>boolean<br/>string</td><td>If <code>true</code>, POV-Ray debug messages are written to <code>DEBUG.OUT</code>. Alternatively, a custom filename may be specified here.</td></tr>
<tr><td>RW</td><td>N</td><td>display</td><td>boolean</td><td>If <code>true</code>, the image in progress will be displayed during rendering.</td></tr>
<tr><td>RW</td><td>N</td><td>displayGamma</td><td>float<br/>string</td><td>A float defining the gamma to be used by the display during rendering or the string <code>"sRGB"</code> (roughly 2.2).</td></tr>
<tr><td>RW</td><td>N</td><td>dither</td><td>boolean</td><td>If <code>true</code> (the default is <code>false</code>), output dithering is used.</td></tr>
<tr><td>RW</td><td>N</td><td>ditherMethod</td><td>string</td><td>Sets the dithering algorithm if dithering is turned on. The supported values are:
<table class="sgrid codeDoc">
<thead>

<tr><th>Code</th><th>Meaning</th></tr>
</thead><tbody>
<tr><td>B2</td><td>Bayer pattern 2x2</td></tr>
<tr><td>B3</td><td>Bayer pattern 3x3</td></tr>
<tr><td>B4</td><td>Bayer pattern 4x4</td></tr>
<tr><td>D1</td><td>Simple error diffusion 1D</td></tr>
<tr><td>D2</td><td>Simple error diffusion 2D</td></tr>
<tr><td>FS</td><td>Floyd-Steinberg error diffusion</td></tr>
</tbody></table>
</td></tr>
<tr><td>RW</td><td>N</td><td>endColumn</td><td>integer<br/>float</td><td>Forces the end of output at the specified column if an integer is supplied or a fraction of screen width if a float in the unit interval (0.n) is supplied.</td></tr>
<tr><td>RW</td><td>N</td><td>endRow</td><td>integer<br/>float</td><td>Forces the end of output at the specified row if an integer is supplied or a fraction of screen height if a float in the unit interval (0.n) is supplied.</td></tr>
<tr><td>RW</td><td>N</td><td>exePath</td><td>string</td><td>This should contain the full path to the POV-Ray executable if it is not in the system path.</td></tr>
<tr><td>RW</td><td>N</td><td>fatalConsole</td><td>boolean</td><td>If <code>true</code>, POV-Ray fatal error messages are sent to the console.</td></tr>
<tr><td>RW</td><td>N</td><td>fatalErrorCommand</td><td>string</td><td>Shell command to execute when POV-Ray encounters a fatal error.</td></tr>
<tr><td>RW</td><td>N</td><td>fatalErrorReturn</td><td>string</td><td>Specifies the action to take when a fatal error occurs during the exectuion of the <code>fatalErrorCommand</code>. Action codes may be prefixed with "<code>-</code>" or "<code>!</code> to negate the action. The legal codes are
<table class="sgrid codeDoc">
<thead>

<tr><th>Code</th><th>Meaning</th></tr>
</thead><tbody>
<tr><td>A</td><td>all steps skipped</td></tr>
<tr><td>F</td><td>generate a fatal error in POV-Ray</td></tr>
<tr><td>I</td><td>ignore code</td></tr>
<tr><td>Q</td><td>quit POV-Ray immediately</td></tr>
<tr><td>S</td><td>skip one step</td></tr>
<tr><td>U</td><td>generate a user abort in POV-Ray</td></tr>
</tbody></table>
</td></tr>
<tr><td>RW</td><td>N</td><td>fatalFile</td><td>boolean<br/>string</td><td>If <code>true</code>, POV-Ray fatal error messages are written to <code>FATAL.OUT</code>. Alternatively, a custom filename may be specified here.</td></tr>
<tr><td>RW</td><td>N</td><td>fileGamma</td><td>float<br/>string</td><td>Sets the display target gamma for the output file. This may be given as either a float or the string <code>"sRGB"</code> (approx. 2.2).</td></tr>
<tr><td>RW</td><td>N</td><td>highReproducibility</td><td>boolean</td><td>If <code>true</code>, enables the experimental high reproducibility mode, which attempts to impose determinism on calculations in SMP environments. Currently only works with radiosity.</td></tr>
<tr><td>RW</td><td>N</td><td>includeHeader</td><td>string</td><td>Specifies an SDL include file to be referenced in the SDL output.</td></tr>
<tr><td>RW</td><td>N</td><td>inputFileName</td><td>string</td><td>Explicitly sets an input .pov file name.</td></tr>
<tr><td>RW</td><td>N</td><td>jitter</td><td>boolean</td><td>If <code>true</code>, enables random jittering of antialiasing super-samples to minimize artifacts. This should only be used for static scenes, not animation.</td></tr>
<tr><td>RW</td><td>N</td><td>jitterAmount</td><td>float</td><td>Defines the amount of jitter. The default is 1.0, above which super-samples may stray outside of their pixels.</td></tr>
<tr><td>RW</td><td>N</td><td>libraryPath</td><td>Array</td><td>An array of one or more paths to search for include files.</td></tr>
<tr><td>RW</td><td>N</td><td>maxImageBuffer</td><td>integer</td><td>Specifies the number of megabytes of memory to reserve as an output buffer for images. The default is 128.</td></tr>
<tr><td>RW</td><td>N</td><td>outputAlpha</td><td>boolean</td><td>Enables or disables the alpha channel in output files. This only has an effect when the output file type supports alpha, i.e., PNG or Targa.</td></tr>
<tr><td>RW</td><td>N</td><td>outputFileName</td><td>string</td><td>By default, the output file name is derived from the .pov scene file name. This option allows it to be set manually. If a directory name is given here instead of a file name, the default name is used and the file is written to the specified directory.</td></tr>
<tr><td>RW</td><td>N</td><td>outputFileType</td><td>string</td><td>Sets the format of the output file. These are all single-character codes as specified below:
<table class="sgrid codeDoc">
<thead>

<tr><th>Code</th><th>Meaning</th></tr>
</thead><tbody>
<tr><td>B</td><td>BMP</td></tr>
<tr><td>C</td><td>TGA, RLE compression</td></tr>
<tr><td>E</td><td>OpenEXR HDR</td></tr>
<tr><td>H</td><td>Radiance HDR</td></tr>
<tr><td>J</td><td>JPEG</td></tr>
<tr><td>N</td><td>PNG</td></tr>
<tr><td>P</td><td>PPM</td></tr>
<tr><td>S</td><td>System default</td></tr>
<tr><td>T</td><td>TGA, uncompressed</td></tr>
</tbody></table>
</td></tr>
<tr><td>RW</td><td>N</td><td>outputToFile</td><td>boolean</td><td>If <code>true</code> (the default), POV-Ray will produce an output image file. If <code>false</code>, no file is produced, which is often desirable when doing test renders.</td></tr>
<tr><td>RW</td><td>N</td><td>palette</td><td>char</td><td>A single character which selects a hardware-dependent palette for display during rendering.</td></tr>
<tr><td>RW</td><td>N</td><td>pauseWhenDone</td><td>boolean</td><td>If <code>true</code>, POV-Ray will wait for a keypress at the end of rendering before clearing the display.</td></tr>
<tr><td>RW</td><td>N</td><td>postSceneCommand</td><td>string</td><td>Shell command to execute after rendering a scene. Since CephaloPOV replaces POV-Ray's native animation system, this happens after every frame in an animation.</td></tr>
<tr><td>RW</td><td>N</td><td>postSceneReturn</td><td>string</td><td>Specifies the action to take when the <code>postSceneAction</code> fails. See <code>fatalExecutionReturn</code> for a list of legal values.</td></tr>
<tr><td>RW</td><td>N</td><td>preSceneCommand</td><td>string</td><td>Shell command to execute before rendering a scene. Since CephaloPOV replaces POV-Ray's native animation system, this happens before every frame in an animation.</td></tr>
<tr><td>RW</td><td>N</td><td>preSceneReturn</td><td>string</td><td>Specifies the action to take when the <code>preSceneAction</code> fails. See <code>fatalExecutionReturn</code> for a list of legal values.</td></tr>
<tr><td>RW</td><td>N</td><td>previewEndSize</td><td>integer</td><td>Sets the final block size in pixels for mosaic rendering. This must be an integer that is both a power of two and greater than zero.</td></tr>
<tr><td>RW</td><td>N</td><td>previewStartSize</td><td>integer</td><td>Sets the initial block size in pixels for mosaic rendering. This must be an integer that is both a power of two and greater than zero.</td></tr>
<tr><td>RW</td><td>N</td><td>quality</td><td>integer</td><td>Determines rendering quality in the range (0 - 11), with higher values being better. The supported levels, with duplication to allow for future changes, are
<table class="sgrid codeDoc">
<thead>

<tr><th>Code</th><th>Meaning</th></tr>
</thead><tbody>
<tr><td>0</td><td>Just show quick colors. Use full ambient lighting only. Quick colors are used only at 5 or below.</td></tr>
<tr><td>1</td><td>Just show quick colors. Use full ambient lighting only. Quick colors are used only at 5 or below.</td></tr>
<tr><td>10</td><td>Compute media, radiosity and subsurface light transport.</td></tr>
<tr><td>11</td><td>Compute media, radiosity and subsurface light transport.</td></tr>
<tr><td>2</td><td>Show specified diffuse and ambient light.</td></tr>
<tr><td>3</td><td>Show specified diffuse and ambient light.</td></tr>
<tr><td>4</td><td>Render shadows, but no extended lights.</td></tr>
<tr><td>5</td><td>Render shadows, including extended lights.</td></tr>
<tr><td>6</td><td>Compute texture patterns, compute photons.</td></tr>
<tr><td>7</td><td>Compute texture patterns, compute photons.</td></tr>
<tr><td>8</td><td>Compute reflected, refracted, and transmitted rays.</td></tr>
<tr><td>9</td><td>Compute media, radiosity and subsurface light transport.</td></tr>
</tbody></table>
</td></tr>
<tr><td>RW</td><td>N</td><td>radFileName</td><td>string</td><td>If specified, manually sets the name of the radiosity cache file.</td></tr>
<tr><td>RW</td><td>N</td><td>radFromFile</td><td>string</td><td>If <code>true</code>, loads sample data from an existing radiosity cache file.</td></tr>
<tr><td>RW</td><td>N</td><td>radToFile</td><td>string</td><td>If <code>true</code>, saves sample data to a radiosity cache file for reuse.</td></tr>
<tr><td>RW</td><td>N</td><td>radVainPretrace</td><td>boolean</td><td>If <code>true</code> (the default), an extra radiosity trace will be taken to improve the quality of the preview. If not needed, this can be turned off to improve rendering speed.</td></tr>
<tr><td>RW</td><td>N</td><td>removeBounds</td><td>boolean</td><td>If <code>true</code> (the default), manual bounds will be removed if automatic bounding control is turned on.</td></tr>
<tr><td>RW</td><td>N</td><td>renderBlockSize</td><td>integer</td><td>Specifies the size of blocks of pixels to be rendered. Must be 4 or greater.</td></tr>
<tr><td>RW</td><td>N</td><td>renderBlockStep</td><td>integer</td><td>Sets the step size for walking through the blocks numbered by <code>renderPattern</code></td></tr>
<tr><td>RW</td><td>N</td><td>renderConsole</td><td>boolean</td><td>If <code>true</code>, POV-Ray rendering information is sent to the console.</td></tr>
<tr><td>RW</td><td>N</td><td>renderFile</td><td>boolean<br/>string</td><td>If <code>true</code>, POV-Ray rendering information is written to <code>RENDER.OUT</code>. Alternatively, a custom filename may be specified here.</td></tr>
<tr><td>RW</td><td>N</td><td>renderPattern</td><td>integer</td><td>Determines the order in which render blocks will be rendered. See the POV-Ray documentation for <a href="http://povray.org/documentation/3.7.0/r3_2.html#r3_2_8_2_1">details</a>.</td></tr>
<tr><td>RW</td><td>N</td><td>samplingMethod</td><td>integer</td><td>Sets the antialiasing sampling method. A value of 1, the default, enables non-recursive sampling, while 2 enables adaptive, recursive sampling.</td></tr>
<tr><td>RW</td><td>N</td><td>splitUnions</td><td>boolean</td><td>If <code>true</code>, manually bound <code>Union</code> objects will be rebound by the automatic bounding system. The default is <code>false</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>startColumn</td><td>integer<br/>float</td><td>Forces the start of output at the specified column if an integer is supplied or a fraction of screen width if a float in the unit interval (0.n) is supplied.</td></tr>
<tr><td>RW</td><td>N</td><td>startRow</td><td>integer<br/>float</td><td>Forces the end of output at the specified row if an integer is supplied or a fraction of screen height if a float in the unit interval (0.n) is supplied.</td></tr>
<tr><td>RW</td><td>N</td><td>statisticConsole</td><td>boolean</td><td>If <code>true</code>, POV-Ray statistics are sent to the console.</td></tr>
<tr><td>RW</td><td>N</td><td>statisticFile</td><td>boolean<br/>string</td><td>If <code>true</code>, POV-Ray statistics are written to <code>STATS.OUT</code>. Alternatively, a custom filename may be specified here.</td></tr>
<tr><td>RW</td><td>N</td><td>testAbort</td><td>boolean</td><td>If <code>true</code>, POV-Ray will poll the keyboard for <code>Ctrl-C</code> to halt the program. If false, <code>Ctrl-C</code> is ignored.</td></tr>
<tr><td>RW</td><td>N</td><td>testAbortCount</td><td>integer</td><td>If <code>testAbort</code> is <code>true</code>, <code>testAbortCount</code> specifies the number of pixels rendered between tests for <code>Ctrl-C</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>userAbortCommand</td><td>string</td><td>Shell command to execute when the user aborts rendering.</td></tr>
<tr><td>RW</td><td>N</td><td>userAbortReturn</td><td>string</td><td>Specifies the action to take when the <code>userAbortAction</code> fails. See <code>fatalExecutionReturn</code> for a list of legal values.</td></tr>
<tr><td>RW</td><td>N</td><td>verbose</td><td>boolean</td><td>If true, POV-Ray will output additional information about each render. Not to be confused with CephaloPOV's <code>-v</code> switch, which only increses the verbosity of its own output.</td></tr>
<tr><td>RW</td><td>N</td><td>videoMode</td><td>char</td><td>A single character/digit which defines the hardware-dependent video mode.</td></tr>
<tr><td>RW</td><td>N</td><td>warningConsole</td><td>boolean</td><td>If <code>true</code>, POV-Ray warning messages are sent to the console.</td></tr>
<tr><td>RW</td><td>N</td><td>warningFile</td><td>boolean<br/>string</td><td>If <code>true</code>, POV-Ray warning messages are written to <code>WARNING.OUT</code>. Alternatively, a custom filename may be specified here.</td></tr>
<tr><td>RW</td><td>N</td><td>warningLevel</td><td>integer</td><td>Specifies POV-Ray's warning level. The legal values are:
<table class="sgrid codeDoc">
<thead>

<tr><th>Code</th><th>Meaning</th></tr>
</thead><tbody>
<tr><td>0</td><td>Turn off all warnings.</td></tr>
<tr><td>10</td><td>Turn on all warnings (default).</td></tr>
<tr><td>5</td><td>Turn off language version warnings.</td></tr>
</tbody></table>
</td></tr>
<tr><td>RW</td><td>N</td><td>workThreads</td><td>integer</td><td>Sets the number of processor threads in a multicore environment. Defaults to the detected number of cores or 4 if detection is not possible, but may be set as high as 512.</td></tr>
</tbody></table>
</div dh="ImageOptions">

<h5>Methods</h5>

<div class='fsig'>ImageOptions(<i>options</i>)</div>

<p class='fdesc'>The constructor may be called without arguments, returning an
object with its attributes initialized to <code>null</code>. The
<code>options</code> argument may also be a plain JavaScript object containing
named initializers. User programs will rarely have to call the <code>ImageOptions</code>
constructor directly as <code>cpov.imageOptions</code> is already initialized.</p>

<div class='fsig'>xset(<i>valObj</i>)</div>

<p class='fdesc'>This is a convenience function which takes an object full
of key/value pairs and sets several attributes at the same time, much like
the constructor, which avoids having to set them individually. The following
are equivalent:</p>

<div class='code fdesc'>cpov.imageOptions.verbose = true;
cpov.imageOptions.quality = 9;

// is the same as...

cpov.imageOptions.xset({verbose: true, quality: 9});</div>

<h4>GlobalSettings</h4>

<p>The <code>GlobalSettings</code> class defines the behavior of light in the
image along with a few odds and ends like the character set used for input
files. At startup, <code>cpov.globalSettings</code> is initialized with a
pristine instance of the class. None of its parameters are mandatory.</p>

<h5>Attributes</h5>

<div dh="GlobalSettings">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>N</td><td>adcBailout</td><td>float</td><td>Defines the Adaptive Depth Control bailout value, which determines when to stop tracing further reflections once they cease to contribute significantly to the color of the current pixel. This defaults to 0.0039 and should not require changing. If it is set to zero, only <code>maxTraceLevel</code> will interrupt the tracing of reflections.</td></tr>
<tr><td>RW</td><td>N</td><td>ambientLight</td><td>Color</td><td>Specifies the color of the ambient light, i.e., the illumination that falls on every object from all directions in the absence of any explicit <code>LightSource</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>assumedGamma</td><td>float</td><td>Defines the working gamma space for the render.</td></tr>
<tr><td>RW</td><td>N</td><td>charset</td><td>string</td><td>Specifies which character set will be used in interpreting the contents of text strings. The supported values are <code>"ascii"</code>, <code>"sys"</code>, and <code>"utf8"</code>. The default is <code>ascii</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>iridWavelength</td><td>Color</td><td>Specifies a color to use in iridescence calculations. The default, <code>[0.70, 0.52, 0.48]</code> will rarely if ever need to be changed, but it is available for experimentation.</td></tr>
<tr><td>RW</td><td>N</td><td>maxIntersections</td><td>integer</td><td>Sets the size of POV-Ray's internal "I-Stacks" for tracking ray/object intersections. The default value for <code>maxIntersections</code> is 64, but if a rendering produces an error message about an I-Stack overflow, you will have to increase this value until the error message disappears.</td></tr>
<tr><td>RW</td><td>N</td><td>maxTraceLevel</td><td>integer</td><td>Sets an upper limit on the number of reflections that a ray can undergo before calculations are stopped and the pixel returns as black. Legal values are in the range 1-256. Increase the value only as needed to fix black spots in reflections as higher values require more memory and time to calculate.</td></tr>
<tr><td>RW</td><td>N</td><td>mmPerUnit</td><td>float</td><td>Sets the number of millimeters per unit of space in the POV-Ray coordinate system, which affects the behavior of subsurface transport. The default is 10, i.e., 1 cm per unit.</td></tr>
<tr><td>RW</td><td>N</td><td>noiseGenerator</td><td>integer</td><td>Specifies which noise generator POV-Ray will use. The default is 2. The legal values are
<table class="sgrid codeDoc">
<thead>

<tr><th>Code</th><th>Meaning</th></tr>
</thead><tbody>
<tr><td>1</td><td>The original noise generator from POV-Ray 3.1 and earlier</td></tr>
<tr><td>2</td><td>An improved noise generator with fewer artifacts</td></tr>
<tr><td>3</td><td>Perlin noise</td></tr>
</tbody></table>
</td></tr>
<tr><td>RW</td><td>N</td><td>numberOfWaves</td><td>integer</td><td>Specifies the number of waves used by the <code>waves</code> and <code>ripples</code> texture patterns. The default is 10.</td></tr>
<tr><td>RW</td><td>N</td><td>photon</td><td>boolean</td><td>If <code>true</code>, photons are enabled and the <code>photon*</code> parameters are emitted in output.</td></tr>
<tr><td>RW</td><td>N</td><td>photonAdcBailout</td><td>float</td><td>Specifies an Adaptive Depth Control for photons. If not specified, the regular <code>adcBailout</code> will be used.</td></tr>
<tr><td>RW</td><td>N</td><td>photonAutostop</td><td>float</td><td>This is a float in the unit interval (0.0 - 1.0) that determines how much of an object's bounding volume must be tested before aborting. It defaults to 0, but objects with holes often require a higher value.</td></tr>
<tr><td>RW</td><td>N</td><td>photonCount</td><td>integer</td><td>Determines the number of photons to use. Cannot be used at the same time as <code>photonSpacing</code></td></tr>
<tr><td>RW</td><td>N</td><td>photonExpandThresholds</td><td>Array</td><td>An array of a float in the unit interval (0.0 - 1.0) and an integer which define how much the adaptive search radius can be increased before reverting to <code>photonRadius</code> and the minimum number of photons to gather, respectively. The default is <code>[0.2, 40]</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>photonGather</td><td>Array</td><td>This is an array of two integers which specify the minimum and maximum number of photons to gather at each point. The default is <code>[20, 100]</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>photonJitter</td><td>float</td><td>Specifies the amount of jitter to use in the pre-processing step. The default is 0.4 and rarely needs to be changed.</td></tr>
<tr><td>RW</td><td>N</td><td>photonLoadFile</td><td>string</td><td>Specifies a photon map to load instead of performing the calculations.</td></tr>
<tr><td>RW</td><td>N</td><td>photonMaxTraceLevel</td><td>integer</td><td>Sets an upper limit on the number of reflections that a photon can undergo before calculations are stopped. Legal values are in the range 1-256. If unspecified, the global <code>maxTraceLevel</code> is used.</td></tr>
<tr><td>RW</td><td>N</td><td>photonMedia</td><td>Array</td><td>If specified, media photons are enabled. This is an array of an integer and a float. The integer specifies the maximum number of photons to deposit over an interval, and the float specifies the difference in media spacing relative to surface spacing.</td></tr>
<tr><td>RW</td><td>N</td><td>photonRadius</td><td>Array</td><td>This is an array of four floats that specify the gather radius, its multiplier, the media gather radius, and its multiplier.</td></tr>
<tr><td>RW</td><td>N</td><td>photonSaveFile</td><td>string</td><td>Saves the calculated photon map to this file for reuse.</td></tr>
<tr><td>RW</td><td>N</td><td>photonSpacing</td><td>float</td><td>Specifies the average distance between photons on surfaces. Cannot be used at the same time as <code>photonCount</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>radAdcBailout</td><td>float</td><td>Specifies an Adaptive Depth Control for radiosity rays. The default is 0.01.</td></tr>
<tr><td>RW</td><td>N</td><td>radAlwaysSample</td><td>boolean</td><td>If <code>true</code>, new samples will be gathered during the final radiosity pass. This is slower and often produces lower-quality results, so the default is <code>false</code>, but there are some cases where turning it on can correct blotchy imperfections.</td></tr>
<tr><td>RW</td><td>N</td><td>radBrightness</td><td>float</td><td>Specifies the amount by which the brightness of objects should be adjusted before being returned to the rest of the system. The default value is 1.0 and should almost never be changed; individual object properties should be adjusted instead.</td></tr>
<tr><td>RW</td><td>N</td><td>radCount</td><td>Array</td><td>This is an array which specifies the number of radiosity rays emitted when a new radiosity value is needed. The default is 35. The second, optional element sets the number of directions to choose rays from.</td></tr>
<tr><td>RW</td><td>N</td><td>radErrorBound</td><td>float</td><td>Specifies the tolerated error and defaults to 1.8. Lower values are more accurate but require higher <code>radCount</code> values to avoid artifacts and dramatically increase rendering times.</td></tr>
<tr><td>RW</td><td>N</td><td>radGrayThreshold</td><td>float</td><td>This is a float in the unit interval (0.0 - 1.0) that counteracts color bleed by desaturating reflected light. At 0.0 (the default), it has no effect, while at the other extreme, 1.0, reflected light is greyscale only.</td></tr>
<tr><td>RW</td><td>N</td><td>radLowErrorFactor</td><td>float</td><td>The <code>radErrorBound</code> is multiplied by <code>radLowErrorFactor</code> during preliminary passes to reduce the blotchy artifacts that would otherwise occur. The default is 0.5.</td></tr>
<tr><td>RW</td><td>N</td><td>radMaxSample</td><td>float</td><td>Defines an upper limit on the brightness of radiosity samples, which can correct for some brightness artifacts at the expense of realism. Setting <code>radMaxSample</code> to a negative value (the default) will disable it.</td></tr>
<tr><td>RW</td><td>N</td><td>radMaximumReuse</td><td>float</td><td>Sets an upper bound on the reuse of samples. See the POV-Ray documentation for <a href="http://povray.org/documentation/3.7.0/r3_4.html#r3_4_4_3">more details</a>.</td></tr>
<tr><td>RW</td><td>N</td><td>radMinimumReuse</td><td>float</td><td>Sets a lower bound on the reuse of samples. See the POV-Ray documentation for <a href="http://povray.org/documentation/3.7.0/r3_4.html#r3_4_4_3">more details</a>.</td></tr>
<tr><td>RW</td><td>N</td><td>radNearestCount</td><td>integer</td><td>Specifies minimum number of old radiosity values blended together to create a new interpolated value. Defaults to 5 with an upper limit of 20.</td></tr>
<tr><td>RW</td><td>N</td><td>radNormal</td><td>boolean</td><td>If <code>true</code>, radiosity will be affected by normals.</td></tr>
<tr><td>RW</td><td>N</td><td>radPretraceEnd</td><td>float</td><td>Specifies the size of mosaic blocks at the end of the pretrace phase as a fraction of image size. This is float in the unit interval (0.0 - 1.0).</td></tr>
<tr><td>RW</td><td>N</td><td>radPretraceStart</td><td>float</td><td>Specifies the size of mosaic blocks at the start of the pretrace phase as a fraction of image size. This is float in the unit interval (0.0 - 1.0).</td></tr>
<tr><td>RW</td><td>N</td><td>radRecursionLimit</td><td>integer</td><td>Determines how many recursion levels are used to calculate the diffuse inter-reflection. The legal range is 1 - 20, but values above 3 are rarely useful.</td></tr>
<tr><td>RW</td><td>N</td><td>radSubsurface</td><td>boolean</td><td>If <code>true</code>, radiosity calculations will take subsurface light transport into account. This will increase realism where translucent objects are concerned at the expense of increased rendering time.</td></tr>
<tr><td>RW</td><td>N</td><td>radiosity</td><td>boolean</td><td>If <code>true</code>, radiosity is enabled and the <code>rad*</code> parameters are emitted in output.</td></tr>
<tr><td>RW</td><td>N</td><td>subRadiosity</td><td>boolean</td><td>If <code>true</code>, subsurface effects will be applied to incoming radiosity illumination.</td></tr>
<tr><td>RW</td><td>N</td><td>subSamples</td><td>Array</td><td>This is an array of two integers which set the number of samples to use for diffuse scattering and single-scattering approximation. The default for both is 50.</td></tr>
<tr><td>RW</td><td>N</td><td>subsurface</td><td>boolean</td><td>If <code>true</code>, subsurface light transport is enabled and the <code>sub*</code> parameters are emitted in output.</td></tr>
</tbody></table>
</div dh="GlobalSettings">

<h5>Methods</h5>

<div class='fsig'>GlobalSettings(<i>options</i>)</div>

<p class='fdesc'>The constructor may be called without arguments, returning an
object with its attributes initialized to <code>null</code>. The
<code>options</code> argument may also be a plain JavaScript object containing
named initializers. User programs will rarely have to call the <code>GlobalSettings</code>
constructor directly as <code>cpov.globalSettings</code> is already initialized.</p>

<div class='fsig'>xset(<i>valObj</i>)</div>

<p class='fdesc'>This is a convenience function which takes an object full
of key/value pairs and sets several attributes at the same time, much like
the constructor, which avoids having to set them individually. The following
are equivalent:</p>

<div class='code fdesc'>cpov.globalSettings.numberOfWaves = 3;
cpov.globalSettings.charset = "utf8";

// is the same as...

cpov.globalSettings.xset({numberOfWaves: 3, charset: "utf8"});</div>


<h3>Vectors, Colors, and Matrices</h3>

<p>Most of the geometry in POV-Ray is defined in terms of vectors, i.e., arrays of floats
whose interpretation depends on context. For the sake of better type checking, CephaloPOV
implements vectors as distinct classes even though some of them, like <code>VectorUV</code>
and <code>VectorXY</code>, are identical save for their attribute names.</p>

<p>Because initializing vector objects involves more typing than POV-Ray's admirably concise
generic notation, all of CephaloPOV's vector types and other object methods that accept
vectors will take JavaScript arrays as initializers in addition to the generic JavaScript objects that
all CephaloPOV class constructors accept.</p>

<div class='code'>var vec = new VectorXYZ();      // The long way
vec.x = 2;
vec.y = -1;
vec.z = 5.2;

var vec = new VectorXYZ({ x: 2, y: -1, z: 5.2 }); // The shorter generic way

var vec = new VectorXYZ([2, -1, 5.2]);            // The shortest way

// A vector can also copy the values of another vector:

var vec1 = new VectorXYZ([3, 4, 5]);
var vec2 = new VectorXYZ(vec1);

// Since you rarely ever need a bare vector, you can also assign arrays
// to vector attributes in other objects:

var box = new Box();
box.corner1 = [ 0, 0, 0 ];
box.corner2 = [ 1, 1, 1 ];</div>

<p>Like most CephaloPOV objects, all of the vector classes have a <code>toSDL()</code>
method which returns the vector in the form of an SDL string.</p>

<h4>VectorUV</h4>

<p>The <code>VectorUV</code> class is used to define 2D coordinates on the UV
plane for texture mapping. Aside from having coordinates named <code>u</code>
and <code>v</code>, it is otherwise identical to <code>VectorXY</code>.</p>

<h5>Attributes</h5>
<div dh="VectorUV">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>u</td><td>float</td><td>The U coordinate of the vector.</td></tr>
<tr><td>RW</td><td>Y</td><td>v</td><td>float</td><td>The V coordinate of the vector.</td></tr>
</tbody></table>
</div dh="VectorUV">

<h5>Methods</h5>

<div class='fsig'>xset(<i>valObj</i>)</div>

<p class='fdesc'>This is a convenience function which takes an object full
of key/value pairs and sets several attributes at the same time, much like
the constructor, which avoids having to set them individually. The following
are equivalent:</p>

<div class='code fdesc'>vec.u = 4;
vec.v = 3.2;;

// is the same as...

vec.xset({u: 4, v: 3.2});</div>

<div class='fsig'>VectorUV(<i>options</i>)</div>

<p class='fdesc'>The constructor may be called without arguments, returning an
object with its attributes initialized to <code>null</code>. The
<code>options</code> argument may also be a plain JavaScript object containing
named initializers, an array of two floats, or another <code>VectorUV</code>
object. The following are all equivalent:</p>

<div class='code fdesc'>var vec1 = new VectorUV({ u: 1, v: 3 });
var vec2 = new VectorUV([1, 3]);
var vec3 = new VectorUV(vec1);</div>

<div class='fsig'>toSDL(<i>stops</i>);</div>

<p class='fdesc'>Returns the SDL representation of the vector as a string,
indented by the optional number of tab <code>stops</code>. If the mandatory
attributes are not specified, a fatal error message is emitted and CephaloPOV
halts.</p>

<div class='fsig'>xset(<i>valObj</i>)</div>

<p class='fdesc'>This is a convenience function which takes an object full
of key/value pairs and sets several attributes at the same time, much like
the constructor, which avoids having to set them individually. The following
are equivalent:</p>

<div class='code fdesc'>vec.u = 4;
vec.v = 3.2;;

// is the same as...

vec.xset({u: 4, v: 3.2});</div>

<h4>VectorXY</h4>

<p>The <code>VectorXY</code> class is used to define 2D coordinates. It is
mostly used to define splines and the outlines of objects which are essentially
sweeps, like the <code>Prism</code>. (For prisms, the points defined are
actually on the XZ plane and the shape is swept along the Y axis, but coming up
with a separate <code>VectorXZ</code> seems excessively pedantic.</p>

<h5>Attributes</h5>

<div dh="VectorXY">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>x</td><td>float</td><td>The X coordinate of the vector.</td></tr>
<tr><td>RW</td><td>Y</td><td>y</td><td>float</td><td>The Y coordinate of the vector.</td></tr>
</tbody></table>
</div dh="VectorXY">

<h5>Methods</h5>

<div class='fsig'>VectorXY(<i>options</i>)</div>

<p class='fdesc'>The constructor may be called without arguments, returning an
object with its attributes initialized to <code>null</code>. The
<code>options</code> argument may also be a plain JavaScript object containing
named initializers, an array of two floats, or another <code>VectorXY</code>
object. The following are all equivalent:</p>

<div class='code fdesc'>var vec1 = new VectorXY({ x: 1, y: 3 });
var vec2 = new VectorXY([1, 3]);
var vec3 = new VectorXY(vec1);</div>

<div class='fsig'>toSDL(<i>stops</i>);</div>

<p class='fdesc'>Returns the SDL representation of the vector as a string,
indented by the optional number of tab <code>stops</code>. If the mandatory
attributes are not specified, a fatal error message is emitted and CephaloPOV
halts.</p>

<div class='fsig'>xset(<i>valObj</i>)</div>

<p class='fdesc'>This is a convenience function which takes an object full
of key/value pairs and sets several attributes at the same time, much like
the constructor, which avoids having to set them individually. The following
are equivalent:</p>

<div class='code fdesc'>vec.x = 4;
vec.y = 3.2;;

// is the same as...

vec.xset({x: 4, y: 3.2});</div>

<h4>VectorXYZ</h4>

<p>Probably the most commonly used vector type for most users, the <code>VectorXYZ</code> class
defines points in three-dimensional space.</p>

<h5>Attributes</h5>

<div dh="VectorXYZ">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>x</td><td>float</td><td>The X coordinate of the vector.</td></tr>
<tr><td>RW</td><td>Y</td><td>y</td><td>float</td><td>The Y coordinate of the vector.</td></tr>
<tr><td>RW</td><td>Y</td><td>z</td><td>float</td><td>The Z coordinate of the vector.</td></tr>
</tbody></table>
</div dh="VectorXYZ">

<h5>Methods</h5>

<div class='fsig'>VectorXYZ(<i>options</i>)</div>

<p class='fdesc'>The constructor may be called without arguments, returning an
object with its attributes initialized to <code>null</code>. The
<code>options</code> argument may also be a plain JavaScript object containing
named initializers, an array of three floats, or another <code>VectorXYZ</code>
object. The following are all equivalent:</p>

<div class='code fdesc'>var vec1 = new VectorXYZ({ x: 1, y: 3, z: 4 });
var vec2 = new VectorXYZ([1, 3, 4]);
var vec3 = new VectorXYZ(vec1);</div>

<div class='fsig'>toSDL(<i>stops</i>);</div>

<p class='fdesc'>Returns the SDL representation of the vector as a string,
indented by the optional number of tab <code>stops</code>. If the mandatory
attributes are not specified, a fatal error message is emitted and CephaloPOV
halts.</p>

<div class='fsig'>xset(<i>valObj</i>)</div>

<p class='fdesc'>This is a convenience function which takes an object full
of key/value pairs and sets several attributes at the same time, much like
the constructor, which avoids having to set them individually. The following
are equivalent:</p>

<div class='code fdesc'>vec.x = 4;
vec.y = 3.2;;

// is the same as...

vec.xset({x: 4, y: 3.2});</div>

<h4>VectorXYZW</h4>

<p>The <code>VectorXYZW</code> class defines points in four-dimensional space,
and as such, it is not often used. One use case is the four-dimensional
<code>JuliaFractal</code>. In the <code>Polynomial</code> type, it is used as a
convenient (and somewhat hackish) way of grouping sets of four floats that are
not actually coordinates.</p>

<h5>Attributes</h5>

<div dh="VectorXYZW">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>x</td><td>float</td><td>The X coordinate of the vector.</td></tr>
<tr><td>RW</td><td>Y</td><td>y</td><td>float</td><td>The Y coordinate of the vector.</td></tr>
<tr><td>RW</td><td>Y</td><td>z</td><td>float</td><td>The Z coordinate of the vector.</td></tr>
<tr><td>RW</td><td>Y</td><td>w</td><td>float</td><td>The W coordinate of the vector.</td></tr>
</tbody></table>
</div dh="VectorXYZW">

<h5>Methods</h5>

<div class='fsig'>VectorXYZW(<i>options</i>)</div>

<p class='fdesc'>The constructor may be called without arguments, returning an
object with its attributes initialized to <code>null</code>. The
<code>options</code> argument may also be a plain JavaScript object containing
named initializers, an array of four floats, or another <code>VectorXYZW</code>
object. The following are all equivalent:</p>

<div class='code fdesc'>var vec1 = new VectorXYZW({ x: 1, y: 3, z: 4, w: -1 });
var vec2 = new VectorXYZW([1, 3, 4, -1]);
var vec3 = new VectorXYZW(vec1);</div>

<div class='fsig'>toSDL(<i>stops</i>);</div>

<p class='fdesc'>Returns the SDL representation of the vector as a string,
indented by the optional number of tab <code>stops</code>. If the mandatory
attributes are not specified, a fatal error message is emitted and CephaloPOV
halts.</p>

<div class='fsig'>xset(<i>valObj</i>)</div>

<p class='fdesc'>This is a convenience function which takes an object full
of key/value pairs and sets several attributes at the same time, much like
the constructor, which avoids having to set them individually. The following
are equivalent:</p>

<div class='code fdesc'>vec.x = 4;
vec.y = 3.2;;

// is the same as...

vec.xset({x: 4, y: 3.2});</div>

<h4>Color</h4>

<p>The <code>Color</code> class is used to represent RGB colors. In addition to
the usual <code>r</code>, <code>g</code>, and <code>b</code> attributes, it has
two optional attributes, <code>f</code> (filter) and <code>t</code> (transmit).
There is a final optional boolean attribute, <code>sRGB</code> which, if
<code>true</code>, maps the colors to the sRGB color space.</p>

<h5>Attributes</h5>

<div dh="Color">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>r</td><td>float</td><td>The red component of the color, in the unit interval (0.0-1.0).</td></tr>
<tr><td>RW</td><td>Y</td><td>g</td><td>float</td><td>The green component of the color, in the unit interval (0.0-1.0).</td></tr>
<tr><td>RW</td><td>Y</td><td>b</td><td>float</td><td>The blue component of the color, in the unit interval (0.0-1.0).</td></tr>
<tr><td>RW</td><td>N</td><td>f</td><td>float</td><td>The filter component of the color, in the unit interval (0.0-1.0).</td></tr>
<tr><td>RW</td><td>N</td><td>t</td><td>float</td><td>The transmit component of the color, in the unit interval (0.0-1.0).</td></tr>
<tr><td>RW</td><td>N</td><td>srgb</td><td>float</td><td>If <code>true</code>, specifies sRGB gamma values. This will produce an error when POV-Ray parses CephaloPOV's output if <code>cpov.globalSettings.assumedGamma</code> is not set.</td></tr>
</tbody></table>
</div dh="Color">

<h5>Methods</h5>

<div class='fsig'>Color(<i>options</i>)</div>

<p class='fdesc'>The constructor may be called without arguments, returning an
object with its attributes initialized to <code>null</code>. The
<code>options</code> argument may also be a plain JavaScript object containing
named initializers, an array of three to six values, or another
<code>Color</code> object. The following are all equivalent:</p>

<div class='code fdesc'>var color1 = new Color({ r: 1.0, g: 0.2, b: 0.33, f: 0.2, t: 1.0, srgb: true });
var color2 = new Color([1.0, 0.2, 0.33, 0.2, 1.0, true]);
var color3 = new Color(color2);</div>

<p class='fdesc'>Note that the <code>f</code>, <code>t</code>, and
<code>srgb</code> attributes are optional, so none, any, or all of them can be
used, but they must be specified in order when passing a bare array.</p>

<div class='fsig'>toSDL(<i>stops</i>);</div>

<p class='fdesc'>Returns the SDL representation of the vector as a string,
indented by the optional number of tab <code>stops</code>. If the mandatory
attributes are not specified, a fatal error message is emitted and CephaloPOV
halts.</p>

<div class='fsig'>xset(<i>valObj</i>)</div>

<p class='fdesc'>This is a convenience function which takes an object full
of key/value pairs and sets several attributes at the same time, much like
the constructor, which avoids having to set them individually. The following
are equivalent:</p>

<div class='code fdesc'>color.r = 0.2;
vec.g = 1.0;;

// is the same as...

vec.xset({r: 0.2, g: 1.0});</div>

<h4>Matrix</h4>

<p>The <code>Matrix</code> type is the workhorse of transformations and
one of the areas where CephaloPOV differs most from the way POV-Ray handles
transformations, though this is more a matter of syntax than anything else.</p>

<h5>Attributes</h5>

<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>v00</td><td>float</td><td>Row 0, column 0 of the matrix.</td></tr>
<tr><td>RW</td><td>Y</td><td>v01</td><td>float</td><td>Row 0, column 1 of the matrix.</td></tr>
<tr><td>RW</td><td>Y</td><td>v02</td><td>float</td><td>Row 0, column 2 of the matrix.</td></tr>
<tr><td>RW</td><td>Y</td><td>v10</td><td>float</td><td>Row 1, column 0 of the matrix.</td></tr>
<tr><td>RW</td><td>Y</td><td>v11</td><td>float</td><td>Row 1, column 1 of the matrix.</td></tr>
<tr><td>RW</td><td>Y</td><td>v12</td><td>float</td><td>Row 1, column 2 of the matrix.</td></tr>
<tr><td>RW</td><td>Y</td><td>v20</td><td>float</td><td>Row 2, column 0 of the matrix.</td></tr>
<tr><td>RW</td><td>Y</td><td>v21</td><td>float</td><td>Row 2, column 1 of the matrix.</td></tr>
<tr><td>RW</td><td>Y</td><td>v22</td><td>float</td><td>Row 2, column 2 of the matrix.</td></tr>
<tr><td>RW</td><td>Y</td><td>v30</td><td>float</td><td>Row 3, column 0 of the matrix.</td></tr>
<tr><td>RW</td><td>Y</td><td>v31</td><td>float</td><td>Row 3, column 1 of the matrix.</td></tr>
<tr><td>RW</td><td>Y</td><td>v32</td><td>float</td><td>Row 3, column 2 of the matrix.</td></tr>
</tbody></table>

<h5>Methods</h5>

<div class="fsig">Matrix(<i>v00</i>, <i>v01</i>, <i>v02</i>, <i>v10</i>, <i>v11</i>, <i>v12</i>, <i>v20</i>, <i>v21</i>, <i>v22</i>, <i>v30</i>, <i>v31</i>, <i>v32</i>);</div>

<p class='fdesc'>In its basic form, which few users will often use, the
constructor takes twelve floats for each of the values in the matrix, just as it
is done in SDL. Like SDL, there are several short convenience forms for the
basic transformations:</p>

<div class='code fdesc'>var scale     = new Matrix("scale", 1.5, 2, 1);
var translate = new Matrix("translate", 5, 2.2, 0);
var rotate    = new Matrix("rotate", 45, 15, 0);</div>

<p class='fdesc'>In each of the examples above, the name of the transformation
is the first argument, followed by three float arguments, one for each of the
axes. As with POV-Ray, the values for rotations are given in degrees.</p>

<p class='fdesc'>The <code>Matrix</code> constructor has a couple of additional
short forms. The first of these lets you specify skews without having to
construct the whole matrix by hand. Just pass <code>"skew"</code> as the first
argument, and the second argument is an object containing the axis pairs to
perform the skew by, like so:</p>

<div class='code fdesc'>var skew = new Matrix("skew", { xy: 1.5, zy: 0.2 });</div>

<p class='fdesc'>The complete set of axis pairs is <code>yx</code>,
<code>zx</code>, <code>xy</code>, <code>zy</code>, <code>xz</code>, and
<code>yz</code>. You can omit the pairs you don't need.</p>

<p class='fdesc'>Finally, you can just pass <code>"none"</code> as the sole
argument and get a <code>Matrix</code> that does nothing. This is useful if your
"base" transformation (see the <code>Primitive</code> type for more details)
doesn't require any actual transformations.</p>

<div class='fsig'>toSDL(<i>stops</i>);</div>

<p class='fdesc'>Returns the SDL representation of the matrix as a string,
indented by the optional number of tab <code>stops</code>. Unlike most other
<code>toSDL</code> methods, this one always succeeds because the constructor
either requires or supplies all of the mandatory values.</p>

<div class='fsig'>Matrix.xMatrix(<i>that</i>);</div>

<p class='fdesc'>Given another <code>Matrix</code>, <code><i>that</i></code>,
returns a new <code>Matrix</code> that is the product of
<code><i>this</i></code> &times; <code><i>that</i></code>.</p>

<div class='fsig'>Matrix.xPoint(<i>point</i>);</div>

<p class='fdesc'>Given a <code>VectorXYZ</code>, <code><i>point</i></code>,
returns a new <code>VectorXYZ</code> which has been transformed by the
matrix.</p>

<div class='fsig'>xset(<i>valObj</i>)</div>

<p class='fdesc'>This is a convenience function which takes an object full
of key/value pairs and sets several attributes at the same time, much like
the constructor, which avoids having to set them individually. The following
are equivalent:</p>

<div class='code fdesc'>matrix.v01 = 4;
matrix.v02 = 3.2;

// is the same as...

matrix.xset({v01: 4, v02: 3.2});</div>

<h3>Geometric Primitives</h3>

<h4>Primitive</h4>

<p>The <code>Primitive</code> type is the base class for all of the other
geometric primitives. Unless you're implementing a new primitive, perhaps for
one of the experimental forks of POV-Ray like MegaPOV, you don't need to worry
about its internals, but you do need to be familiar with the public attributes
and methods it shares with all of its subclasses.</p>

<p>Two of those attributes, <code>baseTransform</code> and
<code>transform</code>, are important enough to discuss outside of the
attributes table, below. In order to support several significant features
now and in the future, CephaloPOV distinguishes between an initial
transformation that is effectively part of the definition of an object and
subsequent transformations applied to it. That initial transformation is the
<code>baseTransform</code>, and the subsequent transformations are combined
mathematically in the <code>transform</code> attribute.</p>

<p>When a <code>Primitive</code> is output to SDL, the current value of its
<code>transform</code> attribute is included in the object definition. The
<code>baseTransform</code> is kept internal to CephaloPOV to help with geometric
queries and the scene graph system. Most of the time, you won't have to do
anything more than set the <code>baseTransform</code>, though it can be useful
in user code in snapshot mode, as we will see.</p>

<p>The easiest way and clearest way to establish the <code>baseTransform</code>
is simply to assign it:</p>

<div class='code'>someBox.baseTransform = new Matrix("rotate", 0, 45, 15);</div>

<p>If you don't set <code>baseTransform</code> explicitly, setting
<code>transform</code> will set it at the same time. Naturally, if you are
defining an object that doesn't change from frame to frame and its initial
parameters are fine without any transformations at all, you don't have to bother
with either transform attribute.</p>

<p>Each time thereafter that you set <code>transform</code>, the supplied
<code>Matrix</code> is <em>multiplied</em> by the existing
<code>transform</code> value. Because of the way matrix multiplication works,
this will effectively add the new transformation to the transformations that
have already been applied. If you want to start over fresh with the
<code>baseTransform</code> value, just call the <code>transformReset</code>
method.</p>

<p>The main purpose of all of this behind-the-scenes plumbing is to provide the
necessary basis for higher-level features like the <span class='ephemeral'>not
yet implemented</span> scene graph, and you don't have to worry about it much in
your own user programs. One exception to this is if you are using snapshot mode,
where multiple output objects can be created using a single primitive object and
repeatedly setting <code>transform</code> and then calling
<code>baseTransform</code>.</p>

<h5>Attributes</h5>

<div dh="Primitive">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>N</td><td>active</td><td>boolean</td><td>If <code>active == false</code>, it will not be output to the current .pov frame file. Defaults to <code>true</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>baseTransform</td><td>Matrix</td><td>The <code>baseTransform</code> attribute contains the "default" transformation of the object. As new transformations are applied, the original <code>baseTransform</code> remains unchanged, making it easy to revert to the original state by calling the <code>resetTransform</code> method.</td></tr>
<tr><td>RW</td><td>N</td><td>boundedBy</td><td>Primitive</td><td>Defines a manual bounding volume for the object.</td></tr>
<tr><td>RW</td><td>N</td><td>clippedBy</td><td>Primitive</td><td>Specifies a solid <code>Primitive</code> that the object is clipped by in a manner similar to CSG intersection.</td></tr>
<tr><td>RW</td><td>N</td><td>doubleIlluminate</td><td>boolean</td><td>If <code>true</code>, the object is illuminated on its shadow side.</td></tr>
<tr><td>RW</td><td>N</td><td>finish</td><td>Finish</td><td class='dummy'>TODO: Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce nec tellus quis turpis pretium condimentum ut eget neque. Integer pharetra imperdiet elit, eu malesuada tortor.</td></tr>
<tr><td>RW</td><td>N</td><td>frameBegin</td><td>function</td><td>If defined, this function will be called at the beginning of a frame before output.</td></tr>
<tr><td>RW</td><td>N</td><td>frameEnd</td><td>function</td><td>If defined, this function will be called at the end of a frame after output.</td></tr>
<tr><td>RW</td><td>N</td><td>hollow</td><td>boolean</td><td>If <code>true</code>, this will make an otherwise solid primitive hollow. Has no effect on objects which are not solid.</td></tr>
<tr><td>RW</td><td>N</td><td>id</td><td>string</td><td>An optional, unique string which serves to identify an object. While you can pull objects out of <code>cpov.idMap</code> using this value, it is output in error messages, making it easier to find the offending object.</td></tr>
<tr><td>RW</td><td>N</td><td>interior</td><td>Interior</td><td class="niy">NOT IMPLEMENTED YET</td></tr>
<tr><td>RW</td><td>N</td><td>inverse</td><td>boolean</td><td>If <code>true</code>, the inside and outside of the solid object are swapped. For example, a hollow <code>Sphere</code> would consist of a spherical void in an infinite solid mass. This is mainly useful in CSG objects.</td></tr>
<tr><td>RW</td><td>N</td><td>material</td><td>Material</td><td class="niy">NOT IMPLEMENTED YET</td></tr>
<tr><td>RW</td><td>N</td><td>noImage</td><td>boolean</td><td>If <code>true</code>, the object will be invisible to cameras, but it will still cast shadows and show up in reflections.</td></tr>
<tr><td>RW</td><td>N</td><td>noRadiosity</td><td>boolean</td><td>If <code>true</code>, the object will be invisible to radiosity rays.</td></tr>
<tr><td>RW</td><td>N</td><td>noReflection</td><td>boolean</td><td>If <code>true</code>, the object will not be visible in reflections.</td></tr>
<tr><td>RW</td><td>N</td><td>noShadow</td><td>boolean</td><td>If <code>true</code>, the object will not cast shadows.</td></tr>
<tr><td>RO</td><td>N</td><td>parent</td><td>Primitive</td><td>This is a read-only reference to the parent object of which the current object is a component, e.g., <code>Blob</code>, <code>Mesh</code>, and CSG objects.</td></tr>
<tr><td>RW</td><td>N</td><td>photons</td><td>TODO</td><td class='dummy'>TODO: Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce nec tellus quis turpis pretium condimentum ut eget neque. Integer pharetra imperdiet elit, eu malesuada tortor.</td></tr>
<tr><td>RW</td><td>N</td><td>radiosity</td><td>TOOD</td><td class='dummy'>TODO: Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce nec tellus quis turpis pretium condimentum ut eget neque. Integer pharetra imperdiet elit, eu malesuada tortor.</td></tr>
<tr><td>RW</td><td>N</td><td>serial</td><td>integer</td><td>This is a unique read-only integer serial number automatically assigned by CephaloPOV upon object creation. It is displayed in error messages, and objects can be looked up using <code>cpov.serialMap</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>texture</td><td>string</td><td>Pending implementation of CephaloPOV's texture subsystem, this is a literal SDL string which will be output as-is.</td></tr>
<tr><td>RW</td><td>N</td><td>transform</td><td>Matrix</td><td>This is a <code>Matrix</code> representing the current transformation state of the object, as distinct from <code>baseTransform</code>, which represents its original state. <code>Matrix</code> values assigned to the <code>transform</code> attribute are silently multiplied against its current value.</td></tr>
</tbody></table>
</div dh="Primitive">

<h5>Methods</h5>

<div class='fsig'>resetTransform();</div>

<p class='fdesc'>Restores the object's current <code>transform</code> to the
value of its <code>baseTransform</code>.</p>

<div class='fsig'>snapshot();</div>

<p class='fdesc'>If <code>cpov.snapshotMode</code> is <code>true</code>, this
method sends the output of <code>toSDL</code> to the snapshot output buffer,
where it will remain until <code>cpov.outputFrame</code> is called.</p>

<div class='fsig'>toSDL(<i>stops</i>);</div>

<p class='fdesc'>Returns the SDL representation of the <code>Primitive</code> as
a string, indented by the optional number of tab <code>stops</code>. User
programs will seldom if ever call this directly, but it is overridden and called
by the <code>toSDL</code> methods in the subclasses. Those subclass methods will
emit a fatal error message if any mandatory attributes are not specified, but
the <code>Primitive</code> base class has no mandatory attributes, so this call
will always succed.</p>

<div class='fsig'>xset(<i>valObj</i>)</div>

<p class='fdesc'>This is a convenience function which takes an object full
of key/value pairs and sets several attributes at the same time, much like
the constructor, which avoids having to set them individually. The following
are equivalent:</p>

<div class='code fdesc'>box.corner1 = [-1, -1, -1];
box.corner2 = [1, 1, 1];

// is the same as...

box.xset({corner1: [-1, -1, -1], corner2: [1, 1, 1]});</div>

<h4>BicubicPatch</h4>

<table class="illusBasic"><tr><td>

<p>The <code>BicubicPatch</code> type is a curved surface defined by a
4&nbsp;&times;&nbsp;4 array of <code>VectorXYZ</code> control points which are
interpolated behind the scenes using Bezier splines and converted to a mesh of
triangles. The number of triangles used along the u- and v-axes are defined by
<code>uSteps</code> and <code>vSteps</code>.</p>

<div class='code'>var obj = new BicubicPatch({
    type: 0,
    flatness: 0.01,
    uSteps: 4,
    vSteps: 4,
    points: [
        [0, 2, 0], [0, 0, 1], [0, 0, 2], [0, -2, 3],
        [1, 0, 0], [1, 0, 1], [1, 0, 2], [1,  0, 3],
        [2, 0, 0], [2, 0, 1], [2, 0, 2], [2,  0, 3],
        [3, 2, 0], [3, 0, 1], [3, 0, 2], [3, -2, 3]
    ]
});</div>

</td><td>

    <img src="img/bicubicpatch_basic.png">

</td></tr></table>

<h5>Attributes</h5>

<div dh="BicubicPatch">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>points</td><td>[VectorXYZ]</td><td>The <code>points</code> attribute is an array of 16 <code>VectorXYZ</code> points which define the 4 &times; 4 array of control points that define the patch.</td></tr>
<tr><td>RW</td><td>Y</td><td>type</td><td>integer</td><td>This may be either 0 or 1. Type 0 reduces the amount of memory used to store the patch in memory at the cost of slower rendering. Type 1 does the reverse, consuming more memory but reducing the number of calculations required.</td></tr>
<tr><td>RW</td><td>N</td><td>flatness</td><td>float</td><td>If <code>flatness</code> is 0 (the default), the patch will be subdivided into only as many triangles as specified by <code>uSteps</code> and <code>vSteps</code>. Increasing it up to a maximum of 1.0 will encourage POV-Ray to automatically subdivide the patch into additional triangles as needed.</td></tr>
<tr><td>RW</td><td>N</td><td>uSteps</td><td>integer</td><td>Defines the number of rows of triangles used to create the patch. Most patches can be acceptably rendered using 3 rows.</td></tr>
<tr><td>RW</td><td>N</td><td>vSteps</td><td>integer</td><td>Defines the number of columns of triangles used to create the patch. Most patches can be acceptably rendered using 3 columns.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>BicubicPatch</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>BicubicPatch</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>pseudo</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV makes it act similar to one so it can be included in CSG objects. For a <code>BicubicPatch</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>BicubicPatch</code>, this is always <code>false</code>.</td></td></tr>
</tbody></table>
</div dh="BicubicPatch">

<h4>Blob</h4>

<table class="illusBasic"><tr><td>

<p>The <code>Blob</code> type is an isosurface of scalar fields produced by
points and lines represented in the <code>components</code> array by
<code>Sphere</code> and <code>Cylinder</code> objects. What this means in
practice is that each object has a field <code>strength</code> that starts at
the center of the object and drops to zero at its <code>radius</code>. The
surface of the blob is wherever the overlapping fields have a value equal to the
blob's <code>threshold</code> value, which defaults to 1.0. The effect is a smooth
surface like drops and strings of honey.</p>

<p>This makes the <code>Blob</code> an excellent tool for building smooth,
organic shapes. In the simple example here, a <code>Blob</code> composed of
three <code>Sphere</code> objects forms a lumpy diagonal line through the demo
stage space.</p>

<div class='code'>var obj = new Blob({
    components: [
        new Sphere({ center: [-1.5, -1.5, -1.5],
            radius: 2, strength: 4 }),
        new Sphere({ center: [   0,    0,    0],
            radius: 2, strength: 4 }),
        new Sphere({ center: [ 1.5,  1.5,  1.5],
            radius: 2, strength: 4 }),
    ],
    texture: texture
});</div>

</td><td>

    <img src="img/blob_basic.png">

</td></tr></table>

<h5>Attributes</h5>

<div dh="Blob">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>components</td><td>Array</td><td>This is an array of <code>Sphere</code> and <code>Cylinders</code>, optionally with their <code>strength</code> attributes set.</td></tr>
<tr><td>RW</td><td>N</td><td>hierarchy</td><td>hierarchy</td><td>If <code>false</code>, turn off the internal bounding hierarchy.</td></tr>
<tr><td>RW</td><td>N</td><td>sturm</td><td>boolean</td><td>If <code>true</code>, POV-Ray will use the slower but more accurate Sturmian root solver. Use this if the surface exhibits holes or other imperfections.</td></tr>
<tr><td>RW</td><td>N</td><td>threshold</td><td>float</td><td>The <code>threshold</code> determines the field strength that distinguishes between the inside and outside of a <code>Blob</code>, i.e., <code>threshold</code> defines the surface of a <code>Blob</code>.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Blob</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Blob</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>pseudo</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV makes it act similar to one so it can be included in CSG objects. For a <code>Blob</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Blob</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Blob">

<h4>Box</h4>

<table class="illusBasic"><tr><td>

<p>The <code>Box</code> type is exactly what it sounds like: a rectangular box.
It is defined by the coordinates of two diagonally opposite corners,
<code>corner1</code> and <code>corner2</code>. Its sides are orthogonal to the
axes, so other orientations will require applying a transformation. The example
at right was created by the following code:</p>

<div class='code'>var obj = new Box({
    corner1: [2, 2, 2],
    corner2: [-2, -2, -2]
});</div>

</td><td>

    <img src="img/box_basic.png">

</td></tr></table>


<h5>Attributes</h5>

<div dh="Box">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>corner1</td><td>VectorXYZ</td><td>The first of two opposite corners of the cube.</td></tr>
<tr><td>RW</td><td>Y</td><td>corner2</td><td>VectorXYZ</td><td>The first of two opposite corners of the cube.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Box</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Box</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>pseudo</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV makes it act similar to one so it can be included in CSG objects. For a <code>Box</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Box</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Box">

<h4>Camera</h4>

<p>TODO</p>

<h5>Attributes</h5>

<div dh="Camera">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>type</td><td>string</td><td>Defines the type of the camera. The legal values are
<table class="sgrid codeDoc">
<thead>

<tr><th>Code</th><th>Meaning</th></tr>
</thead><tbody>
<tr><td>cylinder</td><td>cylinder</td></tr>
<tr><td>fisheye</td><td>fisheye</td></tr>
<tr><td>meshCamera</td><td>mesh_camera</td></tr>
<tr><td>omnimax</td><td>omnimax</td></tr>
<tr><td>orthographic</td><td>orthographic</td></tr>
<tr><td>panoramic</td><td>panoramic</td></tr>
<tr><td>perspective</td><td>perspective</td></tr>
<tr><td>spherical</td><td>spherical</td></tr>
<tr><td>ultraWideAngle</td><td>ultra_wide_angle</td></tr>
</tbody></table>
</td></tr>
<tr><td>RW</td><td>N</td><td>angle</td><td>float</td><td>Sets the width of the camera's viewing angle in degrees.</td></tr>
<tr><td>RW</td><td>N</td><td>aperture</td><td>float</td><td>A non-zero value will enable simulated focal depth-of-field.</td></tr>
<tr><td>RW</td><td>N</td><td>blurSamples</td><td>[float]</td><td>Specifies the minimum and maximum number of samples to be used when <code>aperture</code> is non-zero.</td></tr>
<tr><td>RW</td><td>N</td><td>bokeh</td><td>Color</td><td>Specifies the bokeh color.</td></tr>
<tr><td>RW</td><td>N</td><td>confidence</td><td>float</td><td>Specifies the confidence interval that determines when enough samples have been taken when <code>aperture</code> is non-zero.</td></tr>
<tr><td>RW</td><td>N</td><td>cylinderType</td><td>integer</td><td>If the cylinder camera type is used, <code>cyliderType</code> must be set with an integer in the range 1-4. These values correspond to
<table class="sgrid codeDoc">
<thead>

<tr><th>Code</th><th>Meaning</th></tr>
</thead><tbody>
<tr><td>1</td><td>vertical cylinder, fixed viewpoint</td></tr>
<tr><td>2</td><td>horizontal cylinder, fixed viewpoint</td></tr>
<tr><td>3</td><td>vertical cylinder, viewpoint moves along the cylinder's axis</td></tr>
<tr><td>4</td><td>horizontal cylinder, viewpoint moves along the cylinder's axis</td></tr>
</tbody></table>
</td></tr>
<tr><td>RW</td><td>N</td><td>direction</td><td>VectorXYZ</td><td>Sets the direction vector of the camera before it is moved by <code>lookAt</code> and any rotations. For most purposes, you will not need to set <code>direction</code>, but see the POV-Ray docs for <a href="http://povray.org/documentation/3.7.0/r3_4.html#r3_4_2_1_4">more details</a>.</td></tr>
<tr><td>RW</td><td>N</td><td>focalPoint</td><td>VectorXYZ</td><td>Specifies the point at which the image is perfectly focused when <code>aperture</code> is non-zero.</td></tr>
<tr><td>RW</td><td>N</td><td>location</td><td>VectorXYZ</td><td>Specifies the location of the camera.</td></tr>
<tr><td>RW</td><td>N</td><td>lookAt</td><td>VectorXYZ</td><td>Specifies the point at which the camera is aimed.</td></tr>
<tr><td>RW</td><td>N</td><td>right</td><td>VectorXYZ</td><td>Along with <code>up</code>, the <code>right</code> vector determines how POV-Ray calculates the aspect ratio of the image. By default, it is <code>[1.33, 0, 0]</code>. The cylindrical and orthographic cameras have different behaviors, for which see the <a href="http://povray.org/documentation/3.7.0/r3_4.html#r3_4_2_1_5">POV-Ray docs</a>. It also determines the handedness of the coordinate system.</td></tr>
<tr><td>RW</td><td>N</td><td>sky</td><td>VectorXYZ</td><td>Determines where "up" is for the camera. By default, this is [0, 1, 0].</td></tr>
<tr><td>RW</td><td>N</td><td>up</td><td>VectorXYZ</td><td>Along with <code>right</code>, the <code>up</code> vector determines how POV-Ray calculates the aspect ratio of the image. By default, it is <code>[0, 1, 0]</code>. The cylindrical and orthographic cameras have different behaviors, for which see the <a href="http://povray.org/documentation/3.7.0/r3_4.html#r3_4_2_1_5">POV-Ray docs</a>.</td></tr>
<tr><td>RW</td><td>N</td><td>variance</td><td>float</td><td>When <code>aperture</code> is non-zero, <code>variance</code> tells POV-Ray the value of the smallest displayable color difference. The default, 0.0078125, can produce fairly grainy images. To fix this, try a value around 0.00001.</td></tr>
<tr><td>RW</td><td>N</td><td>vertAngle</td><td>float</td><td>For the spherical camera, this defines the vertical angle of the viewing area while <code>angle</code> specifies the horizontal angle.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Camera</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Camera</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>pseudo</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV makes it act similar to one so it can be included in CSG objects. For a <code>Camera</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Camera</code>, this is always <code>false</code>.</td></td></tr>
</tbody></table>
</div dh="Camera">

<h5>Methods</h5>

<p>TODO</p>

<h4>Cone</h4>

<table class="illusBasic"><tr><td>

<p>The <code>Cone</code> type is deceptively simple. At a minimum, you must
specify a <code>basePoint</code> and a <code>capPoint</code> along with their
respective radii. For the result to be a cone, one of the radii must be zero,
but non-zero values will produce a frustum, i.e., a truncated cone. You can also
remove the endcaps and create a hollow cone by setting <code>open</code> to
true. The example at right was created by the following code:</p>

<div class='code'>var obj = new Cone({
    basePoint: [0, -2, 0],
    baseRadius: 2,
    capPoint: [0, 2, 0],
    capRadius: 0
});</div>

</td><td>

    <img src="img/cone_basic.png">

</td></tr></table>


<h5>Attributes</h5>

<div dh="Cone">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>basePoint</td><td>VectorXYZ</td><td>Defines the location of the center of the cone's base end.</td></tr>
<tr><td>RW</td><td>Y</td><td>baseRadius</td><td>float</td><td>Defines the radius of the cone's base end.</td></tr>
<tr><td>RW</td><td>Y</td><td>capPoint</td><td>VectorXYZ</td><td>Defines the location of the center of the cone's cap end.</td></tr>
<tr><td>RW</td><td>Y</td><td>capRadius</td><td>float</td><td>Defines the radius of the cone's cap end. If this is non-zero, it technically ceases to be a cone and instead becomes a frustum.</td></tr>
<tr><td>RW</td><td>N</td><td>open</td><td>boolean</td><td>If <code>true</code>, the base and the cap are left open, yielding a hollow cone.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Cone</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Cone</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>pseudo</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV makes it act similar to one so it can be included in CSG objects. For a <code>Cone</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Cone</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Cone">

<h4>Cubic</h4>

<p>TODO</p>

<h5>Attributes</h5>

<div dh="Cubic">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>coefficients</td><td>[float]</td><td>An array of 20 floats that act as the coefficients of a third-order polynomial.</td></tr>
<tr><td>RW</td><td>N</td><td>sturm</td><td>boolean</td><td>If <code>true</code>, POV-Ray will use the slower but more accurate Sturmian root solver. Use this if the surface exhibits holes or other imperfections.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Cubic</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Cubic</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>pseudo</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV makes it act similar to one so it can be included in CSG objects. For a <code>Cubic</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Cubic</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Cubic">

<h4>Cylinder</h4>

<table class="illusBasic"><tr><td>

<p>The <code>Cylinder</code> type produces a solid cylinder by default and
defined by the coordinates of the centers of its two circular ends,
<code>basePoint</code> and <code>capPoint</code>, plus the <code>radius</code>
of both. If the <code>open</code> attribute is true, the end caps are omitted
and the interior is hollow, leaving an infinitely thin tube.</p>

<p>If it is being used as a component in a <code>Blob</code>, the <code>strength</code>
attribute can be used to assign a field strength to the cylinder.</p>

<p>The following code produces the example at right:</p>

<div class='code'>var obj = new Cylinder({
    basePoint: [0, -2, 0],
    capPoint: [0, 2, 0],
    radius: 2,
});</div>

</td><td>

    <img src="img/cylinder_basic.png">

</td></tr></table>

<h5>Attributes</h5>

<div dh="Cylinder">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>basePoint</td><td>VectorXYZ</td><td>Defines the center of the base end of the cylinder.</td></tr>
<tr><td>RW</td><td>Y</td><td>capPoint</td><td>VectorXYZ</td><td>Defines the center of the cap end of the cylinder.</td></tr>
<tr><td>RW</td><td>Y</td><td>radius</td><td>float</td><td>Defines the radius of the cylinder.</td></tr>
<tr><td>RW</td><td>N</td><td>open</td><td>boolean</td><td>If <code>true</code>, the cap and base planes are are eliminating, yielding a hollow tube.</td></tr>
<tr><td>RW</td><td>N</td><td>strength</td><td>float</td><td>Defines the field strength of the cylinder. This is only used when the cylinder is a component of a <code>Blob</code> object.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Cylinder</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Cylinder</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>pseudo</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV makes it act similar to one so it can be included in CSG objects. For a <code>Cylinder</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Cylinder</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Cylinder">

<h4>Difference</h4>

<p>TODO</p>

<h5>Attributes</h5>

<div dh="Difference">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>negativeComponents</td><td>Array</td><td>This is an array of objects to subtract from the <code>positiveComponent</code>.</td></tr>
<tr><td>RW</td><td>Y</td><td>positiveComponent</td><td>Primitive</td><td>This is the single base object from which the object(s) in the <code>negativeComponents</code> array are subtracted.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Difference</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Difference</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Difference</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Difference">

<h4>Disc</h4>

<table class="illusBasic"><tr><td>

<p>The <code>Disc</code> type is a two-dimensional circular disc defined by its
<code>center</code>, <code>radius</code>, and <code>normal</code>. As in the
example below, it is possible to turn it into a washer-like ring by specifying a
non-zero <code>holeRadius</code>.</p>

<div class='code'>var obj = new Disc({
    center: [0, 0, 0],
    radius: 2,
    holeRadius: 1,
    normal: [0, 1, 0]
});</div>

</td><td>

    <img src="img/disc_basic.png">

</td></tr></table>

<h5>Attributes</h5>

<div dh="Disc">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>center</td><td>VectorXYZ</td><td>This is the center point of the disc.</td></tr>
<tr><td>RW</td><td>Y</td><td>normal</td><td>VectorXYZ</td><td>This defines the normal or orientation of the disc in space.</td></tr>
<tr><td>RW</td><td>Y</td><td>radius</td><td>float</td><td>Defines the radius of the disc.</td></tr>
<tr><td>RW</td><td>N</td><td>holeRadius</td><td>float</td><td>If supplied and non-zero, defines the radius of the hole in the center of the disc.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Disc</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Disc</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>pseudo</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV makes it act similar to one so it can be included in CSG objects. For a <code>Disc</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Disc</code>, this is always <code>false</code>.</td></td></tr>
</tbody></table>
</div dh="Disc">

<h4>HeightField</h4>

<h5>Attributes</h5>

<p>TODO</p>

<div dh="HeightField">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>source</td><td>SDL<br/>string</td><td>Defines the source of the points that comprise the height field. This may be either an SDL function or the path to a graphics file.</td></tr>
<tr><td>RW</td><td>N</td><td>gamma</td><td>float<br/>string</td><td>Defines the gamma value to be used in interpreting an image file. This may be either a float or the string <code>"sRGB"</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>hfType</td><td>string</td><td>If <code>source</code> is a graphics file, the <code>hfType</code> attribute declares the file format, which must be one of <code>"exr"</code>, <code>"gif"</code>, <code>"hdr"</code>, <code>"iff"</code>, <code>"jpeg"</code>, <code>"pgm"</code>, <code>"png"</code>, <code>"pot"</code>, <code>"ppm"</code>, <code>"sys"</code>, <code>"tga"</code>, and <code>"tiff"</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>hierarchy</td><td>boolean</td><td>If <code>false</code>, turn off the internal bounding hierarchy.</td></tr>
<tr><td>RW</td><td>N</td><td>premultiplied</td><td>boolean</td><td>Specifies whether the file is stored in premultiplied associated or non-premultiplied straight alpha format, overriding the file format specific default. This keyword has no effect on files without an alpha channel.</td></tr>
<tr><td>RW</td><td>N</td><td>smooth</td><td>boolean</td><td>If <code>true</code>, POV-Ray will manipulate the surface normals of the generated triangles to create a smoother-looking surface.</td></tr>
<tr><td>RW</td><td>N</td><td>waterLevel</td><td>float</td><td>Defines the point below which the height field is hidden. This defaults to 0.0, which corresponds to the bottom of the height field, i.e., nothing is hidden. At the other extreme, 1.0 will cause the entire height field to be hidden. Note that this does not create a plane representing water; you'll have to do that manually.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>HeightField</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>HeightField</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>pseudo</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV makes it act similar to one so it can be included in CSG objects. For a <code>HeightField</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>HeightField</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="HeightField">

<h4>Intersection</h4>

<p>TODO</p>

<h5>Attributes</h5>

<div dh="Intersection">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>components</td><td>[Primitive]</td><td>An array of objects whose intersection will produce the resulting object.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Intersection</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Intersection</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Intersection</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Intersection">

<h4>IsoSurface</h4>

<p>TODO</p>

<h5>Attributes</h5>

<div dh="IsoSurface">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>source</td><td>SDL</td><td>This is a string containing the SDL function code which defines the surface.</td></tr>
<tr><td>RW</td><td>N</td><td>accuracy</td><td>float</td><td>Defines the amount of subdivision POV-Ray performs to find the surface, with lower values being more accurate. Defaults to 0.001.</td></tr>
<tr><td>RW</td><td>N</td><td>containedBy</td><td>Sphere<br/>Box</td><td>Defines a <code>Sphere</code> or <code>Box</code> which determines the portion of the (potentially infinite) surface that POV-Ray will render. By default, this is a <code>Box</code> with corners at <code>[1, 1, 1]</code> and <code>[-1, -1, -1]</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>evaluate</td><td>[float]</td><td>This is an array of three floats that optionally guides POV-Ray in dynamically adapting <code>maxGradient</code>. See the official POV-Ray documentation for <a href="specifies whether the file is stored in premultiplied associated or non-premultiplied straight alpha format, overriding the file format specific default. This keyword has no effect on files without an alpha channel.">details.</a></td></tr>
<tr><td>RW</td><td>N</td><td>maxGradient</td><td>float</td><td>Rendering will be faster if POV-Ray knows the maximum gradient of the <code>source</code> function. The <code>maxGradient</code> value defaults to 1.1, but if this too low, holes and other imperfections may appear, and POV-Ray will emit a warning telling you the maximum gradient it found so that you can manually update this value. Beware of raising the value beyond the actual maximum gradient, as this will slow down the render.</td></tr>
<tr><td>RW</td><td>N</td><td>maxTrace</td><td>integer<br/>string</td><td>When used as part of a CSG object, this determines the maximum number of surfaces to look for when constructing the final CSG object. By default, only the <code>containedBy</code> object is examined. For complete accuracy at the expense of speed, use the string <code>"all_intersections".</td></tr>
<tr><td>RW</td><td>N</td><td>open</td><td>boolean</td><td>If <code>true</cope>, the boundaries where the isosurface intersects with the <code>containedBy</code> object will be left open.</td></tr>
<tr><td>RW</td><td>N</td><td>threshold</td><td>float</td><td>The surface appears where the value of <code>source</code> equals this value, which defaults to 0.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>IsoSurface</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>IsoSurface</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>pseudo</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV makes it act similar to one so it can be included in CSG objects. For a <code>IsoSurface</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>IsoSurface</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="IsoSurface">

<h4>JuliaFractal</h4>

<table class="illusBasic"><tr><td>

<p>The <code>JuliaFractal</code> is a three-dimensional slice of a
four-dimensional Julia fractal set. See the <a
href="http://www.povray.org/documentation/3.7.0/r3_4.html#r3_4_5_1_7">POV-Ray
docs</a> for a little more detail. The CephaloPOV interface follows the POV-Ray
model quite closely, the major difference being that POV-Ray's anonymous algebra
type and function type parameters are combined in <code>type</code>.</p>

<div class='code'>var obj = new JuliaFractal({
    juliaParam: [-0.083, 0.0, -0.83, -0.025],
    type: "quaternion:sqr",
    maxIter: 8,
    precision: 15
});</div>

</td><td class='infinite'>

    <img src="img/julia_basic.png">

</td></tr></table>

<h5>Attributes</h5>

<div dh="JuliaFractal">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>juliaParam</td><td>VectorXYZW</td><td>This is the standard julia parameter, <i>p</i>, in <i>f(h) + p</i>.</td></tr>
<tr><td>RW</td><td>Y</td><td>type</td><td>string</td><td>Specifies the type of julia fractal formula used. The legal values are:
<table class="sgrid codeDoc">
<thead>
<tr><th>Julia Fractal Types</th></tr>
</thead><tbody>
<tr><td><code>hypercomplex:acos</code></td></tr>
<tr><td><code>hypercomplex:acosh</code></td></tr>
<tr><td><code>hypercomplex:asin</code></td></tr>
<tr><td><code>hypercomplex:atan</code></td></tr>
<tr><td><code>hypercomplex:atanh</code></td></tr>
<tr><td><code>hypercomplex:cos</code></td></tr>
<tr><td><code>hypercomplex:cosh</code></td></tr>
<tr><td><code>hypercomplex:cube</code></td></tr>
<tr><td><code>hypercomplex:exp</code></td></tr>
<tr><td><code>hypercomplex:ln</code></td></tr>
<tr><td><code>hypercomplex:pwr</code></td></tr>
<tr><td><code>hypercomplex:reciprocal</code></td></tr>
<tr><td><code>hypercomplex:sin</code></td></tr>
<tr><td><code>hypercomplex:sinh</code></td></tr>
<tr><td><code>hypercomplex:sqr</code></td></tr>
<tr><td><code>hypercomplex:tan</code></td></tr>
<tr><td><code>hypercomplex:tanh</code></td></tr>
<tr><td><code>quaternion:cube</code></td></tr>
<tr><td><code>quaternion:sqr</code></td></tr>
</tbody></table>
</td></tr>
<tr><td>RW</td><td>N</td><td>distance</td><td>float</td><td>Specifies the distance of the <code>slice</code> from the origin. Defaults to 0.</td></tr>
<tr><td>RW</td><td>N</td><td>maxIter</td><td>integer</td><td>Determines the number of iterations used to find the surface of the fractal, with higher values being more accurate but slower to render. The default is 20.</td></tr>
<tr><td>RW</td><td>N</td><td>power</td><td>VectorXY</td><td>For the <code>hypercomplex:pwr</code> formula, this <code>VectorXY</code> contains the X and Y exponents used in the calculations. Has no effect on other formula types.</td></tr>
<tr><td>RW</td><td>N</td><td>precision</td><td>integer</td><td>Determines the accuracy of the calculations for finding the surface of the julia set. The default is 20. Higher values result in greater accuracy but longer rendering times.</td></tr>
<tr><td>RW</td><td>N</td><td>slice</td><td>VectorXYZW</td><td>Specifies the 3D slice through 4D space used to view the fractal. Defaults to <code>[0, 0, 0, 1]</code>.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>JuliaFractal</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>JuliaFractal</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>pseudo</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV makes it act similar to one so it can be included in CSG objects. For a <code>JuliaFractal</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>JuliaFractal</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="JuliaFractal">

<h4>Lathe</h4>

<table class="illusBasic"><tr><td>

<p>The <code>Lathe</code> object is a surface of revolution created by sweeping
a spline around the y-axis, centered at the origin. The resulting object is
solid, but the spline will not produce a closed curve unless the first and last
points are the same.</p>

<p>A <code>Lathe</code> is much more flexible than the other surface of revolution
object, <code>Sor</code>, but it is also substantially slower to render.</p>

<div class='code'>var obj = new Lathe({
    points: [
        [0, -1.2],
        [1, -1.2],
        [1, -0.8],
        [0.8, -0.6],
        [0.8, -0.4],
        [1, -0.4],
        [1, -0.2],
        [0.8, -0.2],
        [0.8, 0],
        [1, 0],
        [1, 0.2],
        [0.8, 0.2],
        [0.6, 0.8],
        [0.6, 1.2],
        [0.8, 1.2],
        [0.8, 1.4],
        [0, 1.4]
    ],
    type: "linearSpline"
});</div>

</td><td class='infinite'>

    <img src="img/lathe_basic.png">

</td></tr></table>



<h5>Attributes</h5>

<div dh="Lathe">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>points</td><td>VectorXY</td><td>An array of points defining the spline.</td></tr>
<tr><td>RW</td><td>Y</td><td>type</td><td>string</td><td>Determines the type of spline used to define the profile. Legal types are <code>"bezierSpline"</code>, <code>"cubicSpline"</code>, <code>"linearSpline"</code>, and <code>"quadraticSpline"</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>sturm</td><td>boolean</td><td>If <code>true</code>, POV-Ray will use the slower but more accurate Sturmian root solver. Use this if the surface exhibits holes or other imperfections.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Lathe</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Lathe</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>pseudo</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV makes it act similar to one so it can be included in CSG objects. For a <code>Lathe</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Lathe</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Lathe">

<h4>LightSource</h4>

<p>TODO</p>

<h5>Attributes</h5>

<div dh="LightSource">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>color</td><td>Color</td><td>Specifies the color of the light source.</td></tr>
<tr><td>RW</td><td>Y</td><td>location</td><td>VectorXYZ</td><td>Specifies the location of the light source.</td></tr>
<tr><td>RW</td><td>Y</td><td>type</td><td>string</td><td>Determines the type of the light. The legal values are <code>"cylinder"</code>, <code>"point"</code>, and <code>"spotlight"</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>adaptive</td><td>float</td><td>Used with area lights. If defind, POV-Ray will use adaptive sampling in an attempt to speed up rendering. Higher values are more accurate.</td></tr>
<tr><td>RW</td><td>N</td><td>areaIllumination</td><td>boolean</td><td>If <code>true</code>, the experimental support in POV-Ray 3.7 for full area light diffuse and specular illumination is enabled.</td></tr>
<tr><td>RW</td><td>N</td><td>areaLight</td><td>boolean</td><td>If <code>true</code>, the light becomes an area light, and <code>axis1</code>, <code>axis2</code>, <code>size1</code>, and <code>size2</code> must be defined.</td></tr>
<tr><td>RW</td><td>N</td><td>axis1</td><td>VectorXYZ</td><td>When <code>areaLight</code> is <code>true</code>, <code>axis1</code> defines the orientation of the area light along one axis.</td></tr>
<tr><td>RW</td><td>N</td><td>axis2</td><td>VectorXYZ</td><td>When <code>areaLight</code> is <code>true</code>, <code>axis2</code> defines the orientation of the area light along one axis.</td></tr>
<tr><td>RW</td><td>N</td><td>circular</td><td>boolean</td><td>Used with area lights. If <code>true</code>, the default rectilinear grid is modified to approximate a circle or ellipse.</td></tr>
<tr><td>RW</td><td>N</td><td>fadeDistance</td><td>float</td><td>Defines the distance at which the light will be at full intensity.</td></tr>
<tr><td>RW</td><td>N</td><td>fadePower</td><td>float</td><td>Defines the rate at which light intensity decreases with distance beyond <code>fadeDistance</code>. A value of 1 is linear, 2 is quadratic, and so on.</td></tr>
<tr><td>RW</td><td>N</td><td>falloff</td><td>float</td><td>If specified, <code>falloff</code> describes a larger cone than <code>radius</code> within which the light fades from its original intensity to nothing. Note that this will still cast sharp shadows.</td></tr>
<tr><td>RW</td><td>N</td><td>jitter</td><td>boolean</td><td>Used with area lights. If <code>true</code>, the positions of the lights are randomly moved during rendering so that banding effects are minimized. Should not be used with animations.</td></tr>
<tr><td>RW</td><td>N</td><td>looksLike</td><td>Primitive</td><td>Assigns an object (with an implicit <code>noShadow</code> flag) to act as the physical source of the light.</td></tr>
<tr><td>RW</td><td>N</td><td>mediaAttenuation</td><td>boolean</td><td>If <code>true</code>, the light will be attenuated by passing through media. The default is <code>false</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>mediaInteraction</td><td>boolean</td><td>If <code>true</code> (the default), the light will interact with media.</td></tr>
<tr><td>RW</td><td>N</td><td>orient</td><td>boolean</td><td>Used with area lights, and causes the array of lights to be oriented toward every surface being tested. The <code>orient</code> flag can only be used along with <code>circular</code> when both axes are of equal length and use an equal number of samples.</td></tr>
<tr><td>RW</td><td>N</td><td>parallel</td><td>boolean</td><td>If <code>true</code>, all of the light rays will be parallel to the line between <code>location</code> and <code>pointAt</code>. This is useful for simulating very distant light sources like the sun, but be aware that shadows cease to work behind the light plane.</td></tr>
<tr><td>RW</td><td>N</td><td>pointAt</td><td>VectorXYZ</td><td>Specifies the point the spotlight is aimed at.</td></tr>
<tr><td>RW</td><td>N</td><td>projectedThrough</td><td>Primitive</td><td>Specifies an object through which the light rays must pass in order to be visible.</td></tr>
<tr><td>RW</td><td>N</td><td>radius</td><td>float</td><td>Specifies the angle of the cone of light produced by a spotlight.</td></tr>
<tr><td>RW</td><td>N</td><td>shadowless</td><td>boolean</td><td>If <code>true</code>, the light will neither cast shadows nor cause highlights.</td></tr>
<tr><td>RW</td><td>N</td><td>size1</td><td>float</td><td>When <code>areaLight</code> is <code>true</code>, <code>size1</code> defines the number of rows of lights.</td></tr>
<tr><td>RW</td><td>N</td><td>size2</td><td>float</td><td>When <code>areaLight</code> is <code>true</code>, <code>size2</code> defines the number of columns of lights.</td></tr>
<tr><td>RW</td><td>N</td><td>tightness</td><td>float</td><td>The <code>tightness</code> attribute is a number between 0 and 100 that modifies the relationship between <code>radius</code> and <code>falloff</code>. Counterintuitively, lower values produce a sharper, brighter spotlight and higher values produce a dimmer, softer spotlight. To exercise complete control over the spotlight with <code>tightness</code> alone, set <code>radius = 0</code> and <code>falloff = 90</code>.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>LightSource</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>LightSource</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>pseudo</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV makes it act similar to one so it can be included in CSG objects. For a <code>LightSource</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>LightSource</code>, this is always <code>false</code>.</td></td></tr>
</tbody></table>
</div dh="LightSource">

<h4>Merge</h4>

<p>TODO</p>

<h5>Attributes</h5>

<div dh="Merge">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>components</td><td>Array</td><td>An array of objects to merge.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Merge</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Merge</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Merge</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Merge">

<h4>Mesh</h4>

<p>TODO</p>

<h5>Attributes</h5>

<div dh="Mesh">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>triangles</td><td>[Triangle]</td><td>The array of <code>Triangle</code>s comprising the mesh.</td></tr>
<tr><td>RW</td><td>N</td><td>hierarchy</td><td>boolean</td><td>If <code>false</code>, turn off the internal bounding hierarchy.</td></tr>
<tr><td>RW</td><td>N</td><td>insideVector</td><td>VectorXYZ</td><td>For the <code>Mesh</code> to be solid, it must be completely closed and have a defined <code>insideVector</code>.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Mesh</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Mesh</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>pseudo</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV makes it act similar to one so it can be included in CSG objects. For a <code>Mesh</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Mesh</code>, this is always <code>false</code>.</td></td></tr>
</tbody></table>
</div dh="Mesh">

<h4>Ovus</h4>

<table class="illusBasic"><tr><td>

<p>The <code>Ovus</code> type is one of POV-Ray's more interesting and versatile
geometric primitives. It consists of two spheres defined by
<code>bottomRadius</code> and <code>topRadius</code> such that the center of the
top sphere is positioned on the top of the bottom sphere, and then a smooth
curved surface connects the two. The center of the bottom sphere is at the
origin, and the centers of both spheres are aligned along the y-axis.</p>

<p>In the example code below, the result is the egg-like shape to the right, but
a wide variety of other shapes can be constructed with it.</p>

<div class='code'>var obj = new Ovus({
    bottomRadius: 2,
    topRadius: 1
});</div>

</td><td>

    <img src="img/ovus_basic.png">

</td></tr></table>

<h5>Attributes</h5>

<div dh="Ovus">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>bottomRadius</td><td>float</td><td>Sets the radius of the bottom sphere.</td></tr>
<tr><td>RW</td><td>Y</td><td>topRadius</td><td>float</td><td>Sets the radius of the top sphere.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Ovus</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Ovus</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>pseudo</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV makes it act similar to one so it can be included in CSG objects. For a <code>Ovus</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Ovus</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Ovus">

<h4>Parametric</h4>

<p>TODO</p>

<h5>Attributes</h5>

<div dh="Parametric">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>funcX</td><td>SDL</td><td>Determines the X coordinate of the surface.</td></tr>
<tr><td>RW</td><td>Y</td><td>funcY</td><td>SDL</td><td>Determines the Y coordinate of the surface.</td></tr>
<tr><td>RW</td><td>Y</td><td>funcZ</td><td>SDL</td><td>Determines the Z coordinate of the surface.</td></tr>
<tr><td>RW</td><td>Y</td><td>uv1</td><td>VectorUV</td><td>Specifies one corner of the UV plane to which the surface is mapped.</td></tr>
<tr><td>RW</td><td>Y</td><td>uv2</td><td>VectorUV</td><td>Specifies the other corner of the UV plane to which the surface is mapped.</td></tr>
<tr><td>RW</td><td>N</td><td>accuracy</td><td>float</td><td>Defines the amount of subdivision POV-Ray performs to find the surface, with lower values being more accurate. Defaults to 0.001.</td></tr>
<tr><td>RW</td><td>N</td><td>containedBy</td><td>Sphere<br/>Box</td><td>Defines a <code>Sphere</code> or <code>Box</code> which determines the portion of the (potentially infinite) surface that POV-Ray will render. By default, this is a <code>Box</code> with corners at <code>[1, 1, 1]</code> and <code>[-1, -1, -1]</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>maxGradient</td><td>float</td><td>Rendering will be faster if POV-Ray knows the maximum gradient of the surface functions. The <code>maxGradient</code> value defaults to 1.1, but if this too low, holes and other imperfections may appear, and POV-Ray will emit a warning telling you the maximum gradient it found so that you can manually update this value. Beware of raising the value beyond the actual maximum gradient, as this will slow down the render.</td></tr>
<tr><td>RW</td><td>N</td><td>precomputeDepth</td><td>integer</td><td>If defined, <code>precomputeDepth</code> can speed up rendering at the expense of memory. The maximum value is 20. At least one of <code>precomputeX</code>, <code>precomputeY</code>, or <code>precomputeZ</code> must be <code>true</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>precomputeX</td><td>boolean</td><td>Enables precalculation of the X coordinate during subdivision of parametric surfaces. <code>precomputeDepth</code> must also be defined.</td></tr>
<tr><td>RW</td><td>N</td><td>precomputeY</td><td>boolean</td><td>Enables precalculation of the Y coordinate during subdivision of parametric surfaces. <code>precomputeDepth</code> must also be defined.</td></tr>
<tr><td>RW</td><td>N</td><td>precomputeZ</td><td>boolean</td><td>Enables precalculation of the Z coordinate during subdivision of parametric surfaces. <code>precomputeDepth</code> must also be defined.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Parametric</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Parametric</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>pseudo</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV makes it act similar to one so it can be included in CSG objects. For a <code>Parametric</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Parametric</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Parametric">

<h4>Plane</h4>

<table class="illusBasic"><tr><td>

<p>Arguably POV-Ray's simplest primitive, the <code>Plane</code> is an infinite
solid dividing all space into two halves. It is defined by a
<code>distance</code> from the origin and a <code>normal</code> which determines
the orientation of its surface. It provides a convenient infinite ground plane,
of course, but because it creates a solid half-surface, you can use a CSG
<code>Intersection</code> of planes to create complex shapes like solid
polyhedra.</p>

<p>In the example below, the plane is oriented perpendicularly to the y-axis at
the origin. Its infinite extent is amusingly clear in the rendering to the
right, where our standard demonstration stage looks like it has been caught in a
flood!</p>

<div class='code'>var obj = new Plane({
    distance: 0,
    normal: [0, 1, 0]
});</div>

</td><td class='infinite'>

    <img src="img/plane_basic.png">

</td></tr></table>

<h5>Attributes</h5>

<div dh="Plane">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>distance</td><td>float</td><td>Specifies the distance the plane lies from the origin along the <code>normal</code> vector. This is multiplied by the normal, so if <code>distance</code> is 2 and <code>normal</code> is <code>[0, 2, 0]</code>, the plane will lie 4 units from the origin.</td></tr>
<tr><td>RW</td><td>Y</td><td>normal</td><td>VectorXYZ</td><td>Defines the surface normal of the plane, i.e., a vector that points up perpendicularly from the surface of the plane.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Plane</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Plane</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>pseudo</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV makes it act similar to one so it can be included in CSG objects. For a <code>Plane</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Plane</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Plane">

<h4>Poly</h4>

<p>TODO</p>

<h5>Attributes</h5>

<div dh="Poly">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>coefficients</td><td>[float]</td><td>An array defining the coefficients of the polynomial. The number of coefficients required is equal to ((<code>order</code> + 1) * (<code>order</code> + 2) * (<code>order</code> + 3)) / 6.</td></tr>
<tr><td>RW</td><td>Y</td><td>order</td><td>integer</td><td>Specifies the order of the polynomial. Must be in the range 2 to 35.</td></tr>
<tr><td>RW</td><td>N</td><td>sturm</td><td>boolean</td><td>If <code>true</code>, POV-Ray will use the slower but more accurate Sturmian root solver. Use this if the surface exhibits holes or other imperfections.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Poly</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Poly</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>pseudo</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV makes it act similar to one so it can be included in CSG objects. For a <code>Poly</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Poly</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Poly">

<h4>Polygon</h4>

<table class="illusBasic"><tr><td>

<p>Another versatile two-dimensional primitive, the <code>Polygon</code> type is
defined by it's sole <code>points</code> parameter, which is an array of
<code>VectorXY</code> points listing the vertices of an arbitrary polygon on the
XY-plane. For a simple polygon, a line will automatically connect the first
and last points. If the first point of the polygon is repeated, subsequent points
create an additional polygon which, if it is enclosed in the first (or another) polygon,
defines a hole in it.</p>

<p>In the example code below, two rectangles are defined with the second being a hole
in the first. Thanks to the polygons' position on the XY-plane and the position
of the <code>LightSource</code> illuminating the scene, it appears completely black but
is in fact the same color as all the other examples.</p>

<div class='code'>var obj = new Polygon({
    points: [[-2, 2], [2, 2], [2, -2], [-2, -2], [-2, 2],
        [-1, 1], [1, 1], [1, -1], [-1, -1], [-1, 1]],
});</div>

</td><td class='infinite'>

    <img src="img/polygon_basic.png">

</td></tr></table>

<h5>Attributes</h5>

<div dh="Polygon">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>points</td><td>[VectorXY]</td><td>This is an array of at least three <code>VectorXY</code> objects defining the vertices of the polygon.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Polygon</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Polygon</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>pseudo</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV makes it act similar to one so it can be included in CSG objects. For a <code>Polygon</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Polygon</code>, this is always <code>false</code>.</td></td></tr>
</tbody></table>
</div dh="Polygon">

<h4>Polynomial</h4>

<p>TODO</p>

<h5>Attributes</h5>

<div dh="Polynomial">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>coefficients</td><td>[VectorXYZW]</td><td>An array of <code>VectorXYZW</code> defining the coefficients of the polynomial. The choice of <code>VectorXYZW</code> is a bit of a convenience hack as it doesn't encode a 4D cartesian point. Instead, the X, Y, and Z values specify the corresponding powers of the coefficient and W specifies the value. The members of the array can be specified in any order.</td></tr>
<tr><td>RW</td><td>Y</td><td>order</td><td>integer</td><td>Specifies the order of the polynomial. Must be in the range 2 to 35.</td></tr>
<tr><td>RW</td><td>N</td><td>sturm</td><td>boolean</td><td>If <code>true</code>, POV-Ray will use the slower but more accurate Sturmian root solver. Use this if the surface exhibits holes or other imperfections.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Polynomial</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Polynomial</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>pseudo</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV makes it act similar to one so it can be included in CSG objects. For a <code>Polynomial</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Polynomial</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Polynomial">

<h4>Prism</h4>

<table class="illusBasic"><tr><td>

<p>The <code>Prism</code> type is the three-dimensional analogue of the
<code>Polygon</code>. It sweeps the shape defined by the array of
<code>VectorXY</code> in the <code>points</code> parameter along the y-axis from
<code>height1</code> to <code>height2</code>. The points may define multiple
sub-polygons provided that each polygon is closed by repeating the first point
as the last.</p>

<p>Unlike <code>Polygon.points</code>, <code>Prism.points</code> may specify
more than just simple linear splines depending on the value of <code>type</code>.</p>

<p>The example below uses the same <code>points</code> argument as the example for
the <code>Polygon</code>.</p>

<div class='code'>var obj = new Polygon({
    height1: -2,
    height2: 2,
    type: "linearSpline",
    points: [[-2, 2], [2, 2], [2, -2], [-2, -2], [-2, 2],
        [-1, 1], [1, 1], [1, -1], [-1, -1], [-1, 1]],
});</div>

</td><td class='infinite'>

    <img src="img/prism_basic.png">

</td></tr></table>

<h5>Attributes</h5>

<div dh="Prism">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>height1</td><td>float</td><td>Specifies the Y coordinate of the top of the prism.</td></tr>
<tr><td>RW</td><td>Y</td><td>height2</td><td>float</td><td>Specifies the Y coordinate of the bottom of the prism.</td></tr>
<tr><td>RW</td><td>Y</td><td>points</td><td>Array</td><td>The array of spline points to be swept along the Y axis. This can specify multiple sub-shapes: to close a shape, simply repeat the first coordinate. When using any <code>type</code> other than <code>linearSpline</code>, all shapes must be closed.</td></tr>
<tr><td>RW</td><td>Y</td><td>type</td><td>string</td><td>Specifies the spline type used for the prism. The legal values are <code>"bezierSpline"</code>, <code>"conicSweep"</code>, <code>"cubicSpline"</code>, <code>"linearSpline"</code>, <code>"linearSweep"</code>, and <code>"quadraticSpline"</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>open</td><td>boolean</td><td>If <code>true</code>, the top and bottom of the prism are left open.</td></tr>
<tr><td>RW</td><td>N</td><td>sturm</td><td>boolean</td><td>If <code>true</code>, POV-Ray will use the slower but more accurate Sturmian root solver. Use this if the surface exhibits holes or other imperfections.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Prism</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Prism</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>pseudo</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV makes it act similar to one so it can be included in CSG objects. For a <code>Prism</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Prism</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Prism">

<h4>Quadric</h4>

<p>TODO</p>

<h5>Attributes</h5>

<div dh="Quadric">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>coefficients</td><td>Array</td><td>An array of 10 floats defining the coefficients of a second-order polynomial.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Quadric</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Quadric</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>pseudo</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV makes it act similar to one so it can be included in CSG objects. For a <code>Quadric</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Quadric</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Quadric">

<h4>Quartic</h4>

<p>TODO</p>

<h5>Attributes</h5>

<div dh="Quartic">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>coefficients</td><td>Array</td><td>An array of floats defining the coefficients of a fourth-order polynomial.</td></tr>
<tr><td>RW</td><td>N</td><td>sturm</td><td>boolean</td><td>If <code>true</code>, POV-Ray will use the slower but more accurate Sturmian root solver. Use this if the surface exhibits holes or other imperfections.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Quartic</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Quartic</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>pseudo</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV makes it act similar to one so it can be included in CSG objects. For a <code>Quartic</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Quartic</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Quartic">

<h4>Sor</h4>

<p>TODO</p>

<h5>Attributes</h5>

<div dh="Sor">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>points</td><td>VectorXY</td><td>An array of at least two points which define the open curve used to generate the surface.</td></tr>
<tr><td>RW</td><td>N</td><td>open</td><td>boolean</td><td>If <code>true</code>, the base and the cap are left open, yielding a hollow surface of revolution.</td></tr>
<tr><td>RW</td><td>N</td><td>sturm</td><td>boolean</td><td>If <code>true</code>, POV-Ray will use the slower but more accurate Sturmian root solver. Use this if the surface exhibits holes or other imperfections.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Sor</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Sor</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>pseudo</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV makes it act similar to one so it can be included in CSG objects. For a <code>Sor</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Sor</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Sor">

<h4>Sphere</h4>

<table class="illusBasic"><tr><td>

<p>The <code>Sphere</code> is defined by the coordinates of its
<code>center</code> and the measure of its <code>radius</code>. The example at
right was created by the following code:</p>

<div class='code'>var obj = new Sphere({
    center: [0, 0, 0],
    radius: 2
});</div>

<p>The optional <code>strength</code> parameter does nothing with an independent
<code>Sphere</code>, but when the object is part of a <code>Blob</code>, it sets
the field strength.

</td><td>

    <img src="img/sphere_basic.png">

</td></tr></table>

<h5>Attributes</h5>

<div dh="Sphere">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>center</td><td>VectorXYZ</td><td>Defines the center point of the sphere.</td></tr>
<tr><td>RW</td><td>Y</td><td>radius</td><td>float</td><td>Specifies the radius of the sphere.</td></tr>
<tr><td>RW</td><td>N</td><td>strength</td><td>float</td><td>If and only if the <code>Sphere</code> is being used as a blob component, <code>strength</code> is a float defining its field strength.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Sphere</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Sphere</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>pseudo</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV makes it act similar to one so it can be included in CSG objects. For a <code>Sphere</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Sphere</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Sphere">

<h4>SphereSweep</h4>

<p>TODO</p>

<h5>Attributes</h5>

<div dh="SphereSweep">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>spheres</td><td>Array</td><td>The array of <code>Sphere</code>s whose positions are interpolated to create the sweep.</td></tr>
<tr><td>RW</td><td>Y</td><td>type</td><td>string</td><td>Sets the spline type to be used for the sweep. The legal values are <code>"bezierSpline"</code>, <code>"cubicSpline"</code>, and <code>"linearSpline"</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>tolerance</td><td>float</td><td>Defines the depth tolerance used for intersection calculations. The default value, 0.000001, should be adequate in most cases. If imperfections appear on the surface of the sweep, try increasing it to 0.0001.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>SphereSweep</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>SphereSweep</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>pseudo</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV makes it act similar to one so it can be included in CSG objects. For a <code>SphereSweep</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>SphereSweep</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="SphereSweep">

<h4>Superellipsoid</h4>

<table class="illusBasic"><tr><td>

<p>The <code>Superellipsoid</code> type implements what is more properly known
as a superquadric ellipsoid whose shape can vary from a cube with rounded edges
to fat, egg-like cylinders. It is defined solely by two float parameters,
<code>e</code> and <code>n</code>, the so-called east-west and north-south
exponents, respectively. It occupies roughly the same space as a <code>Box</code>
with corners at <code>[1, 1, 1]</code> and <code>[-1, -1, -1]</code>.</p>

<p>As the example code and rendering indicate, when <code>e</code> and <code>n</code>
have the same value, the result is a cube with rounded edges. When both values reach
1.0, the result is equivalent to a unit sphere.</p>

<div class='code'>var obj = new Superellipsoid({
    e: 0.25,
    n: 0.25
});</div>

</td><td class='infinite'>

    <img src="img/superellipsoid_basic.png">

</td></tr></table>

<h5>Attributes</h5>

<div dh="Superellipsoid">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>e</td><td>float</td><td>Defines the so-called <em>east-west</em> exponent.</td></tr>
<tr><td>RW</td><td>Y</td><td>n</td><td>float</td><td>Defines the so-called <em>north-south</em> exponent.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Superellipsoid</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Superellipsoid</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>pseudo</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV makes it act similar to one so it can be included in CSG objects. For a <code>Superellipsoid</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Superellipsoid</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Superellipsoid">

<h4>Text</h4>

<p>TODO</p>

<h5>Attributes</h5>

<div dh="Text">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>displayText</td><td>string</td><td>This contains the text to be rendered.</td></tr>
<tr><td>RW</td><td>Y</td><td>font</td><td>string</td><td>The filename of the font.</td></tr>
<tr><td>RW</td><td>Y</td><td>fontType</td><td>string</td><td>Specifies the file format of the font being used. Legal values are <code>"ttc"</code>, and <code>"ttf"</code>.</td></tr>
<tr><td>RW</td><td>Y</td><td>offset</td><td>float</td><td>If defined, specifies extra space to be placed between characters.</td></tr>
<tr><td>RW</td><td>Y</td><td>thickness</td><td>float</td><td>Specifies the front-to-back thickness of the extruded character shapes.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Text</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Text</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>pseudo</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV makes it act similar to one so it can be included in CSG objects. For a <code>Text</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Text</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Text">

<h4>Torus</h4>

<table class="illusBasic"><tr><td>

<p>The <code>Torus</code> type specifies a torus with its major and minor radii.
If you think of a torus as the surface described by a smaller two-dimensional
ring swept perpendicularly to a larger ring, the <code>majorRadius</code> is the
radius of the larger ring, and the <code>minorRadius</code> is the radius of the
smaller ring.</p>

<p>The example code and rendering demonstrates a <code>Torus</code> with a minor radius
of 0.5 units and a major radius of 2 units.</p>

<div class='code'>var obj = new Torus({
    minorRadius: 0.5,
    majorRadius: 2,
    texture: texture
});</div>

</td><td class='infinite'>

    <img src="img/torus_basic.png">

</td></tr></table>

<h5>Attributes</h5>

<div dh="Torus">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>majorRadius</td><td>float</td><td>Defines the major radius of the torus, which is the circle along which the perpendicular circle defined by <code>minorRadius</code> is swept.</td></tr>
<tr><td>RW</td><td>Y</td><td>minorRadius</td><td>float</td><td>Defines the minor radius of the torus, which is the radius of its cross section.</td></tr>
<tr><td>RW</td><td>N</td><td>sturm</td><td>float</td><td>If <code>true</code>, POV-Ray will use the slower but more accurate Sturmian root solver. Use this if the surface exhibits holes or other imperfections.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Torus</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Torus</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>pseudo</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV makes it act similar to one so it can be included in CSG objects. For a <code>Torus</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Torus</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Torus">

<h4>Triangle</h4>

<p>TODO</p>

<h5>Attributes</h5>

<div dh="Triangle">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>corner1</td><td>VectorXYZ</td><td>Defines the first corner of the triangle.</td></tr>
<tr><td>RW</td><td>Y</td><td>corner2</td><td>VectorXYZ</td><td>Defines the second corner of the triangle.</td></tr>
<tr><td>RW</td><td>Y</td><td>corner3</td><td>VectorXYZ</td><td>Defines the third corner of the triangle.</td></tr>
<tr><td>RW</td><td>N</td><td>normal1</td><td>VectorXYZ</td><td>Specifies the surface normal for <code>corner1</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>normal2</td><td>VectorXYZ</td><td>Specifies the surface normal for <code>corner2</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>normal3</td><td>VectorXYZ</td><td>Specifies the surface normal for <code>corner3</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>smooth</td><td>boolean</td><td>If <code>smooth</code> is <code>true</code> and <code>normal1...3</code> are defined, the triangle will be output as a smooth triangle.</td></tr>
<tr><td>RW</td><td>N</td><td>textures</td><td>VectorXYZ</td><td class='dummy'>TODO: Lorem ipsum dolor sit amet, consectetur adipiscing elit. Fusce nec tellus quis turpis pretium condimentum ut eget neque. Integer pharetra imperdiet elit, eu malesuada tortor.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Triangle</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Triangle</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>pseudo</td><td>boolean</td><td>If <code>true</code>, the object is not actually a POV-Ray primitive object, but CephaloPOV makes it act similar to one so it can be included in CSG objects. For a <code>Triangle</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Triangle</code>, this is always <code>false</code>.</td></td></tr>
</tbody></table>
</div dh="Triangle">

<h4>Union</h4>

<h5>Attributes</h5>

<p>TODO</p>

<div dh="Union">
<table class='sgrid attrs'>
<thead>
<tr><th>&nbsp;</th><th>Req</th><th>Name</th><th>Type(s)</th><th>Description</th></tr>
<thead><tbody>
<tr><td>RW</td><td>Y</td><td>components</td><td>Array</td><td>This is the array of objects to be combined by the CSG <code>Union</code>.</td></tr>
<tr><td>RW</td><td>N</td><td>splitUnion</td><td>boolean</td><td>If the composite object lacks holes, setting <code>splitUnion</code> to <code>false</code> can speed up rendering. Defaults to <code>true</code>.</td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>csg</td><td>boolean</td><td>If <code>true</code>, the primitive is a composite CSG container. For a <code>Union</code>, this is always <code>true</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>finite</td><td>boolean</td><td>If <code>true</code>, the shape is finite in extent. For a <code>Union</code>, this is always <code>false</code>.</td></td></tr>
<tr><td>RO</td><td>&nbsp;</td><td>solid</td><td>boolean</td><td>If <code>true</code>, the shape is solid. For a <code>Union</code>, this is always <code>true</code>.</td></td></tr>
</tbody></table>
</div dh="Union">


<h2>Appendices</h2>

<p><span class='h2num'></span>The appendices contain further details and discussions about
CephaloPOV and ray tracing supplementary to the main text.</p>

<p><br/><br/><br/><br/><br/><br/><br/></p>

<h3>Matrices</h3>

<p>SDL matrices are an abbreviated form of the entire matrix being used. The
fourth column is invariant and therefore omitted from its SDL representation and
inaccessible within CephaloPOV, but we show it below in grey for the
math-curious. You <em>don't</em> have to know much about matrix math to use the
<code>Matrix</code> class. Like SDL, CephaloPOV offers shortcuts to the
individual transformations in the form of special arguments to the
<code>Matrix</code> constructor and the <code>apply</code> method.</p>

<h4>Translation, Scaling, and Skewing</h4>

<p>Red elements determine scaling, blue elements determine translation, and
green elements determine skewing. (The grey elements, as previously mentioned,
are invariant and hidden in both POV-Ray and CephaloPOV.) Note that there are
three elements for each axis when scaling and translating, but there are six
elements for skewing, because skew transformations involve relationships between
pairs of axes.</p>

<table class='matrixDemo'>
    <tr><th></th><th>Column<br/>0</th><th>Column<br/>1</th><th>Column<br/>2</th><th>Column<br/>3</th></tr>
    <tr>
        <th>Row<br/>0</th>
        <td class='scale'><div class='cpName'>v00</div><div class='op'>Scale X</div></td>
        <td class='skew'><div class='cpName'>v01</div><div class='op'>Skew Y by X</div></td>
        <td class='skew'><div class='cpName'>v02</div><div class='op'>Skew Z by X</div></td>
        <td class='implicit'><div class='cpName'>(v03)</div><div class='op'>0</div></td>
    </tr><tr>
        <th>Row<br/>1</th>
        <td class='skew'><div class='cpName'>v10</div><div class='op'>Skew X by Y</div></td>
        <td class='scale'><div class='cpName'>v11</div><div class='op'>Scale Y</div></td>
        <td class='skew'><div class='cpName'>v12</div><div class='op'>Skew Z by Y</div></td>
        <td class='implicit'><div class='cpName'>(v13)</div><div class='op'>0</div></td>
    </tr><tr>
        <th>Row<br/>2</th>
        <td class='skew'><div class='cpName'>v20</div><div class='op'>Skew X by Z</div></td>
        <td class='skew'><div class='cpName'>v21</div><div class='op'>Skew Y by Z</div></td>
        <td class='scale'><div class='cpName'>v22</div><div class='op'>Scale Z</div></td>
        <td class='implicit'><div class='cpName'>(v23)</div><div class='op'>0</div></td>
    </tr><tr>
        <th>Row<br/>3</th>
        <td class='translate'><div class='cpName'>v30</div><div class='op'>Translate X</div></td>
        <td class='translate'><div class='cpName'>v31</div><div class='op'>Translate Y</div></td>
        <td class='translate'><div class='cpName'>v32</div><div class='op'>Translate Z</div></td>
        <td class='implicit'><div class='cpName'>(v33)</div><div class='op'>1</div></td>
    </tr>
</table>

<p>An important thing to notice here is that while the matrix elements that
determine translation and skewing are 0 if no translation or skewing is to be
done, the elements that define scaling must be 1 when no scaling is to be done,
i.e., it's an identity element. Setting the scaling elements to zero will make
the object disappear!</p>

<p>Another thing to notice about scaling is that negative values will
<em>reflect</em> the object across the relevant axis. In the special case of 1,
this will be a perfect mirror image; other values will stretch or squash the
object.</p>

<h4>Rotation</h4>

<p>Rotation is a little more complicated because it requires the use of
trigonometric functions. This is handled for you by the Matrix class'
<code>rotate</code> constructor argument, but it's worth understanding in case
you want to try doing the calculations yourself or trying variations to see what
they do.</p>

<p>Since the values for rotations around the axes overlap, we'll omit the
invariant fourth column and the translation row so we can cram all three
rotation matrices into a single row. In this case, we'll color the rotation
elements red, the single scale identity element blue, and everything else grey.
If you're entirely innocent of trigonometry, know that <i>cos</i> and <i>sin</i>
are the trigonometric functions cosine and sine, which are implemented in
JavaScript as the <code>Math.cos()</code> and <code>Math.sin()</code> methods.
The angle of rotation is conventionally represented by the Greek letter theta,
&theta;, and is specified in radians, though POV-Ray and CephaloPOV expect you
to use degrees instead and quietly translate degrees into radians for you.</p>


<table style='width: 100%;'>
    <tr>
        <td style='width: 33%;'>

            <table class='matrixDemo'>
                <tr><th colspan='4'>Rotation around the X axis</th></tr>
                <tr><th></th><th>Col.<br/>0</th><th>Col.<br/>1</th><th>Col.<br/>2</th></tr>
                <tr>
                    <th>Row<br/>0</th>
                    <td class='ident'><div class='cpName'>v00</div><div class='op'>1</div></td>
                    <td class='null'><div class='cpName'>v01</div><div class='op'>0</div></td>
                    <td class='null'><div class='cpName'>v02</div><div class='op'>0</div></td>
                </tr><tr>
                    <th>Row<br/>1</th>
                    <td class='null'><div class='cpName'>v10</div><div class='op'>0</div></td>
                    <td class='rotate'><div class='cpName'>v11</div><div class='op'><i>cos</i>(&theta;)</div></td>
                    <td class='rotate'><div class='cpName'>v12</div><div class='op'><i>sin</i>(&theta;)</div></td>
                </tr><tr>
                    <th>Row<br/>2</th>
                    <td class='null'><div class='cpName'>v20</div><div class='op'>0</div></td>
                    <td class='rotate'><div class='cpName'>v21</div><div class='op'>-<i>sin</i>(&theta;)</div></td>
                    <td class='rotate'><div class='cpName'>v22</div><div class='op'><i>cos</i>(&theta;)</div></td>
                </tr>
            </table>

        </td><td style='width: 33%;'>

            <table class='matrixDemo'>
                <tr><th colspan='4'>Rotation around the Y axis</th></tr>
                <tr><th></th><th>Col.<br/>0</th><th>Col.<br/>1</th><th>Col.<br/>2</th></tr>
                <tr>
                    <th>Row<br/>0</th>
                    <td class='rotate'><div class='cpName'>v00</div><div class='op'><i>cos</i>(&theta;)</div></td>
                    <td class='null'><div class='cpName'>v01</div><div class='op'>0</div></td>
                    <td class='rotate'><div class='cpName'>v02</div><div class='op'>-<i>sin</i>(&theta;)</div></td>
                </tr><tr>
                    <th>Row<br/>1</th>
                    <td class='null'><div class='cpName'>v10</div><div class='op'>0</div></td>
                    <td class='ident'><div class='cpName'>v11</div><div class='op'>1</div></td>
                    <td class='null'><div class='cpName'>v12</div><div class='op'>0</div></td>
                </tr><tr>
                    <th>Row<br/>2</th>
                    <td class='rotate'><div class='cpName'>v20</div><div class='op'><i>sin</i>(&theta;)</div></td>
                    <td class='null'><div class='cpName'>v21</div><div class='op'>0</div></td>
                    <td class='rotate'><div class='cpName'>v22</div><div class='op'><i>cos</i>(&theta;)</div></td>
                </tr>
            </table>

        </td><td style='width: 33%;'>

            <table class='matrixDemo'>
                <tr><th colspan='4'>Rotation around the Z axis</th></tr>
                <tr><th></th><th>Col.<br/>0</th><th>Col.<br/>1</th><th>Col.<br/>2</th></tr>
                <tr>
                    <th>Row<br/>0</th>
                    <td class='rotate'><div class='cpName'>v00</div><div class='op'><i>cos</i>(&theta;)</div></td>
                    <td class='rotate'><div class='cpName'>v01</div><div class='op'><i>sin</i>(&theta;)</div></td>
                    <td class='null'><div class='cpName'>v02</div><div class='op'>0</div></td>
                </tr><tr>
                    <th>Row<br/>1</th>
                    <td class='rotate'><div class='cpName'>v10</div><div class='op'>-<i>sin</i>(&theta;)</div></td>
                    <td class='rotate'><div class='cpName'>v11</div><div class='op'><i>cos</i>(&theta;)</div></td>
                    <td class='null'><div class='cpName'>v12</div><div class='op'>0</div></td>
                </tr><tr>
                    <th>Row<br/>2</th>
                    <td class='null'><div class='cpName'>v20</div><div class='op'>0</div></td>
                    <td class='null'><div class='cpName'>v21</div><div class='op'>0</div></td>
                    <td class='ident'><div class='cpName'>v22</div><div class='op'>1</div></td>
                </tr>
            </table>

        </td>
    </tr>
</table>

<p>Note the sign of the sine functions. These are specific to the left-handed
coordinate system that POV-Ray uses. In a right-handed system, you'd reverse the
signs.</p>

<p>If you want to know more, Jeff Lee's <a
href="https://www.shipbrook.net/jeff/raytrace/matrix.html">POV-Ray-specific
tutorial</a> is a good place to start, as are these <a
href="https://courses.cs.washington.edu/courses/cse457/99au/handouts/lectures/3d-transformations.pdf">course
notes</a>. To dig deeper than that&mdash;and there's a <em>lot</em> more you can
do with matrices&mdash;the topic is covered in depth in 3D graphics and linear
algebra textbooks. And don't be scared off: it's far more tedious than
difficult. Choose a simple shape, try fiddling with different elements and
different functions, and look at the results of a rendering.</p>


<h3>CephaloPOV Internals</h3>

<pre>The gsDef, ioDef, primitiveDef, and objDef objects follow similar forms and
are mainly used by codegen.js to crank out the mountain of repetitive boiler-
plate code needed to manage POV-Ray's large set of objects and values.

   gsDef ........... Defines the parameters of the global_settings block.

   ioDef ........... Defines the parameters of POV-Ray's image options, which
                     may be output as .ini files or as CLI switches.

   primitiveDef .... Defines the members of the Primitive base class from
                     which all geometric primitives plus CSG objects, lights,
                     and cameras are subclassed.

   objDef .......... Defines all of the subclasses of Primitive.

They each use some or all of the following parameters:

   desc ......... A human-readable description of the object or class, to be
                  placed in a header comment in the generated code.

   conArgs ...... Custom constructor arguments, supplied as a string.

   conBlock ..... Name of the snippet to be placed in the constructor in
                  lieu of the default code.

   snippets ..... List of snippets to append to the class after the standard
                  accessor methods.

   superclass ... Name of superclass; causes generation of extends clause and
                  automatically calls super() in the constructor.

   immutable .... Read-only properties of the object. These are:

                      csg:    Is this a CSG primitive, e.g., Union or Merge.
                      finite: Is this a finite primitive?
                      solid:  Is this a solid primitive?
                      pseudo: Is this an object that isn't actually a
                              POV-Ray primitive that CephaloPOV does extra
                              work to get it to behave like one? Currently,
                              this is only true for Camera.

   mutable ...... Read-write properties of the object. These are:

                      name:   Name of the property, e.g. assumedGamma
                      valid:  Validation conditional
                      err:    Error message to display on validation failure
                      req:    If true, this value must be set before output
                      custom: The name of the snippet to substitute for the
                              auto-generated accessor methods.
                      child:  "scalar" or "array" indicates that this
                              property is itself a primitive or array of
                              primitives whose parent property should be
                              updated upon assignment.
                      dperm:  If present, overrides the RW designation

cpov.vectorDef follows the same format, but the odds of it being entirely
replaced before the first public beta are quite high.</pre>




<h2>Administrivia</h2>

<h3>TODO</h3>

<h4>Milestone C1: Phase 0, Part 1</h4>

<table class='sgrid todo'>
    <thead>
        <tr>
            <th>Status</th>
            <th>Type</th>
            <th>Description</th>
        </tr>
    <thead><tbody>
        <!-- <tr><td></td><td></td><td></td></tr> -->
        <tr><td class='pending'>pending</td><td>Implement</td><td>Document the various spline types.</td></tr>
        <tr><td class='pending'>pending</td><td>Implement/Test</td><td>Atmospheric effects</td></tr>

        <tr><td class='working'>working</td><td>Implement/Test</td><td>Texture subsystem</td></tr>
            <tr><td class='working'>working</td><td>Implement/Test</td><td class='subtask'><code>Normal</code> and <code>NormalMap</code></td></tr>
            <tr><td class='working'>working</td><td>Implement/Test</td><td class='subtask'><code>Pigment</code> and <code>PigmentMap</code></td></tr>
            <tr><td class='working'>working</td><td>Implement/Test</td><td class='subtask'><code>Texture</code> and <code>TextureMap</code></td></tr>

        <tr><td class='working'>working</td><td>Implement/Test</td><td>Documentation illustration generator script, further tests</td></tr>
            <tr><td class='working'>working</td><td>Implement/Test</td><td class='subtask'>Illustration stage generator: <span class='fixme'>translucent</span> XYZ planes, n x n, <span class='fixme'>adjust camera</span></td></tr>
            <tr><td class='pending'>pending</td><td>Implement/Test</td><td class='subtask'><code>Camera</code> description and example</td></tr>
            <tr><td class='pending'>pending</td><td>Implement/Test</td><td class='subtask'><code>Cubic</code> description and example</td></tr>
            <tr><td class='pending'>pending</td><td>Implement/Test</td><td class='subtask'><code>Difference</code> description and example</td></tr>
            <tr><td class='pending'>pending</td><td>Implement/Test</td><td class='subtask'><code>HeightField</code> description and example</td></tr>
            <tr><td class='pending'>pending</td><td>Implement/Test</td><td class='subtask'><code>Intersection</code> description and example</td></tr>
            <tr><td class='pending'>pending</td><td>Implement/Test</td><td class='subtask'><code>IsoSurface</code> description and example</td></tr>
            <tr><td class='pending'>pending</td><td>Implement/Test</td><td class='subtask'><code>Lathe</code> description and example</td></tr>
            <tr><td class='pending'>pending</td><td>Implement/Test</td><td class='subtask'><code>LightSource</code> description and example</td></tr>
            <tr><td class='pending'>pending</td><td>Implement/Test</td><td class='subtask'><code>Merge</code> description and example</td></tr>
            <tr><td class='pending'>pending</td><td>Implement/Test</td><td class='subtask'><code>Mesh</code> description and example</td></tr>
            <tr><td class='pending'>pending</td><td>Implement/Test</td><td class='subtask'><code>Parametric</code> description and example</td></tr>
            <tr><td class='pending'>pending</td><td>Implement/Test</td><td class='subtask'><code>Poly</code> description and example</td></tr>
            <tr><td class='pending'>pending</td><td>Implement/Test</td><td class='subtask'><code>Polynomial</code> description and example</td></tr>
            <tr><td class='pending'>pending</td><td>Implement/Test</td><td class='subtask'><code>Primitive</code> description and example</td></tr>
            <tr><td class='pending'>pending</td><td>Implement/Test</td><td class='subtask'><code>Quadric</code> description and example</td></tr>
            <tr><td class='pending'>pending</td><td>Implement/Test</td><td class='subtask'><code>Quartic</code> description and example</td></tr>
            <tr><td class='pending'>pending</td><td>Implement/Test</td><td class='subtask'><code>Sor</code> description and example</td></tr>
            <tr><td class='pending'>pending</td><td>Implement/Test</td><td class='subtask'><code>SphereSweep</code> description and example</td></tr>
            <tr><td class='pending'>pending</td><td>Implement/Test</td><td class='subtask'><code>Text</code> description and example</td></tr>
            <tr><td class='pending'>pending</td><td>Implement/Test</td><td class='subtask'><code>Triangle</code> description and example</td></tr>

        <tr><td class='pending'>pending</td><td>Implement</td><td>Fix <code>inputFileName</code> and <code>outputFileName</code> in <code>ImageOptions</code> if needed.</td></tr>

        <tr><td class='pending'>pending</td><td>Implement/Test</td><td><code>Camera</code></td></tr>
        <tr><td class='pending'>pending</td><td>Implement</td><td class='subtask'><code>Camera.normal</code></td></tr>
            <tr><td class='pending'>pending</td><td>Implement/Test</td><td class='subtask'>Pseudo-primitive in CSG integration</td></tr>
            <tr><td class='pending'>pending</td><td>Implement/Test</td><td class='subtask'>Pseudo-primitive transform integration</td></tr>
        <tr><td class='pending'>pending</td><td>Implement/Test</td><td><code>copy()</code> method across classes, both shallow and deep</td></tr>
        <tr><td class='pending'>pending</td><td>Implement/Test</td><td><code>cpov.js</code>: More selective scope management, untangle internal dependencies</td></tr>
        <tr><td class='pending'>pending</td><td>Implement/Test</td><td><code>Lathe</code>: add check for correct minimum number of points</td></tr>
        <tr><td class='pending'>pending</td><td>Implement/Test</td><td><code>LightSource</code></td></tr>
        <tr><td class='pending'>pending</td><td>Implement/Test</td><td class='subtask'>Implement restrictions for area lights generally and the orient keyword in particular.</td></tr>
        <tr><td class='pending'>pending</td><td>Implement/Test</td><td class='subtask'><code>LightSource.looksLike</code></td></tr>
        <tr><td class='pending'>pending</td><td>Implement/Test</td><td class='subtask'><code>LightSource.mediaAttenuation</code></td></tr>
        <tr><td class='pending'>pending</td><td>Implement/Test</td><td class='subtask'><code>LightSource.mediaInteraction</code></td></tr>
        <tr><td class='pending'>pending</td><td>Implement/Test</td><td class='subtask'><code>LightSource.projectedThrough</code></td></tr>
        <tr><td class='pending'>pending</td><td>Implement/Test</td><td><code>Matrix, Vector, Color</code>: Use JS/SDL func in lieu of individual attributes</td></tr>
        <tr><td class='pending'>pending</td><td>Implement/Test</td><td><code>Matrix</code>: Improve constructor validation</td></tr>
        <tr><td class='pending'>pending</td><td>Implement/Test</td><td class='subtask'>Compact output format for <code>Triangle</code>s in <code>Mesh</code></td></tr>
        <tr><td class='pending'>pending</td><td>Implement/Test</td><td><code>Mesh/Triangle</code>: Improve constructor validation</td></tr>
        <tr><td class='pending'>pending</td><td>Implement/Test</td><td class='subtask'><code>uvVectors</code> member in <code>Triangle</code>, check <code>Mesh</code> compatibility.</td></tr>
        <tr><td class='pending'>pending</td><td>Implement/Test</td><td><code>Mesh2</code></td></tr>
        <tr><td class='pending'>pending</td><td>Implement/Test</td><td><code>Primitive</code></td></tr>
            <tr><td class='pending'>pending</td><td>Implement/Test</td><td class='subtask'><code>Primitive.interior</code></td></tr>
            <tr><td class='pending'>pending</td><td>Implement/Test</td><td class='subtask'><code>Primitive.interiorTexture</code></td></tr>
            <tr><td class='pending'>pending</td><td>Implement/Test</td><td class='subtask'><code>Primitive.photons</code></td></tr>
            <tr><td class='pending'>pending</td><td>Implement/Test</td><td class='subtask'><code>Primitive.radiosity</code></td></tr>
            <tr><td class='pending'>pending</td><td>Implement/Test</td><td class='subtask'><code>Primitive.texture</code></td></tr>
        <tr><td class='pending'>pending</td><td>Implement/Test</td><td>Management of array attributes</td></tr>
        <tr><td class='pending'>pending</td><td>Implement/Test</td><td>Default option in *Def codegen. Esp. splitUnion = true</td></tr>
        <tr><td class='pending'>pending</td><td>Implement/Test</td><td>Reorg: Move things needed for <code>codegen</code> to separate file not included at runtime</td></tr>
        <tr><td class='pending'>pending</td><td>Implement/Test</td><td>Execution: Optionally generate <code>.sh</code>/<code>.bat</code> files</td></tr>
        <tr><td class='pending'>pending</td><td>Implement/Test</td><td>Execution: Oversee execution directly</td></tr>
        <tr><td class='pending'>pending</td><td>Implement/Test</td><td>Intelligent handling of paths to files, esp. Windows</td></tr>
        <tr><td class='pending'>pending</td><td>Implement/Test</td><td>Reports</td></tr>

    </tbody>
</table>


<h4>Backlog</h4>

<table class='sgrid todo'>
    <thead>
        <tr>
            <th>Status</th>
            <th>Type</th>
            <th>Description</th>
        </tr>
    <thead><tbody>
        <!-- <tr><td></td><td></td><td></td></tr> -->
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>Additional splines, easing functions, esp. Catmull-Rom</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>Angles in the unit interval</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>Atmospheric effects</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>Color and texture SDL generation, i.e., in separate file to use directly with POV-Ray</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>Direct support for ffmpeg/avisynth + Google speech API</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>Drag in some color libraries, theme generators</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>Eric Haines' table of object intersections, collision detection</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>Extensive warn, info, debug output</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>Geometric query system</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>https://www.npmjs.com/package/ml-matrix (?)</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>Interior</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>Level-of-Detail</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>Macro/Function generation, i.e., in separate file to use directly with POV-Ray</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>Output frame range</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>Parametric types</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>Particle systems</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>Polyhedron library</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>Porting of functions in .inc files</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>Script execution on events</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>Script to parse as much as possible of POV-Ray .inc files into JS/cpov</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>Spline-builder UI</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>Stereo pseudo-cameras</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>Reorg: Script to pretty-print definition files</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>Wrap Array attributes with Proxies to enforce type</td></tr>
        <tr><td class='tbd'>TBD</td><td>TBD</td><td>Turtle graphics</td></tr>
    </tbody>
</table>


<h3>CephaloPOV Scene Graph</h3>

<p>Master objects are defined relative to the origin. More precisely, the origin is
their primary point of articulation. In each frame, they are transformed to
their current frame-state.</p>

<p>Possibly, a relationship between A and B is stated in the form of B's point of
articulation relative to some explicit or implicit point in A. In its most basic
form, this would amount to free movement of B relative to its attachment point
to A. PSII could provide a set of standard constraints, e.g., ball joint, hinge,
track, etc., which could be built upon or supplanted by the user.</p>

<p>This suggests a separate assembly process for objects with moving parts, which
means that ordinary native CSG objects can go ahead just fine. Converting them
into master objects amounts to just positioning them appropriately relative to
the origin after construction.</p>


<h3>Changelog</h3>

<p>Oh geez, not yet.</p>


</body>
</html>
