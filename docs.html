<!DOCTYPE html>
<html>
<head>
<meta charset="utf-8">
<title>CephaloPOV Documentation</title>
<style type="text/css">
	body,table,input { font: 10pt Arial,Helvetica,sans-serif; }
	div.code { white-space: pre; font: 10pt Consolas,Courier,fixed; background-color: #EEF; border: 1px solid #CCF; margin-top: 1em; padding: 1em; }
</style>
</head>
<body>
<h1>CephaloPOV Documentation</h1>

<div class='code'>var mk = $CP.factory;

console.log("$CP.currentScene = " + $CP.currentScene);
var s = mk("Scene");
console.log("$CP.currentScene = " + $CP.currentScene);
var b = mk("box");
var c1 = mk("VectorXYZ", [1,2,10]);
console.log(c1);
var c2 = mk("VectorXYZ");
c2.x = 3; c2.y = 5; c2.z = 15;
b.corner1 = c1;
b.corner2 = c2;
console.log(s.frame);
console.log(b.toSDL());

console.log("-------------------------------");

var cam = mk("camera");
cam.type = "perspective";
console.log(cam.toSDL());</div>

<h2>TODO</h2>

<h3>C+0</h3>

<ul>
	<li>$CP.typeCoerce:</li>
		<ul>
			<li>handle Vectors and simple Matrix types</li>
			<li>incorporate this into the Primitive set handler</li>
		</ul>
	<li>Primitive:</li>
		<ul>
		    <li>delete/destructor
		    <li>Implement children, finish, interior, material, normal, parent, photons, pigment, radiosity, texture, transform</li>
		    <li>Generic validation, type-specific validation</li>
		    <li>Camera pseudo-primitive transform integration</li>
		    <li>Find a way to suppress commonToSDL if there are no common attributes set</li>
		</ul>
	<li>Scene</li>
		<ul>
		    <li>Come up with generic SDL test include file</li>
		</ul>
	<li>Output loop</li>
	<li>Matrix</li>
		<ul>
		    <li>rotate and skew</li>
		</ul>
</ul>

<h3>C+1</h3>

<h4>Camera validation</h4>
<div class='code'>if(this.type === null) {
    throw new Error("[Camera]: Camera type is undefined.");
} else if(this.type == "cylinder" && this.cylinderType === null) {
    throw new Error("[Camera]: Camera type is cylinder but cylinderType is undefined.");
} else if(this.type == "orthographic" && (this.angle === null || (this.up === null && this.right === null))) {
    throw new Error("[Camera]: The orthographic camera requires either angle or up and right to be defined.");
}</div>


<pre>Vector: Allow entire vector to be produced by a JS or SDL function

restoreBaseTransform() / null handling for properties generally

ImageOptions
// TODO: boundingThreshold: convert zero to boolean on output
// TODO: constants: gets special handling
// TODO: endColumn: post check startColumn
// TODO: endRow: post check startRow
// TODO: startColumn: post check endColumn
// TODO: startRow: post check endRow

Docs to HTML
Feature and Maintenance tracks

Material
Texture
Interior
Camera

Cameras cannot be part of CSG unions, so come up with a way to link
a camera to an object so that transformations applied to the object
are automatically applied to the camera.</pre>

<h2>Old Notes</h2>

<pre>I. Finish enumeration/epitome
II. World
    A. Types
    B. Camera
    C. Lights (basic)
    D. Textures
    E. Objects (plane, box, cylinder, sphere) + re-eval for complex objects
    F. CSG Objects (generic)
    G. Macro generation

Basic pigment textures

Camera [...partial...]
Transformation [...partial...]
Lights [...partial...]
Matrices [...partial...]
    Transforms.inc
Include Files
    colors.inc [...partial...] (see bottom of this comment)

Test routines


Identifiers

    * 40 chars
    * /[A-Za-z][A-Za-z0-9_]{0,39}/

    Keywords are all lowercase, so a capital letter avoids potential collisions

TODO: Comments -- add emitter

    // single line
    /* multi
        line */
/*

Numeric Expressions
Vector Expressions

    <a, b, c, d, e>

Color Expressions
TODO: User-Defined Functions
TODO: Strings
TODO: Arrays
TODO: Splines

--------------------------------------------------------------------------------

Defer ATMOSPHERIC EFFECTS until later

--------------------------------------------------------------------------------

Objects/CSG...
Texture...

Pattern...
Media...

*Colors.inc

Color-space conversions
Chars.inc
Consts.inc
Debug.inc
Finish.inc
Functions.inc
Glass.inc
Golds.inc
Logo.inc
...etc.
// Color manipulation macros

// Takes Hue value as input, returns RGB vector.
#macro CH2RGB (HH)
   #local H = mod(HH, 360);
   #local H = (H < 0 ? H+360 : H);
   #switch (H)
      #range (0, 120)
         #local R = (120-  H) / 60;
         #local G = (  H-  0) / 60;
         #local B = 0;
      #break
      #range (120, 240)
         #local R = 0;
         #local G = (240-  H) / 60;
         #local B = (  H-120) / 60;
      #break
      #range (240, 360)
         #local R = (  H-240) / 60;
         #local G = 0;
         #local B = (360-  H) / 60;
      #break
   #end
   <min(R,1), min(G,1), min(B,1)>
#end

// Takes RGB vector, Max component, and Span as input,
// returns Hue value.
#macro CRGB2H (RGB, Max, Span)
   #local H = 0;
   #local R = RGB.red;
   #local G = RGB.green;
   #local B = RGB.blue;
   #if (Span>0)
      #local H = (
         + (R = Max & G != Max ? 0 + (G - B)/Span : 0)
         + (G = Max & B != Max ? 2 + (B - R)/Span : 0)
         + (B = Max & R != Max ? 4 + (R - G)/Span : 0)
      )*60;
   #end
   H
#end

// Converts a color in HSL color space to a color in RGB color space.
// Input:  < Hue, Saturation, Lightness, Filter, Transmit >
// Output: < Red, Green, Blue, Filter, Transmit >
#macro CHSL2RGB(Color)
   #local HSLFT = color Color;
   #local H = (HSLFT.red);
   #local S = (HSLFT.green);
   #local L = (HSLFT.blue);
   #local SatRGB = CH2RGB(H);
   #local Col = 2*S*SatRGB + (1-S)*<1,1,1>;
   #if (L<0.5)
      #local RGB = L*Col;
   #else
      #local RGB = (1-L)*Col + (2*L-1)*<1,1,1>;
   #end
   <RGB.red,RGB.green,RGB.blue,(HSLFT.filter),(HSLFT.transmit)>
#end

// Converts a color in RGB color space to a color in HSL color space.
// Input:  < Red, Green, Blue, Filter, Transmit >
// Output: < Hue, Saturation, Lightness, Filter, Transmit >
#macro CRGB2HSL(Color)
   #local RGBFT = color Color;
   #local R = (RGBFT.red);
   #local G = (RGBFT.green);
   #local B = (RGBFT.blue);
   #local Min = min(R,min(G,B));
   #local Max = max(R,max(G,B));
   #local Span = Max-Min;
   #local L = (Min+Max)/2;
   #local S = 0;
   #if( L!=0 & L!=1 )
      #local S = Span / ( L<0.5 ? (L*2) : (2-L*2) );
   #end
   #local H = CRGB2H (<R,G,B>, Max, Span);
   <H,S,L,(RGBFT.filter),(RGBFT.transmit)>
#end

// Converts a color in HSV color space to a color in RGB color space.
// Input:  < Hue, Saturation, Value, Filter, Transmit >
// Output: < Red, Green, Blue, Filter, Transmit >
#macro CHSV2RGB(Color)
   #local HSVFT = color Color;
   #local H = (HSVFT.red);
   #local S = (HSVFT.green);
   #local V = (HSVFT.blue);
   #local SatRGB = CH2RGB(H);
   #local RGB = ( ((1-S)*<1,1,1> + S*SatRGB) * V );
   <RGB.red,RGB.green,RGB.blue,(HSVFT.filter),(HSVFT.transmit)>
#end

// Converts a color in RGB color space to a color in HSV color space.
// Input:  < Red, Green, Blue, Filter, Transmit >
// Output: < Hue, Saturation, Value, Filter, Transmit >
#macro CRGB2HSV(Color)
   #local RGBFT = color Color;
   #local R = (RGBFT.red);
   #local G = (RGBFT.green);
   #local B = (RGBFT.blue);
   #local Min = min(R,min(G,B));
   #local Max = max(R,max(G,B));
   #local Span = Max-Min;
   #local H = CRGB2H (<R,G,B>, Max, Span);
   #local S = 0; #if (Max!=0) #local S = Span/Max; #end
   <H,S,Max,(RGBFT.filter),(RGBFT.transmit)>
#end

#version Colors_Inc_Temp;
#end
Master objects are defined relative to the origin. More precisely, the origin is
their primary point of articulation. In each frame, they are transformed to
their current frame-state.

Possibly, a relationship between A and B is stated in the form of B's point of
articulation relative to some explicit or implicit point in A. In its most basic
form, this would amount to free movement of B relative to its attachment point
to A. PSII could provide a set of standard constraints, e.g., ball joint, hinge,
track, etc., which could be built upon or supplanted by the user.

This suggests a separate assembly process for objects with moving parts, which
means that ordinary native CSG objects can go ahead just fine. Converting them
into master objects amounts to just positioning them appropriately relative to
the origin after construction.
In no particular order:

* Scene graph
* Spline calculations, including Catmull-Rom
* Color calculations from colors.inc, plus others from JS mixers
* Eric Haines' table of object intersections, collision detection
* Derivative relative points
* Callbacks in lieu of literal values
* SDL macro generation
* Stereo camera type
* Parametric type factory using predefined parameters
* Composite types
* Inclusion of all include types
* Level-of-Detail system
* Particle systems

TODO:

Object t-order

.clone
.materialize
Generate:
    Scene files .pov
    Ini files
    Shell script (.sh/.bat)



npm install -g sloc        ... cronify

Primitive.toString()
	add identifier/name, plus autogenerated defaults
    tie into subclass toString() methods
	add CSG parent reference
    respect active flag
Figure out Scene object
	object containing identifier: object relations

Full test of ImageOptions
</pre>

<h2>Changelog</h2>


</body>
</html>